/*
 Copyright (C) 2008 ha55ii, http://dan-ball.jp/
 The games source code use is prohibition.
*/
var aa, ca = 0,
	da = window,
	ea = 512,
	fa = 384,
	ga = 0,
	ha, la, ma, na, oa, qa, ra, sa, ua = 0,
	va = 0,
	xa = new wa,
	Aa = new wa,
	Ba = new wa,
	Da = new wa,
	Fa = new wa,
	Ga = new wa,
	Ha, Ia, Ka = [0, 0, 0, 0, 0, 0, 0, 0],
	La, Ma = new wa,
	Na = new wa,
	Pa = Array(13),
	Qa = new wa,
	Ra = new wa,
	Ua = new wa,
	Va = new wa,
	Wa = new wa,
	Za = new wa,
	$a = new wa,
	cb = new wa,
	db = new wa,
	fb = new wa,
	gb = new wa,
	hb = new wa,
	ib = new wa,
	jb = new wa,
	kb = new wa,
	lb = new wa,
	cloudImg = new wa,
	mapWidth = 78 * 16,
	mapHeigth = 16 * 16,
	mapCloudPos = 384,
	f = 0,
	mb = 0,
	h = 0,
	nb = 0,
	sb = 0,
	l = 0,
	tb = 3,
	ub = !1,
	vb = 0,
	wb = 0,
	xb = 0,
	yb = [0, 0, 0, 0],
	zb = [0, 0, 0, 0],
	Ab = [0, 0, 0, 0],
	Eb = [0, 0, 0, 0],
	Fb = 0,
	Gb = 0,
	Hb = 0,
	Ib = 0,
	Jb = 0,
	Kb = 100,
	Lb = 0,
	Mb = [1, 1],
	Nb = [1, 1],
	$b = [0, 0],
	ac = [0, 0, 0, 0, 0, 0, 0, 0],
	cc = 0,
	dc = 0,
	ec = [0, 0, 0, 0, 0, 0, 0, 0],
	p = [50, 50, 50, 50, 50, 50, 50, 50],
	fc = [0, 0, 0, 0, 0, 0, 0, 0],
	gc = [0, 0, 0, 0, 0, 0, 0, 0],
	hc = [0, 0, 0, 0, 0, 0, 0, 0],
	ic = [0, 0, 0, 0, 0, 0, 0, 0],
	jc = [0, 0, 0, 0, 0, 0, 0, 0],
	kc = [50, 50, 50, 50, 50, 50, 50, 50],
	lc = [0, 0, 0, 0, 0, 0, 0, 0],
	mc = [0, 0, 0, 0, 0, 0, 0, 0],
	nc = [0, 0, 0, 0, 0, 0, 0, 0],
	oc = [0, 0, 0, 0, 0, 0, 0, 0],
	pc = [0, 0, 0, 0, 0, 0, 0, 0],
	qc = [0, 0, 0, 0, 0, 0, 0, 0],
	rc = [0, 0, 0, 0, 0, 0, 0, 0],
	tc = [0, 0, 0, 0, 0, 0, 0, 0],
	uc = [1, 1, 1, 1, 1, 1, 1, 1],
	vc = 0,
	wc = 0,
	xc = 0,
	yc = 0,
	zc = 1,
	Ac = [0, 0, 0, 0, 0, 0, 0, 0],
	Bc = [0, 0, 0, 0, 0, 0, 0, 0],
	Cc = [0, 0, 0, 0, 0, 0, 0, 0],
	priestAuraTimer = [0, 0, 0, 0],
	boxerCombo = [0, 0, 0, 0], //BOXER combo hit amount
	boxerATmodifier = [1, 1, 1, 1] //BOXER AT modifier that increases with combo
	swarm = [1, 1, 1, 1], //SUMMONER Size of summoner's swarm
	selectedSummon = [0, 0, 0, 0], //The currently selected summon slot to fill or replace with a summon
	wraithSoul = [0, 0, 0, 0], //REAPER stat for Wraith Soul power and chance
	scytheClock = [0, 0, 0, 0], //A clock for some scythe movement
	scytheFlightDir = Array(4); //Scythe's flight direction
	for (i = 0; i < 4; i++) scytheFlightDir[i] = new Qg, scytheFlightDir[i].x = 0, scytheFlightDir.y = 0;
	errorName = 0,
	errorCol = 0,
	q = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	Dc = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	Ec = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	s = 4,
	Fc = 16,
	Gc = 40,
	Hc = 41,
	Ic = 13,
	Jc = "Stickman;Boxer;Gladiator;Sniper;Magician;Priest;Gunner;Whipper;Angel;;Summoner;Reaper".split(";"), //SUMMONER REAPER
	Kc = "123456789S".split(""),
	Lc = [ //Shops
		[//Town
			[3, 14, 24, 25, 26, 27, 28, 29, 30, 31, 32, 0],
			[4, 15, 33, 34, 35, 36, 37, 38, 39, 40, 41, 0],
			[5, 16, 42, 43, 44, 45, 46, 47, 48, 49, 50, 0],
			[6, 17, 51, 52, 53, 54, 55, 56, 57, 58, 59, 0],
			[7, 18, 60, 61, 62, 63, 64, 65, 66, 67, 68, 0],
			[8, 19, 69, 70, 71, 72, 73, 74, 75, 76, 77, 0],
			[9, 20, 78, 79, 80, 81, 82, 83, 84, 85, 86, 0],
			[10, 21, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0],
			[11, 22, 96, 97, 98, 99, 100, 101, 102, 103, 104, 0],
			[12, 23, 105, 106, 107, 108, 109, 110, 111, 112, 113, 0]
		],
		[//Compo Shop
			[124, 126, 128, 130, 132, 0, 0, 0, 0],
			[134, 136, 138, 140, 142, 0, 0, 0, 0],
			[144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 205, 0],
			[164, 166, 168, 170, 172, 174, 176, 178, 0],
			[182, 184, 186, 188, 0, 0, 0, 0, 0],
			[190, 192, 194, 207, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0]
		],
		[//Secret Shop
			[114],
			[115],
			[116],
			[117],
			[118],
			[119],
			[120],
			[121],
			[122],
			[123]
		],
		[//
			[0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0]
		]
	],
	Mc = 0,
	Nc = 1,
	Oc = 2,
	Pc = 3,
	Qc = 4,
	Rc = 5,
	Sc = 6,
	Tc = 10,
	Uc = 11,
	Vc = 12,
	Wc = 14,
	Xc = 15,
	Yc = 16,
	Zc = 19,
	$c = 34,
	ad = 35,
	bd = 36,
	cd = 37,
	dd = 39,
	ed = 40,
	fd = 44,
	hd = 7,
	t = 8,
	id = 9,
	jd = 10,
	kd = 11,
	ld = 1,
	md = 2,
	nd = 3,
	od = 4,
	pd = 5,
	qd = 6,
	rd = 7,
	sd = 8,
	td = 9,
	ud = 10,
	vd = 11,
	wd = 12,
	xd = 37,
	yd = 13,
	zd = 14,
	Ad = 15,
	Bd = 16,
	Cd = 17,
	Dd = 18,
	Ed = 19,
	Fd = 20,
	Gd = 21,
	Hd = 22,
	Id = 23,
	Jd = 24,
	Kd = 25,
	Ld = 26,
	Md = 27,
	Nd = 28,
	Od = 29,
	Pd = 32,
	Qd = 33,
	Rd = 34,
	Sd = 35,
	Td = 36,
	Ud = 38,
	Vd = 39,
	Wd = 40,
	Xd = 41,
	Yd = 42,
	Zd = 43,
	$d = 44,
	ae = 45,
	be = 46,
	ce = 47,
	de = 48,
	ee = 49,
	compoHematite = 50, //ELEMENT compo effect ID
	compoCarnelian = 51,
	compoPhysTr = 52, //Transmutations
	compoFireTr = 53,
	compoIceTr = 54,
	compoThunTr = 55,
	compoPoisTr = 56,
	compoFrzTr = 57,
	compoGravTr = 58,
	compoDrainTr = 59,
	compoGlitchTr = 60,
	compoRnbw = 61,
	compoGravWard = 62,
	compoBlademaster = 63,
	u = Array(113);
//Item image guide:
//Glove1, 2, 3, 4, Sword1, 2, 3, 4, Bow1, 2, 3, 4, 5, Orb1, 2, 3, 4, Staff1, 2, 3, 4, Gun1, 2, 3, 4, 5, 6, 7, 8, 9, Whip1, 2, 3, 4, Ring1, 2, 3, 4, Spider, Snake, Bird, Dragon, Fish, Eye, Hydra, Dragon2, Armor, Elemental, Scythe1, 2, 3, 4, Stone, Crystal, Jewel, Medal, Charm, Spirit, Rnbw, Card, Quick, Long, Catap, Spectre, Frog, Bullet, Explosion, Crit, Bersrk, Big, Knckback, Bounce, Katana, Heal, Ring, Windblade, Transmute
//     3, 4, 5, 6,      7, 8, 9,10,   11,12,13,14,15,   16,17,18,19,     20,21,22,23,   24,25,26,27,28,29,30,31,32,    33,34,35,36,    37,38,39,40,     41,    42,   43,     44,   45,  46,    47,      48,    49,        50,      51,52,53,54,    55,      56,    57,    58,    59,     60,   61,   62,    63,   64,    65,      66,   67,     68,        69,   70,     71,  72,       73,     74,     75,   76,   77,		   78,		  79
u[0] = ["NONE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
u[13] = ["", 0, 0, 3, 2, 9, 0x888888, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
u[1] = ["gold", 0, 0, 1, 0, 0, 0xFFFFFF, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
u[2] = ["onigiri", 0, 0, 2, 0, 0, 0xFFFFFF, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
//Boxer
u[3] = ["Tattered Glove",0,100,4,3,1,14646882,0,0,0,1,3,0,0,10,25,15];
u[14] = ["Metal Glove",1,200,4,3,1,8288882,0,0,0,5,9,0,0,10,40,15];
u[24] = ["Gunpowder Glove",1,300,4,3,1,16008459,0,6,1,3,4,1,0,10,30,15,0,2,2868135179,1,32,32,24,24,0,0,25,15,0,100,0,0,0,1,0,8,0,0,4,6];
u[25] = ["Static Glove",1,400,4,3,1,16777088,0,9,0,3,4,3,5,10,30,15,1,20,2868903808,1,32,32,16,16,10,0,30,10,0,95,0,0,0,3,0,8,0,0,1,9];
u[26] = ["Icicle Glove",1,500,4,3,1,11793407,0,3,0,3,4,2,10,10,30,15,1,31,2863920127,1,8,16,12,12,30,5,15,10,0,100,0,0,0,2,15,8,0,0,3,5];
u[27] = ["Wave Glove",1,600,4,3,1,5898139,0,109,0,3,4,6,10,10,30,15,1,11,2858024859,1,24,16,12,12,0,0,10,10,0,100,0,2,0,0,0,10,0,0,1,3];
u[28] = ["Bulletpunch",2,700,4,3,1,7311005,0,0,0,6,12,0,0,5,60,15];
u[29] = ["Snakeskin Glove",2,800,4,3,1,6649628,0,3,0,5,6,2,10,7,45,15,1,9,4290167984,1,16,32,16,16,0,10,30,20,0,95,0,0,0,4,10,15,0,0,1,1];
u[30] = ["Gravity Glove",2,900,4,3,1,7480029,0,4,0,5,6,2,40,7,45,15,1,1,3715244765,1,8,16,8,8,0,10,120,10,5,100,0,0,0,6,10,15,0,0,4,6];
u[31] = ["Lightning Glove",2,1000,4,3,1,7320831,0,5,0,5,6,3,5,7,45,15,1,10,3718959871,1,16,24,12,12,20,0,20,10,0,100,0,0,0,3,20,25,0,0,1,9];
u[32] = ["Vampire Glove",2,1100,4,3,1,11993088,0,6,0,5,6,1,1,7,45,15,0,27,4290183168,1,32,32,24,24,0,5,10,60,0,100,0,0,0,7,50,25,0,0,28,32];
u[114] = ["Welcome to",0,0,4,3.25,1,5848660,0,1,0,5,6,1,1,5,49,15,0,34,2862547103,2,32,32,24,32,30,0,180,60,0,100,1,0,8,8,30,19,0,0,4,9,0,0,0,4294967295,1,16,16,16,16,0,0,0,0,0,100,0,0];

//Gladiator
u[4] = ["Dull Sword",0,100,5,7,2,11247262,0,0,0,2,5,0,0,20,30,30];
u[15] = ["Sharp Sword",1,200,5,7,2,14671579,0,0,0,10,15,0,0,20,30,30];
u[33] = ["Bolt Sword",1,300,5,7,2,16776960,0,7,0,6,10,1,50,20,30,30,1,10,2868903680,1,16,24,12,12,0,0,10,10,0,100,0,0,0,3,0,10,0,0,1,9,5];
u[34] = ["Heat Sword",1,400,5,7,2,16736311,0,7,0,6,10,1,10,20,30,30,1,6,2868863031,1,16,32,16,16,0,0,60,10,0,99,0,0,0,1,30,10,0,0,3,4,5];
u[35] = ["Rusty Sword",1,500,5,7,2,10772576,0,7,0,6,10,1,10,20,30,30,1,4,4287567896,1,8,32,12,12,0,0,10,10,0,100,0,0,0,4,10,14,0,0,1,1,3];
u[36] = ["Snowy Sword",1,600,5,7,2,14677247,0,109,0,6,10,1,5,20,30,30,0,13,4292867327,1,16,16,12,12,0,10,120,10,10,95,0,1,0,2,10,14,0,0,1,2,9];
u[37] = ["Steel Sword",2,700,5,7,2,8037562,0,0,0,12,24,0,0,20,30,35];
u[38] = ["Wind Sword",2,800,5,7,2,10878952,0,7,0,8,12,1,10,20,30,30,0,30,2863005672,1,32,32,28,28,0,0,90,10,0,105,1,0,0,10,70,20,0,0,10,12,3];
u[39] = ["Melting Sword",2,900,5,7,2,16728064,0,1,0,8,12,1,1,20,30,30,0,13,4009705472,2,24,24,8,8,0,5,90,10,5,100,0,1,0,1,80,70,0,0,3,5,30];
u[40] = ["Gravstream Sword",2,1000,5,7,2,9842175,0,7,0,8,12,1,25,20,30,30,1,1,2858090679,1,8,24,12,12,0,0,90,10,10,100,0,0,0,6,10,45,0,0,2,3,15];
u[41] = ["Blood Sword",2,1100,5,7,2,12124160,0,7,0,8,12,1,1,20,30,30,1,20,4290314240,1,16,32,12,12,0,0,10,10,0,100,0,0,0,7,25,70,0,0,2,3,50];
u[115] = ["Pg.gladiatorGreatslash()",0,0,5,7.25,2,7637090,0,0,0,9,31,0,0,17,32,37,0,0,4294967295,1,16,16,16,16,0,0,0,0,0,100,0,0,0,8,50];

//Sniper
u[5] = ["Flimsy Bow",0,100,6,11,3,10198149,0,4,0,2,3,1,100,35,40,90,1,3,4288388229,1,16,16,8,8,0,0,300,10,5,100];
u[16] = ["Crossbow",1,200,6,12,3,12301725,0,3,0,5,7,1,100,40,45,120,1,3,0xFFBBB59D,1,16,16,8,8,0,0,300,10,5,100];
u[42] = ["Bomb Arrow",1,300,6,11,3,4930877,0,4,0,4,5,1,70,30,40,90,1,3,4283120957,1,16,16,8,8,0,0,300,10,5,100,0,0,0,1,0,12,3,1,3,6,3,1,6,2868472064,1,16,32,16,16,6,5,20,10,0,105,0,0];
u[43] = ["Triple Crossbow",1,400,6,14,3,12301725,0,503,0,3,5,3,100,45,50,120,1,3,4290491805,1,16,16,8,8,0,0,300,10,5,100];
u[44] = ["Slowness Arrow",1,500,6,11,3,9297116,0,4,0,4,5,1,80,30,40,90,1,3,4287487196,1,16,16,8,8,0,0,300,10,5,100,0,0,0,2,25,12,7,0,1,2,5,1,6,2860902375,1,16,16,12,12,0,5,30,10,0,75,1,0];
u[45] = ["Thunderbolt Crossbow",1,600,6,12,3,16776960,0,3,0,4,6,1,100,40,45,120,1,3,4294967040,1,16,16,8,8,0,0,300,10,0,100,0,0,0,3,0,20,5,0,1,5,5,1,10,2868903680,1,16,16,8,8,10,0,60,10,0,100,0,0];
u[46] = ["Double Big Arrow",2,700,6,13,3,13814410,0,4,1,6,10,2,80,30,40,90,1,3,4292004490,1,24,24,20,20,10,0,300,10,5,100];
u[47] = ["Poison Gas Arrow",2,800,6,11,3,8097085,0,4,0,5,6,1,80,30,40,90,1,3,4286287165,1,16,16,8,8,0,0,300,10,5,100,0,0,0,4,30,24,1,0,1,1,1,0,6,2859568445,1,64,32,48,24,0,5,240,60,0,100,1,0];
u[48] = ["Crystalline Arrow",2,900,6,11,3,11048447,0,4,0,5,6,1,80,30,40,90,1,3,4289238527,1,16,16,8,8,0,0,300,10,5,100,0,0,0,0,0,24,7,0,3,3,16,1,31,2865071359,2,16,24,12,12,30,0,120,20,0,35,0,2];
u[49] = ["Gravity Crossbow",2,1000,6,12,3,7078105,0,3,0,5,8,1,100,40,45,120,1,3,4285268185,1,16,16,8,8,0,0,300,10,0,100,0,0,0,6,15,26,7,0,6,10,5,1,1,2861902847,1,8,24,12,12,0,5,120,10,-25,80,1,0];
u[50] = ["Burning Arrow",2,1100,6,11,3,7549233,0,4,0,5,6,1,60,30,40,90,1,3,4285739313,1,16,16,8,8,0,0,300,10,5,101,0,0,0,1,40,26,2,0,3,4,25,0,24,2868859648,2,16,16,12,12,0,0,120,20,15,90,0,1];
u[116] = ["CLICK HERE NOW FOR FREE",0,0,6,11.75,3,0,0,3,0,2,3,1,80,17,41,113,0,39,4294967295,1,16,16,8,8,30,0,300,10,0,100,0,0,0,8,25,29,2,0,6,8,33,0,34,2868903935,2,16,16,12,16,60,0,127,37,0,95,1,0];

//Magician
u[6] = ["Lesser Magic Bolt",0,100,7,16,4,13125375,0,3,0,3,10,1,30,80,90,90,1,16,2865252095,1,12,16,8,8,0,0,300,10,0,100];
u[17] = ["Bouncing Burst",1,200,7,16,4,65280,0,3,0,5,12,1,70,70,80,90,1,20,4278255360,2,32,24,8,8,0,0,300,10,2,99,0,2];
u[51] = ["Snowball",1,300,7,16,4,15531007,0,4,0,5,9,1,45,80,90,90,0,2,4293721087,1,16,16,8,8,0,0,300,10,5,100,0,0,0,2,30,0,4,0,1,2,5,0,13,4293721087,1,16,16,8,8,0,10,60,20,10,100,0,0];
u[52] = ["Lingering Sparks",1,400,7,16,4,16777079,0,5,0,1,20,4,5,80,90,90,0,15,2868903799,1,16,16,8,8,60,10,600,20,0,95,0,2,0,3,0,0,0,0,0,0,0,0,0,0,1,16,16,8,8,0,0,0,0,0,100,0,0];
u[53] = ["Sludge",1,500,7,16,4,3766608,0,4,0,0,0,2,50,80,90,90,0,16,4281956688,2,32,16,16,32,10,180,180,10,5,99,0,1,0,4,6,0,2,0,1,1,10,0,13,2855893328,2,16,16,8,8,0,0,30,30,5,100,0,1];
u[54] = ["Graviton",1,600,7,16,4,6881490,0,6,0,16,20,2,30,80,90,90,0,12,4288032255,1,16,16,12,12,20,10,60,30,0,105,1,0,30,6,15];
u[55] = ["Razor Wind",2,700,7,16,4,10878952,0,3,0,1,1,1,50,120,135,90,0,30,2863005672,1,32,32,24,24,0,0,180,30,-2,95,0,2,0,10,60,0,2,0,3,6,10,1,35,2863005672,1,16,16,12,12,0,5,30,10,0,105,1,0];
u[56] = ["High Voltage",2,800,7,16,4,16776960,0,5,0,1,30,1,5,80,90,90,1,10,2868903680,1,24,24,16,16,0,0,300,10,0,100,0,2,0,3,50,0,7,0,1,10,5,1,10,2859972863,2,16,12,12,12,0,5,30,10,0,80,0,2];
u[57] = ["Magma Spray",2,900,7,16,4,16728064,0,1004,0,2,3,9,20,120,135,50,0,13,4009705472,2,24,24,8,8,15,5,120,10,5,97,0,1,0,1,50];
u[58] = ["Blood Rain",2,1000,7,16,4,10878976,0,408,0,4,8,16,1,120,135,90,0,20,4003856384,1,16,16,12,12,120,0,120,10,5,100,0,0,0,7,25];
u[59] = ["Ice Shredder",2,1100,7,16,4,12316927,0,6,0,0,0,1,20,120,135,90,0,0,4005294335,1,32,32,16,16,0,46,45,10,0,100,1,0,0,2,10,0,2,0,4,6,50,1,9,2864443647,2,24,24,12,12,0,10,20,10,0,100,1,0];
u[117] = ["(-- - --)",0,0,7,16.25,4,3552850,0,9,0,5,9,2,60,68,103,97,0,12,2868838400,1,16,16,8,8,30,5,300,10,0,60,0,2,80,8,33,0,1,1,3,11,1,0,33,3996990836,2,32,32,24,24,0,5,10,61,0,100,1,0];

//Priest
u[7] = ["Some Random Stick",0,100,8,20,5,13730862,0,6,0,1,2,1,0,80,90,60,0,15,4291920942,2,24,24,24,24,0,0,100,40,0,100];
u[18] = ["Apprentice Staff",1,200,8,20,5,8553215,0,6,0,3,4,1,0,80,90,70,0,15,2860679935,2,24,24,24,24,0,0,100,40,0,100];
u[60] = ["Slowness Staff",1,300,8,20,5,10803455,0,6,0,2,3,1,0,80,90,70,0,6,2862930175,2,16,16,16,16,0,0,100,40,0,100,0,0,0,2,35];
u[61] = ["Gas Staff",1,400,8,20,5,7706368,0,6,0,1,1,1,0,80,90,70,0,6,4000683776,2,40,24,16,16,0,30,100,40,0,100,0,0,0,4,12];
u[62] = ["Heavy Staff",1,500,8,20,5,6514586,0,6,0,8,10,1,0,100,110,110,0,15,4284704666,2,32,32,16,16,0,0,100,40,0,100];
u[63] = ["Ember Staff",1,600,8,20,5,16731392,0,6,0,2,3,1,0,80,90,70,0,5,2868858112,2,24,24,16,16,0,0,60,40,5,100,0,1,0,1,40];
u[64] = ["Gravity Staff",2,700,8,20,5,5701806,0,6,0,2,3,1,0,80,90,70,0,12,4283891886,2,24,24,24,24,0,0,100,40,0,100,0,0,0,6,15];
u[65] = ["Freezing Staff",2,800,8,20,5,14286847,0,6,0,2,3,1,0,80,90,70,0,8,4292476927,2,12,12,12,12,0,0,100,40,0,100,0,0,0,5,30];
u[66] = ["Jolt Staff",2,900,8,20,5,16777088,0,5,0,1,9,1,5,80,90,70,1,10,2868903808,2,16,16,12,12,0,0,100,40,0,100,0,0,0,3,10];
u[67] = ["Drain Staff",2,1000,8,20,5,11010048,0,6,0,2,3,1,0,80,90,70,0,15,4289200128,2,24,24,24,24,0,0,100,40,0,100,0,0,0,7,100];
u[68] = ["Swift Staff",2,1100,8,20,5,65465,0,9,0,1,3,1,1,40,50,70,1,2,2852192185,2,32,4,16,16,0,0,100,40,0,100];
u[118] = ["  Oracle machine",0,0,8,19.75,5,14154735,0,11,0,1,2,3,30,77,91,74,0,34,4007132143,1,16,16,8,12,47,0,30,10,0,87,0,2,0,8,45];

//Gunner
u[8] = ["Rusty Sidearm",0,100,9,24,6,9268052,0,3,0,3,5,1,30,30,40,60,1,17,4290822336,1,16,16,8,8,0,0,60,10,0,100,0,0,0,0,0];
u[19] = ["Polished Pistol",1,200,9,32,6,12508135,0,203,0,2,4,2,30,40,50,70,1,17,4290698215,1,16,16,8,8,10,0,60,10,0,100,0,0,0,0,3];
u[69] = ["Rubberball Cannon",1,300,9,28,6,4344162,0,3,0,20,30,1,20,50,60,60,0,2,4282534242,1,16,16,12,12,0,0,180,10,5,100,0,2,0,0,0,10];
u[70] = ["Shock Rifle",1,400,9,27,6,3653375,0,103,0,1,30,3,50,60,70,60,1,10,2855780095,2,12,24,10,10,10,0,180,10,0,100,0,0,0,3,0,12];
u[71] = ["Ice Mist",1,500,9,30,6,12910591,0,3,0,0,0,1,10,60,70,50,0,6,4291100671,2,40,24,16,16,0,180,180,30,0,99,0,1,0,2,15,15,2,0,2,3,15,0,6,2868903935,2,24,16,12,12,0,0,10,10,0,0,0,0];
u[72] = ["Alien Gun",1,600,9,29,6,6619319,0,3,0,60,80,1,10,80,90,120,1,11,2858746039,1,16,24,12,12,0,0,180,10,0,110,1,0,0,6,7,20,2,0,0,0,100,0,13,2858746039,2,24,24,16,16,0,2,1,20,0,0,0,0];
u[73] = ["Bomb",2,700,9,28,6,4473924,0,4,0,1,1,1,30,50,60,60,0,12,4282664004,1,32,32,12,12,0,0,120,10,5,99,0,1,0,1,0,16,4,1,18,24,5,1,22,2868864512,2,12,24,12,12,5,0,10,30,0,110,1,0];
u[74] = ["Pulse Gun",2,800,9,31,6,11141226,0,3,0,6,10,1,30,10,15,60,0,14,2868838559,2,16,16,12,12,0,5,120,30,0,98,0,0,0,0,0,7,1,1,4,8,1,0,2,2868838559,2,32,32,16,16,0,0,5,10,0,1,0,0];
u[75] = ["Poison Bubbler",2,900,9,30,6,32832,0,603,0,1,1,3,20,40,50,50,0,28,2852159552,2,16,16,12,12,30,0,180,30,-3,99,0,2,0,4,18,15,1,0,1,2,1,0,0,0,1,16,16,16,16,0,0,5,0,0,1,0,0];
u[76] = ["Plasma Cutter",2,1000,9,25,6,8991282,0,2,0,6,12,5,30,5,10,10,1,22,4287889407,2,16,32,12,12,10,0,30,10,0,50,0,0,0,1,30,8];
u[77] = ["Loud Gun",2,1100,9,24,6,8307367,0,3,0,30,40,1,30,50,60,70,1,11,2856517541,2,24,24,16,16,0,0,120,10,0,99,0,2,0,10,100,20,7,0,5,10,9,1,11,2856517541,2,16,16,12,12,0,0,60,10,0,99,0,2];
u[119] = ["42",0,0,9,24.5,6,16777215,0,3,0,42,42,1,42,42,42,42,0,34,4294967295,1,24,24,12,18,42,0,42,42,0,100,0,0,42,8,42,42,1,0,42,42,1,0,34,4294967295,1,32,32,16,24,42,0,42,42,0,100,0,0];

//Whipper
u[9] = ["Leather Whip",0,100,10,33,7,10903366,0,0,0,1,4,0,0,20,25,40];
u[20] = ["Reinforced Whip",1,200,10,33,7,7764886,0,0,0,4,8,0,0,15,20,40];
u[78] = ["Snowy Whip",1,300,10,33,7,14677247,0,9,0,3,6,9,3,15,20,40,0,13,4292867327,1,16,16,12,12,10,10,90,10,10,95,0,1,0,2,15,16,0,0,2,3];
u[79] = ["Spark Whip",1,400,10,33,7,16777088,0,8,0,3,6,4,1,15,20,40,0,15,2868903808,1,16,16,12,12,30,0,120,10,15,100,0,1,0,3,0,20,0,0,1,20];
u[80] = ["Sludge Whip",1,500,10,33,7,3766608,0,804,0,3,6,1,30,20,25,40,0,16,2855893328,2,32,16,12,12,10,0,120,10,10,99,0,1,0,4,30,30,0,0,1,2];
u[81] = ["Crystal Whip",1,600,10,33,7,16292863,0,9,0,3,6,9,15,15,20,40,1,31,2868419583,2,16,24,12,12,16,0,120,20,0,35,0,2,0,0,0,30,0,0,5,8];
u[82] = ["Long Whip",2,700,10,33,7,8166582,0,0,0,10,12,0,0,20,25,60];
u[83] = ["Gunpowder Whip",2,800,10,33,7,7166040,0,6,1,5,10,10,20,15,20,40,0,2,2868135179,2,16,16,12,12,20,0,10,10,0,100,0,0,0,1,0,90,1,0,2,4,1,0,2,4294901760,2,8,8,16,16,0,2,1,20,0,100,0,0];
u[84] = ["Graviton Whip",2,900,10,33,7,8388863,0,6,0,5,10,12,40,15,20,40,0,12,4286578943,1,16,16,8,8,60,0,90,10,-1,105,1,0,40,6,10,60,0,0,8,12];
u[85] = ["Blood Vessel Whip",2,1000,10,33,7,11343382,0,9,0,5,10,5,5,15,20,40,1,20,2863470102,2,24,24,12,12,5,15,90,10,10,95,0,1,0,7,50,70,0,0,10,15];
u[86] = ["Burning Whip",2,1100,10,33,7,7549233,0,3,0,5,10,3,50,15,20,40,0,12,4285739313,1,16,16,8,8,20,0,180,10,15,95,0,1,0,1,30,120,2,0,2,3,10,0,5,2868854784,2,8,16,8,8,0,0,60,10,15,90,0,1];
u[120] = ["accuracyzero",0,0,10,33.5,7,8579966,0,3,0,3,13,4,10,14,21,47,0,34,2290281342,1,16,16,8,12,60,0,47,56,5,100,1,0,32,8,24,73,0,0,7,17];

//Angel
u[10] = ["Weak Halo",0,100,11,37,8,13563135,30,0,0,3,4,0,0,20,30,60];
u[21] = ["Cherub's Halo",1,200,11,37,8,16580473,20,0,0,5,10,0,0,20,30,60];
u[87] = ["Shock Halo",1,300,11,37,8,16443397,25,9,0,4,6,15,5,20,30,60,1,10,2868570117,1,12,8,8,8,15,5,30,30,0,75,0,0,0,3,0,60,0,0,1,15];
u[88] = ["Hail Halo",1,400,11,37,8,10939391,25,8,0,4,6,16,5,20,30,60,0,38,2863066111,2,12,12,8,8,60,0,60,30,5,100,0,0,0,2,35,80,0,0,7,8];
u[89] = ["Scorched Halo",1,500,11,37,8,9578279,25,9,0,4,6,12,1,20,30,60,1,23,4294923008,2,20,24,18,18,0,0,120,10,0,95,1,0,0,1,70,90,0,0,4,5];
u[90] = ["Alien Halo",1,600,11,37,8,8388863,25,5,0,4,6,5,1,20,30,60,1,11,2860515583,1,16,24,12,12,30,0,180,10,0,103,0,2,40,6,12,120,2,0,30,40,100,0,13,2860515583,2,24,24,16,16,0,2,1,20,0,0,0,0];
u[91] = ["Rapid Halo",2,700,11,37,8,8635016,15,0,0,5,8,0,0,15,25,60];
u[92] = ["Heretical Halo",2,800,11,37,8,45913,25,108,0,5,8,1,1,20,30,60,0,25,4283725403,1,24,24,12,12,0,181,180,30,1,95,0,1,0,4,10,100,2,0,1,1,25,0,6,4279930420,2,16,16,12,12,0,0,60,20,0,100,0,0];
u[93] = ["Wrathful Halo",2,900,11,37,8,6730751,25,208,0,5,8,12,1,20,30,60,1,10,2858857471,2,16,32,12,30,60,0,60,10,10,100,0,0,0,3,25,150,0,0,1,25];
u[94] = ["Fallen Halo",2,1000,11,37,8,7667712,25,5,0,5,8,3,5,20,30,60,1,29,4288348160,1,24,32,12,12,30,0,60,120,2,100,0,0,0,1,0,150,8,1,7,9,9,1,22,2868862976,1,16,24,16,16,30,0,20,10,0,105,0,0];
u[95] = ["Hungry Soul Halo",2,1000,11,37,8,16733525,25,9,0,5,8,6,3,20,30,60,1,33,2868860245,1,24,24,16,16,30,20,240,10,0,98,1,0,80,7,20,150,0,0,18,22];
u[121] = ["[HEAVEN]",0,0,11,37.5,8,16754899,23,109,0,4,9,5,5,14,33,67,0,39,4294967040,1,16,16,8,8,37,5,274,34,0,90,1,0,64,8,31,107,0,0,4,13];

//Summoner
u[11] = ["Little Biter",0,100,12,41,10,13287351,0,0,0,1,3,0,0,30,60,40];
u[22] = ["Vicious Snake",1,200,12,42,10,4025182,1,0,0,4,6,0,0,40,60,60];
u[96] = ["Bomb Snake",1,300,12,42,10,5460819,1,6,1,3,5,1,0,40,60,60,0,2,2868862976,1,24,24,16,16,0,0,10,30,0,100,0,0,0,1,0,20,0,0,6,10];
u[97] = ["Shock Beetle",1,400,12,41,10,16446213,8,1,0,1,10,1,1,30,60,40,0,14,2868903680,1,16,16,12,12,0,10,20,10,0,100,0,0,0,3,0,0,7,0,1,3,3,1,20,2868903680,1,16,16,8,8,0,10,20,10,0,99,0,0];
u[98] = ["Tranquilizer Snake",1,500,12,42,10,5760713,1,6,0,3,5,1,0,40,60,60,0,27,2863726591,1,16,16,12,12,0,5,10,10,0,100,0,0,0,2,35,24,0,0,9,12];
u[99] = ["Stinkbug",1,600,12,41,10,7111740,8,4,0,1,1,1,60,30,60,40,0,12,4285616183,1,16,16,8,8,0,30,120,10,5,99,0,0,0,4,12,0,4,0,1,1,5,0,6,2859552823,1,16,16,12,12,5,0,60,10,-3,100,0,1];
u[100] = ["Infested Snake",2,700,12,42,10,16758711,1,109,0,4,6,8,3,40,60,60,1,36,4284161566,1,8,8,6,6,10,5,180,10,5,99,0,2,10,30,100,36,0,0,4,6];
u[101] = ["Bombardier Beetle",2,800,12,41,10,16635648,8,4,0,1,1,1,60,30,60,40,0,12,4294934528,1,16,16,8,8,0,0,120,10,5,99,0,0,0,1,30,0,4,0,3,4,4,0,24,2868854784,1,16,16,12,12,30,0,30,10,5,95,0,1];
u[102] = ["Leech",2,900,12,42,10,11010048,1,6,0,4,6,2,1,40,60,60,0,27,2863136768,1,24,24,12,12,10,5,10,10,0,100,0,0,0,7,45,36,0,0,24,36];
u[103] = ["Moonbug",2,1000,12,41,10,65465,8,3,0,12,16,3,5,60,80,40,1,11,2858614982,1,16,24,12,12,10,0,60,10,-1,105,0,2,0,6,10,0,2,0,0,0,100,0,13,2858614982,2,24,24,16,16,0,2,1,10,0,100,0,0];
u[104] = ["Basilisk",2,1100,12,42,10,32832,1,3003,0,4,6,5,1,40,60,60,1,2,4294967272,2,8,40,12,12,0,9,10,60,0,100,0,0,0,5,30,40,0,0,12,24];
u[122] = ["Totally not a virus.Trust me...im a dolphin",0,0,12,45,10,6730751,4,4,0,5,8,5,60,34,67,67,0,34,4289848307,1,16,16,8,12,45,5,90,23,8,100,0,1,0,8,26,41,0,0,4,17];

//Reaper
u[12] = ["Old Scythe",0,100,13,51,11,11184810,0,0,0,3,4,0,0,40,50,40];
u[23] = ["Sharp Scythe",1,200,13,51,11,13491424,0,0,0,6,8,0,0,50,60,60];
u[105] = ["Icy Scythe",1,300,13,51,11,9830399,3,7,0,4,6,1,1,50,60,60,1,4,2861957119,2,32,48,32,32,0,0,5,5,0,100,0,0,0,2,15,40,0,0,4,6,24];
u[106] = ["Shock Scythe",1,400,13,51,11,16776960,3,7,0,4,6,1,50,50,60,60,1,10,2868903680,2,24,32,16,16,0,30,40,10,0,80,0,0,0,3,0,60,0,0,1,30,30];
u[107] = ["Heat Scythe",1,500,13,51,11,16740917,2,109,0,4,6,5,5,50,60,60,1,6,2868838400,1,32,12,16,16,0,0,30,10,0,80,1,0,0,1,40,60,0,0,5,6,7];
u[108] = ["Rot Scythe",1,600,13,51,11,5998422,3,7,0,4,6,1,1,50,60,60,1,16,2852159488,2,24,32,16,16,0,0,10,10,0,100,0,0,0,4,24,60,0,0,1,1,30];
u[109] = ["Swift Scythe",2,700,13,51,11,10413236,0,0,0,5,6,0,0,30,40,50];
u[110] = ["Gravekeeper Scythe",2,800,13,51,11,11126192,16,5,0,5,7,1,1,50,60,60,0,37,4001535901,1,32,32,16,12,0,10,180,30,60,90,0,1,0,0,0,90,0,0,26,36,6];
u[111] = ["Freezing Scythe",2,900,13,51,11,13565951,2,7,0,5,7,1,1,50,60,60,1,19,2865692671,2,12,24,16,16,0,0,10,10,0,100,0,0,0,5,12,90,0,0,3,4,90];
u[112] = ["Infernal Scythe",2,1000,13,51,11,16724736,2,7,0,5,7,1,30,50,60,60,1,22,2868851456,2,24,32,20,20,0,0,90,10,0,90,1,0,0,1,50,120,0,0,5,7,50];
u[113] = ["Hungry Soul Scythe",2,1100,13,51,11,12124160,5,109,0,5,7,3,3,50,60,60,1,33,2864250880,1,16,16,12,12,60,10,240,10,0,98,1,0,80,7,35,120,0,0,20,24,3];
u[123] = ["      RAYTRACESOFDEATH",0,0,13,51,11,52736,0,0,0,6,8,0,0,33,66,58,0,0,4294967295,1,16,16,16,16,0,0,0,0,0,100,0,0,0,8,33];

u[124] = ["White Stone", 1, 400, 14, 55, 9, 4294967295, ld, 50, 0, "LP +50", ""];
u[125] = ["White Stone", 2, 800, 14, 55, 9, 4294967295, ld, 100, 0, "LP +100", ""];
u[126] = ["Red Stone", 1, 400, 14, 55, 9, 4294914867, md, 5, 0, "str +5", ""];
u[127] = ["Red Stone", 2, 800, 14, 55, 9, 4294914867, md, 10, 0, "str +10", ""];
u[128] = ["Green Stone", 1, 400, 14, 55, 9, 4281597747, nd, 5, 0, "dex +5", ""];
u[129] = ["Green Stone", 2, 800, 14, 55, 9, 4281597747, nd, 10, 0, "dex +10", ""];
u[130] = ["Blue Stone", 1, 400, 14, 55, 9, 4281545727, od, 5, 0, "mag +5", ""];
u[131] = ["Blue Stone", 2, 800, 14, 55, 9, 4281545727, od, 10, 0, "mag +10", ""];
u[132] = ["Black Stone", 1, 400, 14, 55, 9, 4284900966, pd, 2, 0, "str dex mag +2", ""];
u[133] = ["Black Stone", 2, 800, 14, 55, 9, 4284900966, pd, 4, 0, "str dex mag +4", ""];

u[134] = ["Red Crystal", 1, 1200, 15, 56, 9, 4294936712, qd, 1, 3, "AT +(1-3)", ""];
u[135] = ["Red Crystal", 2, 2400, 15, 56, 9, 4294936712, qd, 2, 6, "AT +(2-6)", ""];
u[136] = ["Yellow Crystal", 1, 1200, 15, 56, 9, 4294967176, rd, 20, 0, "AT +20%", ""];
u[137] = ["Yellow Crystal", 2, 2400, 15, 56, 9, 4294967176, rd, 30, 0, "AT +30%", ""];
u[138] = ["Silver Crystal", 1, 1200, 15, 56, 9, 4291611852, sd, 1, 0, "Defense +1", ""];
u[139] = ["Silver Crystal", 2, 2400, 15, 56, 9, 4291611852, sd, 3, 0, "Defense +3", ""];
u[140] = ["Purple Crystal", 1, 1200, 15, 56, 9, 4291598847, td, 10, 0, "Magic Defense 10%", ""];
u[141] = ["Purple Crystal", 2, 2400, 15, 56, 9, 4291598847, td, 20, 0, "Magic Defense 20%", ""];
u[142] = ["Black Crystal", 1, 1200, 15, 56, 9, 4284900966, ud, 10, 0, "Block rate 10%", ""];
u[143] = ["Black Crystal", 2, 2400, 15, 56, 9, 4284900966, ud, 20, 0, "Block rate 20%", ""];

u[144] = ["Ruby", 1, 2E3, 16, 57, 9, 4294901760, yd, 1, 2, "Add 1-2 fire", "damage"];
u[145] = ["Ruby", 2, 4E3, 16, 57, 9, 4294901760, yd, 3, 4, "Add 3-4 fire", "damage"];
u[146] = ["Garnet", 1, 2E3, 16, 57, 9, 4294914867, zd, 24, 0, "+0.4s Fire Length", ""];
u[147] = ["Garnet", 2, 4E3, 16, 57, 9, 4294914867, zd, 36, 0, "+0.6s Fire Length", ""];
u[148] = ["Sapphire", 1, 2E3, 16, 57, 9, 4284914175, Ad, 3, 5, "Add 3-5 ice", "damage"];
u[149] = ["Sapphire", 2, 4E3, 16, 57, 9, 4284914175, Ad, 6, 10, "Add 6-10 ice", "damage"];
u[150] = ["Aquamarine", 1, 2E3, 16, 57, 9, 4284927231, Bd, 5, 0, "+5% Cold effect", ""];
u[151] = ["Aquamarine", 2, 4E3, 16, 57, 9, 4284927231, Bd, 10, 0, "+10% Cold effect", ""];
u[152] = ["Topaz", 1, 2E3, 16, 57, 9, 4294954035, Cd, 0, 4, "Add 0-4 thunder", "damage"];
u[153] = ["Topaz", 2, 4E3, 16, 57, 9, 4294954035, Cd, 0, 9, "Add 0-9 thunder", "damage"];
u[154] = ["Emerald", 1, 2E3, 16, 57, 9, 4281597747, Dd, 0, 1, "Add 0-1 poison", "damage"];
u[155] = ["Emerald", 2, 4E3, 16, 57, 9, 4281597747, Dd, 1, 1, "Add 1-1 poison", "damage"];
u[156] = ["Peridot", 1, 2E3, 16, 57, 9, 4288282419, Ed, 30, 0, "+0.5s Poison Length", ""];
u[157] = ["Peridot", 2, 4E3, 16, 57, 9, 4288282419, Ed, 60, 0, "+1s Poison Length", ""];
u[158] = ["Diamond", 1, 4E3, 16, 57, 9, 4294967295, Fd, 6, 0, "+0.1s Freeze Length", ""];
u[159] = ["Diamond", 2, 4E3, 16, 57, 9, 4294967295, Fd, 12, 0, "+0.2s Freeze Length", ""];
u[160] = ["Hematite", 1, 4E3, 16, 57, 9, 0x77667F, compoHematite, 50, 0, "+50% Gravity Force", ""];
u[161] = ["Hematite", 2, 4E3, 16, 57, 9, 0x77667F, compoHematite, 60, 0, "+60% Gravity Force", ""];
/*u[] = ["Hematite", 3, 6E3, 16, 57, 9, 0x77667F, compoHematite, 70, 0, "+70% Gravity Force", ""];
u[] = ["Hematite", 4, 8E3, 16, 57, 9, 0x77667F, compoHematite, 90, 0, "+90% Gravity Force", ""];
u[] = ["Hematite", 5, 1E4, 16, 57, 9, 0x77667F, compoHematite, 110, 0, "+110% Gravity Force", ""];
u[] = ["Hematite", 6, 12E3, 16, 57, 9, 0x77667F, compoHematite, 130, 0, "+130% Gravity Force", ""];
u[] = ["Hematite", 7, 14E3, 16, 57, 9, 0x77667F, compoHematite, 150, 0, "+150% Gravity Force", ""];*/
u[162] = ["Carnelian", 1, 4E3, 16, 57, 9, 0x970000, compoCarnelian, 10, 0, "+10% Drain Chance", ""];
u[163] = ["Carnelian", 2, 4E3, 16, 57, 9, 0x970000, compoCarnelian, 20, 0, "+20% Drain Chance", ""];
/*u[] = ["Carnelian", 3, 6E3, 16, 57, 9, 0x970000, compoCarnelian, 30, 0, "+30% Drain Chance", ""];
u[] = ["Carnelian", 4, 8E3, 16, 57, 9, 0x970000, compoCarnelian, 40, 0, "+40% Drain Chance", ""];
u[] = ["Carnelian", 5, 1E4, 16, 57, 9, 0x970000, compoCarnelian, 60, 0, "+60% Drain Chance", ""];
u[] = ["Carnelian", 6, 12E3, 16, 57, 9, 0x970000, compoCarnelian, 80, 0, "+80% Drain Chance", ""];
u[] = ["Carnelian", 7, 14E3, 16, 57, 9, 0x970000, compoCarnelian, 100, 0, "+100% Drain Chance", ""];*/

u[164] = ["Quick's Card", 1, 4E3, 17, 63, 9, 4287124736, Gd, 10, 0, "-10% Limit AGI", ""];
u[165] = ["Quick's Card", 2, 8E3, 17, 63, 9, 4287124736, Gd, 20, 0, "-20% Limit AGI", ""];
u[166] = ["Catapult's Card", 1, 4E3, 17, 65, 9, 4284887808, Id, 20, 0, "+20 Range", ""];
u[167] = ["Catapult's Card", 2, 8E3, 17, 65, 9, 4284887808, Id, 40, 0, "+40 Range", ""];
u[168] = ["Spectre's Card", 1, 4E3, 17, 66, 9, 12513777, Jd, 10, 0, "+10 guide length,", "terrain pierce"];
u[169] = ["Spectre's Card", 2, 8E3, 17, 66, 9, 12513777, Jd, 20, 0, "+20 guide length,", "terrain pierce"];
u[170] = ["Frog's Card", 1, 4E3, 17, 67, 9, 4554540, $d, 10, 0, "+10 guide length,", "terrain bounce"];
u[171] = ["Frog's Card", 2, 8E3, 17, 67, 9, 4554540, $d, 20, 0, "+20 guide length,", "terrain bounce"];
u[172] = ["Bullet's Card", 1, 4E3, 17, 68, 9, 4281545523, Ld, 1, 0, "+1 bullet", ""];
u[173] = ["Bullet's Card", 2, 8E3, 17, 68, 9, 4281545523, Ld, 2, 0, "+2 bullet", ""];
u[174] = ["Explosion's Card", 1, 4E3, 17, 69, 9, 4294940928, Md, 25, 0, "25% chance of", "Splash damage"];
u[175] = ["Explosion's Card", 2, 8E3, 17, 69, 9, 4294940928, Md, 50, 0, "50% chance of", "Splash damage"];
u[176] = ["Critical's Card", 1, 4E3, 17, 70, 9, 4294967142, Od, 25, 100, "25% chance of", "AT +100%"];
u[177] = ["Critical's Card", 2, 8E3, 17, 70, 9, 4294967142, Od, 25, 150, "25% chance of", "AT +150%"];
u[178] = ["Berserk Card", 1, 4E3, 17, 71, 9, 4291559424, Nd, 20, 0, "20% chance of", "instant attack when hit"];
u[179] = ["Berserk Card", 2, 8E3, 17, 71, 9, 4291559424, Nd, 30, 0, "30% chance of", "instant attack when hit"];
u[180] = ["Vampire's Card", 1, 4E3, 17, 62, 9, 4288217088, vd, 3, 0, "3% LP recovery", "per damage"];
u[181] = ["ONIGIRI's Card", 1, 8E3, 17, 62, 9, 4294967295, wd, 5, 0, "5% chance of", "ONIGIRI drop per hit"];

u[182] = ["Bronze Medal", 1, 2E3, 18, 58, 9, 4292708369, Qd, 10, 0, "+10% Drop rate", ""];
u[183] = ["Bronze Medal", 2, 4E3, 18, 58, 9, 4292708369, Qd, 20, 0, "+20% Drop rate", ""];
u[184] = ["Silver Medal", 1, 2E3, 18, 58, 9, 4291611852, Rd, 10, 0, "+10% ONIGIRI Drop", ""];
u[185] = ["Silver Medal", 2, 4E3, 18, 58, 9, 4291611852, Rd, 20, 0, "+20% ONIGIRI Drop", ""];
u[186] = ["Gold Medal", 1, 2E3, 18, 58, 9, 4294958336, Sd, 10, 0, "+10% Gold UP", ""];
u[187] = ["Gold Medal", 2, 4E3, 18, 58, 9, 4294958336, Sd, 20, 0, "+20% Gold UP", ""];
u[188] = ["Iron Medal", 1, 2E3, 18, 58, 9, 4284900966, Td, 10, 0, "+10% EXP UP", ""];
u[189] = ["Iron Medal", 2, 4E3, 18, 58, 9, 4284900966, Td, 20, 0, "+20% EXP UP", ""];

u[190] = ["Ice Charm", 1, 2E3, 19, 59, 9, 4284927231, Ud, 50, 0, "50% Ice immunity", ""];
u[191] = ["Ice Charm", 2, 4E3, 19, 59, 9, 4284927231, Ud, 80, 0, "80% Ice immunity", ""];
u[192] = ["Poison Charm", 1, 2E3, 19, 59, 9, 4288282419, Vd, 50, 0, "50% Poison immunity", ""];
u[193] = ["Poison Charm", 2, 4E3, 19, 59, 9, 4288282419, Vd, 80, 0, "80% Poison immunity", ""];
u[194] = ["Freeze Charm", 1, 2E3, 19, 59, 9, 4294967295, Wd, 50, 0, "50% Freeze immunity", ""];
u[195] = ["Freeze Charm", 2, 4E3, 19, 59, 9, 4294967295, Wd, 80, 0, "80% Freeze immunity", ""];

u[196] = ["Earth Transmutation", 0, 2E3, 22, 79, 9, 10261637, compoPhysTr, 0, 50, "Convert: Physical", "Damage +50%"];
u[197] = ["Venus Transmutation", 0, 2E3, 22, 79, 9, 16737792, compoFireTr, 0, 50, "Convert: Fire", "Burn 5%"];
u[198] = ["Neptune Transmutation", 0, 2E3, 22, 79, 9, 9160696, compoIceTr, 0, 20, "Convert: Ice", "Slow 20%"];
u[199] = ["Saturn Transmutation", 0, 2E3, 22, 79, 9, 16777098, compoThunTr, 0, 50, "Convert: Thunder", "Arc 50%"];
u[200] = ["Mercury Transmutation", 0, 2E3, 22, 79, 9, 8705832, compoPoisTr, 0, 12, "Convert: Poison", "Time 0.2s"];
u[201] = ["Uranus Transmutation", 0, 2E3, 22, 79, 9, 14678783, compoFrzTr, 0, 6, "Convert: Freeze", "Time 0.1s"];
u[202] = ["Jupiter Transmutation", 0, 2E3, 22, 79, 9, 9852651, compoGravTr, 0, 10, "Convert: Gravity", "Force 10"];
u[203] = ["Mars Transmutation", 0, 2E3, 22, 79, 9, 12255232, compoDrainTr, 0, 30, "Convert: Drain", "Chance 30%"];
u[204] = ["Yuggoth Transmutation", 0, 2E3, 22, 79, 9, 3487029, compoGlitchTr, 0, 20, "Convert: Convert: Convert:", "Effect 20"];
u[205] = ["Rainbow Jewel", 1, 4E3, 21, 61, 9, 0xFFFFFF, compoRnbw, 8, 0, "+8 Effect For", "Dual-type weapons"];
u[206] = ["Rainbow Jewel", 2, 4E3, 21, 61, 9, 0xFFFFFF, compoRnbw, 16, 0, "+16 Effect For", "Dual-type weapons"];
u[207] = ["Gravity Charm", 1, 2E3, 19, 59, 9, 8388863, compoGravWard, 50, 0, "50% Gravity immunity", ""];
u[208] = ["Gravity Charm", 2, 4E3, 19, 59, 9, 8388863, compoGravWard, 80, 0, "80% Gravity immunity", ""];
u[209] = ["Blademaster's Card", 1, 4E3, 17, 78, 9, 0xAAA5FFE8, compoBlademaster, 8, 1, "Greatslash: Gust,", "+8 Sword Length"];

var fe = 0,
	ge = 0,
	he = "";
window.GameSave = ie;

function ie(a) { //Get save
	return 0 == a.length ? "" : he
}
var je = 0,
	ke = 0,
	le = "";
window.GameLoad = me;

function me(a) { //Set save
	if (0 != a.length) return le = a, 0;
	if (0 == a.length) {
		if (0 == le.length) return -1;
		l = sb = nb = h = mb = f = 0;
		tb = 3;
		ub = !1;
		for (a = 0; 4 > a; a++) fc[a] = 0;
		Jb = 0;
		v.j();
		ne.j();
		oe.j();
		pe.j();
		qe.j();
		je = re(le, 0);
		0 < je ? ke = 50 : he = se(0);
		le = "";
		te()
	}
	return -1
}
window.AutoSave = ue;

function ue(a) { //Save game
	if (0 == a.length || 0 == fe) return "";
	fe = 0;
	ge = 50;
	return ie("0")
}

function w(a, b) { //Get item value
	return u[a].length <= b ? 0 : b == Sc || b == Zc || b == fd ? u[a][b] >>> 0 : u[a][b]
}
var ve = !1,
	we = !1;

function x(a, b) { //Check compo effect
	we = ve = !1;
	w(Dc[a], hd) == b && (ve = !0);
	w(Ec[a], hd) == b && (we = !0);
	return ve || we ? !0 : !1
}

function y(a, b) { //Get compo effect
	var c = 0;
	ve && (c += w(Dc[a], b));
	we && (c += w(Ec[a], b));
	return c
}
var ye = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.*".split("");

function se(a) { //Generate save code
	var b, c, d = "",
		e = new Int32Array(512);
	b = 0;
	e[b++] = 1;
	e[b++] = 0;
	e[b++] = 0;
	e[b++] = z(A(64));
	e[b++] = z(A(64));
	for (c = 0; 8 > c; c++) e[b++] = Ka[c];
	0 == a && (e[b++] = h >> 6 & 63, e[b++] = h >> 0 & 63);
	e[b++] = Mb[0] >> 6 & 63;
	e[b++] = Mb[0] >> 0 & 63;
	1 == a && (e[b++] = $b[0]);
	for (c = 0; 4 > c; c++) e[b++] = ac[c] >> 6 & 63, e[b++] = ac[c] >> 0 & 63;
	0 == a && (e[b++] = cc >> 18 & 63, e[b++] = cc >> 12 & 63, e[b++] = cc >> 6 & 63, e[b++] = cc >> 0 & 63, e[b++] = dc >> 18 & 63, e[b++] = dc >> 12 & 63, e[b++] = dc >> 6 & 63, e[b++] = dc >> 0 & 63);
	for (c = 0; 4 > c; c++) e[b++] = ec[c] >> 0 & 63;
	if (0 == a)
		for (c = 0; 4 > c; c++) e[b++] = p[c] >>
			12 & 63, e[b++] = p[c] >> 6 & 63, e[b++] = p[c] >> 0 & 63;
	for (c = 0; 4 > c; c++) e[b++] = gc[c] >> 6 & 63, e[b++] = gc[c] >> 0 & 63, e[b++] = hc[c] >> 6 & 63, e[b++] = hc[c] >> 0 & 63, e[b++] = ic[c] >> 6 & 63, e[b++] = ic[c] >> 0 & 63, e[b++] = jc[c] >> 6 & 63, e[b++] = jc[c] >> 0 & 63;
	for (c = s; c < s + 4; c++) e[b++] = q[c] >> 6 & 63, e[b++] = q[c] >> 0 & 63, e[b++] = Dc[c] >> 6 & 63, e[b++] = Dc[c] >> 0 & 63, e[b++] = Ec[c] >> 6 & 63, e[b++] = Ec[c] >> 0 & 63;
	if (0 == a) {
		for (c = Fc; c < Hc; c++) e[b++] = q[c] >> 6 & 63, e[b++] = q[c] >> 0 & 63, e[b++] = Dc[c] >> 6 & 63, e[b++] = Dc[c] >> 0 & 63, e[b++] = Ec[c] >> 6 & 63, e[b++] = Ec[c] >> 0 & 63;
		for (c = 0; 4 > c; c++) e[b++] =
			uc[c];
		e[b++] = vc;
		e[b++] = wc;
		e[b++] = xc;
		e[b++] = yc;
		e[b++] = zc;
		for (c = 0; 3 > c; c++) e[b++] = 0;
		for (c = 0; c < ze; c++) {
			d = Ae[c];
			for (a = 0; c < ze - 1 && d == Ae[c + 1]; c++)
				if (a++, 31 == a) {
					c++;
					break
				}
			e[b++] = d;
			0 < a && (e[b++] = 16 + a)
		}
	}
	for (c = a = 0; c < b; c++) a += e[c] * (z(c / 7) + 1);
	e[1] = a >> 6 & 63;
	e[2] = a & 63;
	for (c = a = 0; c < b; c++) a += e[c] * ((c & 15) + 1);
	e[b++] = a >> 8 & 47;
	e[b++] = a >> 4 & 31;
	e[b++] = a >> 0 & 15;
	d = "" + ye[e[0]];
	d += ye[e[1]];
	d += ye[e[2]];
	a = e[2];
	for (c = 3; c < b; c++) d += ye[e[c] + a & 63], a += e[c] + c + e[1];
	return d
}

function re(a, b) { //Load save
	var c = 4 * b,
		d, e, g = new Int32Array(512),
		k = a.length,
		r = 0;
	if (0 == k) return 1;
	90 > k && (r = 1);
	for (d = 0; d < k; d++) {
		var m = a.charAt(d);
		for (e = 0; e < ye.length; e++)
			if (ye[e] == m) {
				g[d] = e;
				break
			}
	}
	if (0 >= g[0]) return 2;
	e = g[2];
	for (d = 3; d < k; d++) g[d] = g[d] - e & 63, e += g[d] + d + g[1];
	for (d = e = 0; d < k - 3; d++) e += g[d] * ((d & 15) + 1);
	if (g[d + 0] != (e >> 8 & 47) || g[d + 1] != (e >> 4 & 31) || g[d + 2] != (e >> 0 & 15)) return 3;
	if (0 == b)
		for (d = 0; 8 > d; d++)
			if (g[d + 5] != Ka[d]) return 4;
	d = 0;
	d++;
	d++;
	d++;
	d++;
	d++;
	d += 8;
	0 == r && (h = (g[d++] << 6) + g[d++]);
	Mb[b] = (g[d++] << 6) + g[d++];
	1 == r &&
		($b[b] = g[d++]);
	for (e = c; e < c + 4; e++) ac[e] = (g[d++] << 6) + g[d++];
	0 == r && (cc = (g[d++] << 18) + (g[d++] << 12) + (g[d++] << 6) + g[d++], dc = (g[d++] << 18) + (g[d++] << 12) + (g[d++] << 6) + g[d++]);
	for (e = c; e < c + 4; e++) ec[e] = g[d++];
	if (0 == r)
		for (e = c; e < c + 4; e++) p[e] = (g[d++] << 12) + (g[d++] << 6) + g[d++];
	for (e = c; e < c + 4; e++) gc[e] = (g[d++] << 6) + g[d++], hc[e] = (g[d++] << 6) + g[d++], ic[e] = (g[d++] << 6) + g[d++], jc[e] = (g[d++] << 6) + g[d++];
	for (e = s + c; e < s + 4 + c; e++) q[e] = (g[d++] << 6) + g[d++], Dc[e] = (g[d++] << 6) + g[d++], Ec[e] = (g[d++] << 6) + g[d++];
	if (1 == r) return 0;
	for (e = Fc; e < Hc; e++) q[e] =
		(g[d++] << 6) + g[d++], Dc[e] = (g[d++] << 6) + g[d++], Ec[e] = (g[d++] << 6) + g[d++];
	for (e = 0; 4 > e; e++) uc[e] = g[d++];
	vc = g[d++];
	wc = g[d++];
	xc = g[d++];
	yc = g[d++];
	zc = g[d++];
	for (e = 0; 3 > e; e++) d++;
	for (e = 0; e < ze; e++) Ae[e] = 0;
	for (e = 0; d < k - 3; d++)
		if (16 > g[d]) Ae[e++] = g[d];
		else
			for (c = 0; c < g[d] - 16; c++) Ae[e++] = g[d - 1];
	for (e = 0; e < ze; e++) 0 != (Ae[e] & Be) && (Ae[e] |= Ce, 0 < De[e][3] && (Ae[De[e][3]] |= Ce), 0 < De[e][4] && (Ae[De[e][4]] |= Ce));
	return 0
}
da.fff = Ee;

function Ee(a) { //Useless VS mode
	var b, c = "",
		d = new Int32Array(16);
	b = 0;
	d[b++] = z(A(64));
	d[b++] = z(A(64));
	d[b++] = z(A(64));
	d[b++] = z(A(64));
	d[b++] = $b[0];
	d[b++] = $b[1];
	d[b++] = a;
	d[b++] = va >> 18 & 63;
	d[b++] = va >> 12 & 63;
	d[b++] = va >> 6 & 63;
	d[b++] = va & 63;
	var e = 0;
	for (a = 0; a < b; a++) e += d[a] * ((a & 15) + 1);
	d[b++] = e >> 8 & 47;
	d[b++] = e >> 4 & 31;
	d[b++] = e >> 0 & 15;
	c = "" + ye[d[0]];
	c += ye[d[1]];
	e = d[1];
	for (a = 2; a < b; a++) c += ye[d[a] + e & 63], e += d[a] + a + d[0];
	return c
}
var Fe = 0,
	Ge = 0,
	He = [],
	Ie = 0,
	Je = 0,
	Ke = 0;
da.fff = Le;

function Le() { //Gather data
	var a, b, c;
	He = new Int32Array(u.length);
	for (a = 0; a < u.length; a++)
		for (b = He[a] = 0; b < u[a].length; b++) "number" == typeof u[a][b] && (He[a] += u[a][b] & 255);
	for (a = Ie = 0; a < Me.length; a++)
		for (b = 0; b < Me[a].length; b++)
			for (c = 0; c < Me[a][b].length; c++) Ie += Me[a][b][c];
	for (a = Je = 0; a < B.length; a++)
		for (b = 0; b < B[a].length; b++) Je += B[a][b] & 65535;
	for (c = Ke = 0; c < Lc.length; c++)
		for (a = 0; a < Lc[c].length; a++)
			for (b = 0; b < Lc[c][a].length; b++) Ke += Lc[c][a][b] * b & 65535
}

function Ne() {/* Annoying anticheat
	var a, b, c, d;
	if (0 > Mb[0] || 99 < Mb[0]) C = null;
	if (0 > Mb[1] || 99 < Mb[1]) C = null;
	if (0 > cc || 9999999 < cc) C = null;
	if (0 > dc || 9999999 < dc) C = null;
	for (a = 0; 8 > a; a++) {
		if (0 > ac[a] || 196 < ac[a]) C = null;
		if (0 > gc[a] || 196 < gc[a]) C = null;
		if (0 > hc[a] || 196 < hc[a]) C = null;
		if (0 > ic[a] || 196 < ic[a]) C = null;
		if (0 > jc[a] || 196 < jc[a]) C = null
	}
	for (a = 0; 8 > a; a++) 0 != q[s + a] && w(q[s + a], Rc) != ec[a] && (C = null);
	for (a = 0; 8 > a; a++) {
		b = w(q[s + a], Rc);
		c = w(q[s + a], $c);
		d = w(q[s + a], Vc);
		if (0 != Dc[s + a]) {
			9 != w(Dc[s + a], Rc) && (C = null);
			w(Dc[s + a], hd) == w(Ec[s + a], hd) && (C = null);
			var e =
				w(Dc[s + a], hd);
			!1 == Oe(e, b, c, d) && (C = null)
		}
		0 != Ec[s + a] && Ec[s + a] != Ic && (9 != w(Ec[s + a], Rc) && (C = null), e = w(Ec[s + a], hd), !1 == Oe(e, b, c, d) && (C = null))
	}
	if (0 == ga || 2 == ga) {
		for (a = c = 0; a < ze; a++)
			if (0 != (Ae[a] & Ce))
				for (d = Pe[a + 1] - Pe[a], b = 0; b < d; b++) c < B[Pe[a] + b][Qe] && (c = B[Pe[a] + b][Qe]), b += B[Pe[a] + b][Re];
		c + 10 + 2 < Mb[0] && (C = null)
	}
	if (0 == ga || 2 == ga) {
		b = 4753E3;
		a = 9999999;
		if (98 > Mb[0]) {
			b = 0;
			for (a = 1; a < Mb[0]; a++) b += 1E3 * a;
			a = b + 1E3 * a
		}
		if (cc < b || a < cc) C = null
	}
	for (a = d = 0; 8 > a; a++) d += ac[a];
	for (a = 0; 8 > a; a++) d += gc[a];
	for (a = 0; 8 > a; a++) d += hc[a];
	for (a = 0; 8 > a; a++) d +=
		ic[a];
	for (a = 0; 8 > a; a++) d += jc[a];
	d != 8 * (Mb[0] - 1) + 8 * (Mb[1] - 1) && (C = null);
	d = Ge;
	d += (cc | 1) * (d & 15 | 1);
	d += (dc | 1) * (d & 15 | 1);
	for (a = 0; 2 > a; a++) d += (Mb[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (ac[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (gc[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (hc[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (ic[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (jc[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (ec[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (p[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (fc[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (kc[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d +=
		(lc[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (mc[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (nc[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (oc[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (pc[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (qc[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (rc[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (tc[a] | 1) * (d & 15 | 1);
	for (a = 0; a < Hc; a++) d += (q[a] | 1) * (d & 15 | 1);
	for (a = 0; a < Hc; a++) d += (Dc[a] | 1) * (d & 15 | 1);
	for (a = 0; a < Hc; a++) d += (Ec[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (Ac[a] | 1) * (d & 15 | 1);
	for (a = 0; 8 > a; a++) d += (Bc[a] | 1) * (d & 15 | 1);
	for (a = 0; a < ze; a++) d += (Ae[a] |
		1) * (d & 15 | 1);
	d += (ga | 1) * (d & 15 | 1);
	d += (Nb[0] | 1) * (d & 15 | 1);
	d += (Nb[1] | 1) * (d & 15 | 1);
	d += ($b[0] | 1) * (d & 15 | 1);
	d += ($b[1] | 1) * (d & 15 | 1);
	d != (Fe ^ 16777215) && (C = null);
	if (1 > A(100))
		for (a = 0; a < u.length; a++) {
			for (b = d = 0; b < u[a].length; b++) "number" == typeof u[a][b] && (d += u[a][b] & 255);
			d != He[a] && (C = null)
		}
	if (1 > A(100)) {
		for (a = d = 0; a < Me.length; a++)
			for (b = 0; b < Me[a].length; b++)
				for (c = 0; c < Me[a][b].length; c++) d += Me[a][b][c];
		d != Ie && (C = null)
	}
	if (1 > A(100)) {
		for (a = d = 0; a < B.length; a++)
			for (b = 0; b < B[a].length; b++) d += B[a][b] & 65535;
		d != Je && (C = null)
	}
	if (1 >
		A(100)) {
		for (c = d = 0; c < Lc.length; c++)
			for (a = 0; a < Lc[c].length; a++)
				for (b = 0; b < Lc[c][a].length; b++) d += Lc[c][a][b] * b & 65535;
		d != Ke && (C = null)
	}*/
}

function te() {/* Annoying anticheat
	var a, b = z(A(1024));
	Ge = b;
	b += (cc | 1) * (b & 15 | 1);
	b += (dc | 1) * (b & 15 | 1);
	for (a = 0; 2 > a; a++) b += (Mb[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (ac[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (gc[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (hc[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (ic[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (jc[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (ec[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (p[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (fc[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (kc[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (lc[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 >
		a; a++) b += (mc[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (nc[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (oc[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (pc[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (qc[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (rc[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (tc[a] | 1) * (b & 15 | 1);
	for (a = 0; a < Hc; a++) b += (q[a] | 1) * (b & 15 | 1);
	for (a = 0; a < Hc; a++) b += (Dc[a] | 1) * (b & 15 | 1);
	for (a = 0; a < Hc; a++) b += (Ec[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (Ac[a] | 1) * (b & 15 | 1);
	for (a = 0; 8 > a; a++) b += (Bc[a] | 1) * (b & 15 | 1);
	for (a = 0; a < ze; a++) b += (Ae[a] | 1) * (b & 15 | 1);
	b += (ga | 1) * (b & 15 |
		1);
	b += (Nb[0] | 1) * (b & 15 | 1);
	b += (Nb[1] | 1) * (b & 15 | 1);
	b += ($b[0] | 1) * (b & 15 | 1);
	b += ($b[1] | 1) * (b & 15 | 1);
	Fe = b ^ 16777215*/
}
var Se = 0;

function Te(a, b, c, d, e, g, k, r, m, n, F, H, M) { //Game startup
	if (0 == Se) {
		ha = null != a ? a : "";
		La = "0" == b ? !0 : !1;
		Ha = null != c ? c : "";
		ga = null != d ? ~~d : 0;
		la = null != e ? e : "";
		oa = null != g ? g : "";
		Ia = null != k ? k : "";
		ua = null != r ? ~~r : 0;
		va = null != m ? ~~m : 0;
		ma = null != n ? n : "";
		na = null != F ? F : "";
		qa = null != H ? H : "";
		ra = null != M ? M : "";
		for (a = 0; 8 > a && a < ha.length; a++)
			for (b = ha.charAt(a), c = 0; c < ye.length; c++)
				if (ye[c] == b) {
					Ka[a] = c;
					break
				}
		Ue(Ve);
		We.width = ea;
		We.height = fa;
		for (a = 0; 513 > a; a++) Xe[a] = new Float32Array(2);
		for (a = 0; 512 > a; a++) b = 360 * a / 512 * Ye / 180, Xe[a][0] = Math.cos(b), Xe[a][1] = Math.sin(b);
		Xe[a][0] = Xe[0][0];
		Xe[a][1] = Xe[0][1];
		for (a = 0; 256 > a; a++) Ze[a] = !1, $e[a] = !1, af[a] = !1, bf[a] = 0, cf[a] = 0;
		for (a = 0; 10 > a; a++) bf[48 + a] = 48 + a;
		for (a = 0; 9 > a; a++) cf[49 + a] = 33 + a;
		for (a = 0; 4 > a; a++) bf[37 + a] = 37 + a;
		for (a = 0; 4 > a; a++) cf[37 + a] = 37 + a;
		bf[13] = cf[13] = 13;
		bf[16] = cf[16] = 16;
		bf[17] = cf[17] = 17;
		bf[18] = cf[18] = 18;
		bf[32] = cf[32] = 32;
		bf[186] = 58;
		cf[186] = 42;
		bf[187] = 59;
		cf[187] = 43;
		bf[188] = 44;
		cf[188] = 60;
		bf[189] = 45;
		cf[189] = 61;
		bf[190] = 46;
		cf[190] = 62;
		bf[191] = 47;
		cf[191] = 63;
		bf[192] = 64;
		cf[192] = 96;
		bf[219] = 91;
		cf[219] = 123;
		bf[220] = 92;
		cf[220] = 124;
		bf[221] = 93;
		cf[221] = 125;
		bf[222] = 94;
		cf[222] = 126;
		bf[226] = 92;
		cf[226] = 95;
		bf[58] = 58;
		cf[58] = 42;
		bf[59] = 59;
		cf[59] = 43;
		bf[173] = 45;
		cf[173] = 61;
		bf[64] = 64;
		cf[64] = 96;
		bf[160] = 94;
		cf[160] = 126;
		for (a = 0; 1024 > a; a++) df[a] = a / 1024;
		for (a = 0; 1024 > a; a++) b = z(1024 * Math.random()), c = df[a], df[a] = df[b], df[b] = c;
		ef = z(1024 * Math.random()) & 1023;
		ff = z(512 * Math.random()) | 1;
		for (a = 0; a < ea * fa; a++) C[a] = 0;
		for (a = 0; a < ea * fa * 4; a++) gf[a] = 255;
		D.j("font.gif", 8, 12);
		hf.j("font_s.gif", 5, 7);
		for (a = 0; 13 > a; a++) Pa[a] = new wa, Pa[a].j("gt" + a + ".gif");
		Qa.j("pl.gif");
		Ra.j("icon.gif");
		Ua.j("item.gif");
		Va.j("en.gif");
		Wa.j("next.gif");
		Za.j("mag.gif");
		$a.j("title.gif");
		cb.j("ef.gif");
		db.j("town.gif");
		fb.j("water.gif");
		gb.j("water2.gif");
		hb.j("tree.gif");
		ib.j("map.gif");
		jb.j("mt.gif");
		kb.j("map2.gif");
		lb.j("mt2.gif");
		cloudImg.j("cloud.gif");
		jf() ? Se-- : Se++
	}
	if (1 == Se) {
		mf(D.N);
		mf(hf.N);
		for (a = 0; 13 > a; a++) mf(Pa[a]);
		mf(Qa);
		mf(Ra);
		mf(Ua);
		mf(Va);
		mf(Wa);
		mf(Za);
		mf($a);
		mf(cb);
		mf(db);
		mf(fb);
		mf(gb);
		mf(hb);
		mf(ib);
		mf(jb);
		mf(kb);
		mf(lb);
		mf(cloudImg);
		0 != nf ? of (Te, pf()) : Se++
	}
	2 == Se && (v.j(), ne.j(), oe.j(), pe.j(), qe.j(), 1 == ga &&
		re(Ia, 1), re(Ha, 0), he = se(0), Le(), te(), qf(Ma, ea, fa), rf())
}
da.fff = sf;

function sf() { //Play sequence
	if (0 < tf) tf++;
	else {
		me("");
		ue("");
		for (var a = ea * fa - 1; 0 <= a; a--) C[a] = 0;
		9 >= f ? uf() : 49 >= f ? vf() : 59 >= f ? wf() : 60 <= f && xf();
		0 < ge && (ge--, yf(D, 480, 247, "save OK", 16711680, 6684672));
		0 < ke && (ke--, 2 == je ? D.b(10, 10, "VERSION ERROR", 16711680, 6684672) : 3 == je ? D.b(10, 10, "DATA ERROR", 16711680, 6684672) : 4 == je && D.b(10, 10, "USER ERROR", 16711680, 6684672));
		1 == ca && (D.b(0, 0, zf + Af, 16777215, 0), 1 == ca && D.b(48, 0, Bf + "sl", 16777215, 0));
		Ne()
	}
}
da.fff = uf;

function uf() { //Menu and map
	var a;
	if (0 == f)
		if (v.j(), G.j(0), f++, 1 == ga) f = 60;
		else {
			if (2 == ga || 3 == ga) f = 70
		}
	else if (1 == f) nb = 0, I.j(0) && (v.set(0, 20, I.o[20]), v.set(1, 28, I.o[28]), v.set(2, 36, I.o[36]), v.set(3, 44, I.o[44]), Cf(), G.j(1), f++);
	if (f == 1){ //SUMMONER despawn all summons at title screen (Fuck this vanilla syntax it sucks)
		for (i=0; i<4; i++){
			for (j=0; j<summons.maxSummons; j++){
				summons.despawn(i, j);
			}
		}
	}
	else if (2 == f) {
		v.move();
		Cf();
		I.b();
		v.b();
		J($a, 256, 100, 365, 121, 0, La ? 0 : 121, 365, 121, 16777215);
		var b = 100;
		for (a = s; a < Gc; a++) w(q[a], hd) == de && (b += w(q[a], t)), w(Dc[a], hd) == de && (b += w(Dc[a], t)), w(Ec[a], hd) == de && (b += w(Ec[a], t)), w(q[a], hd) == ee && (b += 1), w(Dc[a], hd) == ee && (b += 1), w(Ec[a], hd) == ee && (b += 1);
		b = K(b, 100, 300);
		100 == b ? yf(D, 256, 195, "NEW GAME", 16777215, 10053171) : yf(D, 256, 195, "               NEW GAME with the Crown", 16777215, 10053171);
		if (Df(100 == b ? 256 : 316, 195, 100 == b ? 128 : 248, 24)) {
			if (Ef) {
				Ne();
				tb = l = 3;
				for (a = 0; 4 > a; a++) yb[a] = ec[a], zb[a] = q[s + a], Ab[a] = Dc[s + a], Eb[a] = Ec[s + a], ec[a] = 0, q[s + a] = 0, Dc[s + a] = 0, Ec[s + a] = 0;
				f++;
				te();
				Cf()
			}
			100 == b ? L(192, 203, 320, 203, 11141120) : L(192, 203, 440, 203, 11141120)
		}
		0 != ec[0] && 0 != ec[1] && 0 != ec[2] && 0 != ec[3] && (yf(D, 256, 235, "LOAD GAME", 16777215, 10053171), Df(256, 235, 128, 24) && (Ef && (f = 5), L(192, 243, 320, 243, 11141120)));
		yf(D, 256, 275, "VS MODE", 16777215, 5066137);
		Df(256, 275, 128, 24) && (Ef && (location.pathname = La ? "/javagame/ranger/versus.html" : "/en/javagame/ranger/versus.html"), L(192, 283, 320, 283, 11141120));
		Ff()
	} else if (3 == f) {
		v.move();
		I.b();
		v.b();
		Gf(D, 256, 50, "Player's Class Selection", 204, 148, 73, 255, 100, 0, 0, 255, 16, 24);
		for (a = 0; 4 > a; a++) Df(160 + 64 * a, 140, 24, 24) && (Ef && (tb = l = a), Hf(160 + 64 * a, 140, 24, 24, 8388608)), If(160 + 64 * a, 140, 25, 25, 16777215), J(Qa, 160 + 64 * a, 140, 24, 24, 24 * ec[a], 0, 24, 24, 16777215);
		If(160 + 64 * l, 140, 25, 25, 16711680);
		Ne();
		for (a = 0; 8 > a; a++) {
			var b = 46 + 60 * a,
				c = Jc[a + 1],
				d = D;
			d.Q = -1;
			yf(d, b, 220, c, 13407305, 6553600);
			d.Q = 0;
			Df(46 + 60 * a, 200, 24, 24) && (Ef && (ec[l] = a + 1, q[s + l] = [3, 4, 5, 6, 7, 8, 9, 10][a], Dc[s + l] = 0, Ec[s + l] = 0), Hf(46 + 60 * a, 200, 24, 24, 8388608));
			If(46 + 60 * a, 200, 25, 25, 16777215);
			J(Qa, 46 + 60 * a, 200, 24, 24, 24 * (a + 1), 0, 24, 24, 16777215)
		}
		for (a = 9; 11 > a; a++) { //SUMMONER REAPER New classes on the class select screen
			var b = 46 + 60 * (a - 9),
				c = Jc[a + 1],
				d = D;
			d.Q = -1;
			yf(d, b, 260, c, 13407305, 6553600);
			d.Q = 0;
			Df(46 + 60 * (a - 9), 240, 24, 24) && (Ef && (ec[l] = a + 1, q[s + l] = [3, 4, 5, 6, 7, 8, 9, 10, 0, 11, 12][a], Dc[s + l] = 0, Ec[s + l] = 0), Hf(46 + 60 * (a - 9), 240, 24, 24, 8388608));
			If(46 + 60 * (a - 9), 240, 25, 25, 16777215);
			J(Qa, 46 + 60 * (a - 9), 240, 24, 24, 24 * (a + 1), 0, 24, 24, 16777215)
		}
		0 != ec[0] && 0 != ec[1] && 0 != ec[2] && 0 != ec[3] && (yf(D, 464, 300, "START", 16777215, 10053171), Df(464, 300, 128, 24) && (Ef && f++, L(416, 308, 512, 308, 11141120)));
		yf(D, 48, 300, "RETURN", 16777215, 10053171);
		if (Df(48, 300, 128, 24)) {
			if (Ef) {
				for (a = 0; 4 > a; a++) ec[a] = yb[a], q[s + a] = zb[a], Dc[s + a] = Ab[a], Ec[s + a] = Eb[a];
				f = 2
			}
			L(0, 308, 96, 308, 11141120)
		}
		te();
		Ff()
	} else if (4 == f) {
		Ne();
		b = 100;
		c = 0;
		for (a = s; a < Gc; a++) w(q[a], hd) == de && (b += w(q[a], t)), w(Dc[a], hd) == de && (b += w(Dc[a], t)), w(Ec[a], hd) == de && (b += w(Ec[a], t)), w(q[a], hd) == ee && (c = 1), w(Dc[a], hd) == ee && (c = 1), w(Ec[a], hd) == ee && (c = 1);
		b = K(b, 100, 300);
		h = 0;
		Mb[0] = 1;
		Nb[0] = 1;
		for (a = dc = cc = $b[0] = 0; 4 > a; a++) ac[a] = 0, p[a] = 50, fc[a] = 0, gc[a] = 0, hc[a] = 0, ic[a] = 0, jc[a] = 0, uc[a] = 1;
		yc = xc = wc = vc = 0;
		zc = 1;
		for (a = Fc; a < Hc; a++) q[a] = 0, Dc[a] = 0, Ec[a] = 0;
		for (a = 0; a < ze; a++) Ae[a] = 0;
		Ae[0] = Be | Ce;
		Ae[1] = Ce;
		for (a = 0; 4 > a; a++) v.step[a] = 0;
		300 <= b ? q[Fc + 0] = 560 : 250 <= b ? q[Fc + 0] = 559 : 200 <= b ? q[Fc + 0] = 558 : 150 <= b && (q[Fc + 0] = 557);
		1 == c && 100 == b && (q[Fc + 0] = 561);
		1 == c && 100 != b && (q[Fc + 1] = 561);
		nb = qe.t = 0;
		f = 6;
		te();
		Ff()
	} else 5 == f ? (nb = 0, f = 6) : 6 == f && (qe.b(), Jf(2))
}
da.fff = vf;

function vf() { //Enemy screens
	var a, b, c, d;
	a = "";
	if (10 == f) {
		if (I.j(h)) {
			v.set(0, 0, I.o[0]);
			v.set(1, 1, I.o[1]);
			v.set(2, 2, I.o[2]);
			v.set(3, 3, I.o[3]);
			G.j(1);
			for (b=0; b<4; b++)	{//SUMMONER set summons' position to their ranger when entering a stage
				if (ec[b] == 10) {
					for (i=0; i<swarm[b]; i++){
						if (summons.species[b][i] == -1) continue; //Skip if not spawned
						summons.setPos(b, i);
					}
				}
			}
			G.isFriendly = false; //Enemies are not friendly on enemy screens... obviously
			var e = z(N(12, 28)),
				g = z(N(28, 44)),
				k = z(N(44, 60));
			Kb = 100;
			for (b = s; b < Gc; b++) w(q[b], hd) == de && (Kb += w(q[b], t)), w(Dc[b], hd) == de && (Kb += w(Dc[b], t)), w(Ec[b], hd) == de && (Kb += w(Ec[b], t));
			Kb = K(Kb, 100, 300);
			var r = z((Me[h][nb].length - 2) / 3);
			for (a = 0; a < r; a++) {
				var m = Me[h][nb][3 * a + 2],
					n = Me[h][nb][3 * a + 3],
					F = Me[h][nb][3 * a + 4],
					F = z(F * Kb / 100);
				for (b = 0; b < F; b++) {
					if (m == O) c = z(N(12, 60)), d = Kf(I.o[c], I.I[c]);
					else if (m == P) c = z(N(12, 28)), d = Kf(I.o[c], I.I[c]);
					else if (m == Q) c = z(N(28, 44)), d = Kf(I.o[c], I.I[c]);
					else if (m == R) c = z(N(44, 60)), d = Kf(I.o[c], I.I[c]);
					else if (m == S) c = z(N(12, 60)), d = z(N(I.$[c] + 2, I.I[c]));
					else if (m == Lf) c = z(N(12, 60)), d = z(N(I.$[c] + 2, I.hb[c]));
					else if (m == T && 0 < I.ab) d = z(A(I.ab)), c = I.gb[d] & 63, d = z(I.gb[d] / 64);
					else if (m == Mf) c = e, d = Kf(I.o[c], I.I[c]);
					else if (m == Nf) c = g, d = Kf(I.o[c], I.I[c]);
					else if (m == Of) c = k, d = Kf(I.o[c], I.I[c]);
					else if (m == Pf) c = z(N(12, 60)), d = I.$[c];
					else if (m == Qf) c = z(N(12, 28)), d = I.$[c];
					else if (m == Rf) c = z(N(28, 44)), d = I.$[c];
					else if (m == Sf) c = z(N(44, 60)), d = I.$[c];
					else continue;
					G.add(c, d, n)
				}
			}
			oe.index = 0;
			ne.index = 0;
			pe.index = 0;
			mb = sb = Ib = Hb = Gb = Fb = pe.J = 0;
			f++
		}
	} else if (11 == f) 
		Tf(0), 
		Jf(0), 
		r = 30, 
		a = "", 
		0 == nb ? (r = 110, a = Uf[h]) : 
		h == 16 ? nb == 1 && (r = 110, a = "SUPERBOSS") : //Superboss areas
		nb + 1 == Me[h].length && (r = 110, a = "BOSS AREA"), 
		Vf(255 - z(255 * (30 > mb ? mb : 30) / 30)), 
		110 == r && (b = 255, 30 > mb ? b = z(255 * mb / 30) : 80 < mb && (b = 255 - z(255 * (mb - 80) / 30)), Gf(D, 256, 128, a, 255, 255, 255, b, 64, 64, 64, b, 16, 24), c = -1024 + z(512 * mb / 30), L(c, 112, c + 1024, 112, 8421504), c = 512 - z(512 * mb / 30), L(c, 141, c + 1024, 141, 8421504)), mb++, mb == r && (mb = 0, f++);
	else if (12 == f) Tf(0), Jf(0), 0 == p[0] + p[1] + p[2] + p[3] ? (mb = 0, f = 30) : 0 != sb ? f++ : Wf(364, 4, 56, 20) ? (Ef ? f = 20 : Ze[32] && (f = 20), D.b(368, 8, "Option", 16711680, 0)) : Ze[32] ? f = 20 : Wf(428, 4, 80, 20) && (Ef && (f = 6), D.b(432, 8, "World Map", 16711680, 0));
	else if (13 == f) Tf(0), Jf(0), Vf(z(255 * mb / 30)), mb++, 30 == mb && (1 == sb ? (sb = 0, nb++, mb = 0, f = 10) : 2 == sb && (mb = nb = sb = 0, Ne(), Ae[h] |= Be, 0 < De[h][3] && (Ae[De[h][3]] |= Ce), 0 < De[h][4] && (Ae[De[h][4]] |= Ce), te(), f = 6, -1 == De[h][3] && (f = 40)), he = se(0), fe = 1);
	else if (20 == f) {
		Tf(1);
		Jf(1);
		r = 12;
		0 != h && 20 != h && 47 != h && 70 != h && 77 != h || 1 != nb || (r = 52);
		Wf(364, 4, 56, 20) ? (Ef ? f = r : Ze[32] && (f = r), D.b(368, 8, "Option", 16711680, 0)) : Ze[32] && (f = r);
		Xf = 1;
		V(128, 42, 256, 151, 3425907507);
		Xf = 0;
		yf(D, 256, 58, "OPTION", 16777215, 0);
		for (a = 0; 4 > a; a++) J(Qa, 256 + 32 * a, 78, 24, 24, 24 * w(q[s + a], Rc), 0, 24, 24, 16777215), Yf(256 + 32 * a - 12, 66, 24 * w(q[s + a], Rc), w(q[s + a], Sc));
		yf(D, 180, 98, "Auto move", 16777215, 0);
		b = ["OFF", "ON"];
		for (a = 0; 4 > a; a++) yf(D, 256 + 32 * a, 98, b[uc[a]], 16777215, 0), Df(256 + 32 * a, 98, 32, 13) && (yf(D, 256 + 32 * a, 98, b[uc[a]], 16711680, 0), Ef && (uc[a] = 1 - uc[a]));
		D.b(128, 108, "  Move of dying: " + b[vc], 16777215, 0);
		Wf(128, 108, 256, 13) && (D.b(128, 108, "  Move of dying: " + b[vc], 16711680, 0), vc = Zf(vc + $f, 0, 1));
		a = ["PLAYER&ENEMY", "PLAYER", "ENEMY", "OFF"];
		D.b(128, 121, "  Damage Effect: " + a[wc], 16777215, 0);
		Wf(128, 121, 256, 13) && (D.b(128, 121, "  Damage Effect: " + a[wc], 16711680, 0), wc = Zf(wc + $f, 0, 3));
		a = ["OFF", "PLAYER", "ENEMY", "PLAYER&ENEMY"];
		D.b(128, 134, "  LP Bar       : " + a[xc], 16777215, 0);
		Wf(128, 134, 256, 13) && (D.b(128, 134, "  LP Bar       : " + a[xc], 16711680, 0), xc = Zf(xc + $f, 0, 3));
		a = ["SQUARE", "TRIANGLE", "SHADOW", "OFF"];
		D.b(128, 147, "  PL Symbol    : " + a[yc], 16777215, 0);
		Wf(128, 147, 256, 13) && (D.b(128, 147, "  PL Symbol    : " + a[yc], 16711680, 0), yc = Zf(yc + $f, 0, 3));
		D.b(128, 160, "  Drag DeadBody: " + b[zc], 16777215, 0);
		Wf(128, 160, 256, 13) && (D.b(128, 160, "  Drag DeadBody: " + b[zc], 16711680, 0), zc = Zf(zc + $f, 0, 1));
		yf(D, 256, 182, "Space Key: open & close", 12632256, 0);
		Df(256, 182, 256, 13) && (yf(D, 256, 182, "Space Key: open & close", 16711680, 0), 0 != $f && (f = r))
	} else if (30 == f) {
		if (Tf(0), Jf(0), 100 > mb && mb++, b = z(255 * mb / 100), Gf(D, 256, 128, "GAME OVER", 100, 20, 10, b, 200, 0, 0, b, 16, 24), 100 == mb && Ef) {
			Ne();
			for (a = 0; 4 > a; a++) 0 == p[a] && (p[a] = 1);
			te();
			f = 1
		}
	} else if (40 == f) {
		Gf(D, 256, 112, "Congratulation", 204, 148, 73, 255, 100, 0, 0, 255, 16, 24);
		Gf(D, 256, 144, "Game Clear", 204, 148, 73, 255, 100, 0, 0, 255, 16, 24);
		yf(D, 256, 256, "(C) 2008-2017 DAN-BALL", 13407305, 6553600);
		for (a = 0; 4 > a; a++) {
			c = 166 + 60 * a - v.a[a][2].x;
			d = 224 - v.a[a][2].y;
			for (b = 0; 21 > b; b++) v.a[a][b].x += c, v.a[a][b].y += d;
			ag(Pa[12], 166 + 60 * a - 12, 233, 24, 8, 0, 0, 24, 8)
		}
		v.b();
		if (Ef) {
			Ne();
			for (a = 0; 4 > a; a++) 0 == p[a] && (p[a] = 1);
			te();
			f = 1
		}
	}
}
da.fff = wf;

function wf() { //Town screens
	var a, b, c, d, e = "";
	if (50 == f && I.j(h)){ //Enter stage
		v.set(0, 16, I.o[0]); 
		v.set(1, 19, I.o[1]); 
		v.set(2, 22, I.o[2]); 
		v.set(3, 25, I.o[3]); 
		G.j(1); 
		oe.index = 0; 
		ne.index = 0; 
		pe.index = 0; 
		mb = sb = Ib = Hb = Gb = Fb = pe.J = 0; 
		f++;
		for (b=0; b<4; b++)	{ //SUMMONER set summons' position to their ranger when entering a town NOTE: changed syntax of this 'if' block
			if (ec[b] == 10) {
				for (i=0; i<swarm[b]; i++) {
					if (summons.species[b][i] == -1) continue; //Skip if not spawned
					summons.setPos(b, i);
				}
			}
		}
		G.isFriendly = true; //Monsters in town are friendly
	}
	else if (51 == f) //No tab open
		Tf(0), 
		Jf(0), 
		e = "", 
		0 == h ? e = "TOWN" : 
		17 == h ? e = "VOID MONOLITH" : 
		20 == h ? e = "" : 
		21 == h && (e = "HILLSIDE SETTLEMENT"),
		Vf(255 - z(255 * (30 > mb ? mb : 30) / 30)), 
		c = 255, 30 > mb ? c = z(255 * mb / 30) : 80 < mb && (c = 255 - z(255 * (mb - 80) / 30)), 
		Gf(D, 256, 128, e, 255, 255, 255, c, 64, 64, 64, c, 16, 24), 
		b = -1024 + z(512 * mb / 30), 
		L(b, 112, b + 1024, 112, 8421504),
		b = 512 - z(512 * mb / 30), 
		L(b, 141, b + 1024, 141, 8421504), 
		mb++, 
		110 == mb && (mb = 0, f++);
	else if (52 == f)
		if (Tf(0), Jf(0), 0 != sb) f = 59;
		else if (Wf(364, 4, 56, 20)) Ef ? f = 20 : Ze[32] && (f = 20), D.b(368, 8, "Option", 16711680, 0);
	else if (Ze[32]) f = 20;
	else if (Wf(428, 4, 80, 20)) Ef && (f = 6), D.b(432, 8, "World Map", 16711680, 0);
	else if (17 == h) {
		if (Df(256, 160, 40, 24)) {
			yf(D, 256, 160, "FORGET", 16711680, 1054740);
			Ef && (f = 55, xb = wb = vb = 0);
		}
		else if (Df(256, 180, 40, 24)) {
			var g = 0;
			for (a = 0; 4 > a; a++) g += kc[a] - p[a];
			yf(D, 256, 180, "INN", 16711680, 1054740);
			D.b(280, 174, "charge of " + g, 16711680, 1054740);
			if (g <= dc && Ef) {
				Ne();
				for (a = 0; 4 > a; a++) p[a] != kc[a] && ne.add(v.a[a][0].x, v.a[a][0].y, 0, kc[a] - p[a], 65280), p[a] = kc[a];
				dc -= g;
				te()
			}
		}
	}
	else if (Df(400, 168, 40, 24)) {
		for (a = g = 0; 4 > a; a++) g += kc[a] - p[a];
		yf(D, 400, 168, "INN", 16711680, 13800762);
		yf(D, 400, 208, "charge of " + g, 16777215, 3219229);
		if (g <= dc && Ef) {
			Ne();
			for (a = 0; 4 > a; a++) p[a] != kc[a] && ne.add(v.a[a][0].x, v.a[a][0].y, 0, kc[a] - p[a], 65280), p[a] = kc[a];
			dc -= g;
			te()
		}
	} //SUMMONER Red summon text in town areas when selected player is a summoner
	else if (Df(255, 50, 64, 16) && ec[l] == 10) {
		yf(D, 255, 50, "SUMMON", 16711680, 13800762);
		if (Ef) summons.spawn(l, selectedSummon[l]);
	}
	else if (Df(251, 66, 64, 16) && ec[l] == 10) { //Displays summon slot number
		yf(D, 251, 66, "SLOT: ", 16711680, 13800762);
		if (Ef) selectedSummon[l] = (selectedSummon[l] + 1)%swarm[l];
	}
	else if (Df(255, 82, 40, 16) && ec[l] == 10) { //Fills all slots with currently equipped summon weapon
		yf(D, 255, 82, "ALL", 16711680, 13800762);
		if (Ef) {
			for (i=0; i<swarm[l]; i++) {
				summons.spawn(l, i);
			}
		}
	}
	else if (Df(255, 98, 64, 16) && ec[l] == 10){
		yf(D, 255, 98, "RESET", 16711680, 13800762);
		if (Ef) {
			for (i=0; i<swarm[l]; i++) {
				summons.despawn(l, i);
			}
		}
	}
	else Df(40, 152, 72, 24) ?
		(0 == h ? yf(D, 40, 152, "SHOP", 16711680, 13800762) : 
		21 == h ? yf(D, 40, 152, " COMPO SHOP", 16711680, 13800762) : 
		20 == h ? yf(D, 40, 152, "      SHOP", 16711680, 13800762) : 
		-2 == h ? yf(D, 40, 152, " JUNK SHOP", 16711680, 13800762) : 
		-2 == h && yf(D, 40, 152, " COMPO SHOP", 16711680, 13800762), 
		Ef && (f = 53, xb = wb = vb = 0)) : 
	//Df(280,188,40,24) ? 21 == h && (yf(D, 280, 188, "FORGE", 16711680, 13800762), Ef && (f = 56, xb = wb = vb = 0)) :
	Df(40, 184, 48, 24) && (yf(D, 40, 184, "BOOK", 16711680, 13800762), Ef && (f = 54, xb = wb = vb = 0));
	else if (53 == f) { //Shop tab open
		Tf(0);
		e = sb = 0;
		0 == h ? e = 0 : 21 == h ? e = 1 : 20 == h ? e = 2 : -2 == h && (e = 3);
		var k = [
			[4, 5, 6, 7, 8, 9, 10, 11, 12, 13], //SUMMONER REAPER shop tab
			[14, 15, 16, 17, 18, 19, 20],
			[4, 5, 6, 7, 8, 9, 10, 11, 12, 13], //Secret shop tab
			[14, 15, 16, 17, 18, 19, 20]
		];
		c = 80;
		d = 28;
		Xf = 1;
		V(c - 4, d - 4, 243, 168, 2147483648);
		Xf = 0;
		bg(c + 0, d + 0, 236, 161, 16777215);
		Wf(c + 8, d + 4, 16 * k[e].length, 12) && (b = z((cg - (c + 8)) / 16), Ef && (vb = b, wb = K(wb, 0, z(Lc[e][vb].length / 3) - 1)), V(c + 8 + 16 * b, d + 4, 12, 12, 10027008));
		dg = 2;
		for (a = 0; a < k[e].length; a++) eg(Ra, c + 8 + 16 * a, d + 4, 12, 12, 12 * k[e][a], 0, 12, 12, 16777215);
		dg = 0;
		bg(c + 8 + 16 * vb - 1, d + 4 - 1, 14, 14, 10027008);
		L(c + 0, d + 20 - 1, c + 235, d + 20 - 1, 16777215);
		Wf(c + 120, d + 24, 84, 84) && (b = z((cg - (c + 120)) / 28), a = z((fg - (d + 24)) / 28), Ef && (xb = 3 * a + b), V(c + 120 + 28 * b, d + 24 + 28 * a, 24, 24, 10027008));
		b = (3 * wb + xb) % Lc[e][vb].length;
		k = Lc[e][vb][b];
		g = 1;
		for (a = 0; a < ze; a++) 0 < (Ae[a] & Be) && g < gg[a] && (g = gg[a]);
		0 == h && g <= b && (k = 0);
		hg(c + 8, d + 24, u[k][Mc] + " " + (u[k][Nc] ? u[k][Nc] : ""), -1, 2631720, -2);
		hg(c + 8, d + 24, u[k][Mc] + " " + (u[k][Nc] ? u[k][Nc] : ""), 16777215, -1, -2);
		a = w(k, Rc);
		if (9 == a) D.b(c + 8, d + 40, "Compo Item", -1, 5263440), hg(c + 8, d + 56, u[k][jd], -1, 2631720, -2), hg(c + 8, d + 56, u[k][jd], 16777215, -1, -2), hg(c + 8, d + 68, u[k][kd], -1, 2631720, -2), hg(c + 8, d + 68, u[k][kd], 16777215, -1, -2);
		else {
			D.b(c + 8, d + 40, "AT " + u[k][Tc] + "-" + u[k][Uc], 16777215, 0);
			D.b(c + 8, d + 52, "AGI " + u[k][Wc] + "-" + u[k][Xc], 16777215, 0);
			D.b(c + 8, d + 64, "RANGE " + u[k][Yc], 16777215, 0);
			var r = w(k, $c), //ELEMENT shop UI (r = elemental type)
				m = w(k, ad),
				n = ig(w(k, bd), 0),
				F = w(k, dd),
				H = w(k, ed);
			if (r>9) r = 9;
			if (r>99) r = 10;
			D.b(c + 8, d + 80, "TYPE " + "physical;fire;ice;thunder;poison;freeze;gravity;drain;TYPE TYPE TZPE TYPF UYQE VOPF XORG Z?OC $YJB -AMS A'#G B>R-;dual;special".split(";")[r], 16777215, 0);
			D.b(c + 8, d + 92, "AT " + F + "-" + H, 16777215, 0);
			6 == a ? D.b(c + 8, d + 104, "$$ " + n, 16777215, 0) : D.b(c + 8, d + 104, "MP " + n, 16777215, 0);
			if (m!=0) {
				1 == r ? D.b(c + 8, d + 116, "BURN " + (z(100 * (m / 10)) / 100) + "%", 16777215, 0) : 
				2 == r ? D.b(c + 8, d + 116, "SLOW " + m + "%", 16777215, 0) : 
				3 == r ? D.b(c + 8, d + 116, "ARC " + m + "%", 16777215, 0) : 
				4 == r ? D.b(c + 8, d + 116, "TIME " + (z(100 * (m / 60)) / 100) + "s", 16777215, 0) : 
				5 == r ? D.b(c + 8, d + 116, "TIME " + (z(100 * (m / 60)) / 100) + "s", 16777215, 0) : 
				6 == r ? D.b(c + 8, d + 116, "FORCE " + m, 16777215, 0) : 
				7 == r && D.b(c + 8, d + 116, "CHANCE " + m + "%", 16777215, 0);
			} else if (r == 1) D.b(c + 8, d + 116, "EXPLOSION", 16777215, 0);
		}
		for (a = 0; 9 > a; a++) r = (3 * wb + a) % Lc[e][vb].length, 0 == h && g <= r || (dg = 2, eg(Ua, c + 120 + a % 3 * 28, d + 24 + 28 * z(a / 3), 24, 24, 24 * w(Lc[e][vb][r], Qc), 0, 24, 24, w(Lc[e][vb][r], Sc)), dg = 0, u[Lc[e][vb][r]][Nc] && hf.b(c + 120 + a % 3 * 28 + 19, d + 24 + 28 * z(a / 3) + 17, "" + u[Lc[e][vb][r]][Nc], 16777215, -1));
		bg(c + 120 + xb % 3 * 28, d + 24 + 28 * z(xb / 3), 24, 24, 10027008);
		g = w(k, Oc);
		2 == e && 1 == b && (g *= 10);
		if (Wf(c + 176 - 56, d + 120 - 10, 108, 20)) {
			if (h == 20 && Ef) { //Secret shop
				nb = 0;
				f = 10;
			}
			if (0 != k && g <= dc && Ef) {
				Ne();
				a = 0;
				if (0 == e || 2 == e && 0 == b) a = Ic;
				pe.add(40, 200, k, 0, a);
				dc -= g;
				te()
			}
			V(c + 176 - 56, d + 120 - 10, 108, 20, 10027008)
		}
		if (h == 20) g = 2147483647; //Secret shop
		yf(D, c + 176, d + 120, "" + g + "$ BUY", 16777215, 0);
		bg(c + 176 - 56, d + 120 - 10, 108, 20, 10027008);
		k = 16777215;
		Wf(c + 216 - 12, d + 36 - 12, 24, 24) && (Ef && (wb = Zf(wb - 1, 0, z(Lc[e][vb].length / 3) - 1)), k = 10027008);
		bg(c + 216 - 12, d + 36 - 12, 24, 24, 16777215);
		V(c + 216 - 1, d + 36 - 8, 2, 2, k);
		V(c + 216 - 2, d + 36 - 6, 4, 2, k);
		V(c + 216 - 3, d + 36 - 4, 6, 2, k);
		V(c + 216 - 4, d + 36 - 2, 8, 2, k);
		V(c + 216 - 5, d + 36 + 0, 10, 2, k);
		V(c + 216 - 6, d + 36 + 2, 12, 2, k);
		V(c + 216 - 7, d + 36 + 4, 14, 2, k);
		V(c + 216 - 8, d + 36 + 6, 16, 2, k);
		k = 16777215;
		Wf(c + 216 - 12, d + 92 - 12, 24, 24) && (Ef && (wb = Zf(wb + 1, 0, z(Lc[e][vb].length / 3) - 1)), k = 10027008);
		bg(c + 216 - 12, d + 92 - 12, 24, 24, 16777215);
		V(c + 216 - 8, d + 92 - 8, 16, 2, k);
		V(c + 216 - 7, d + 92 - 6, 14, 2, k);
		V(c + 216 - 6, d + 92 - 4, 12, 2, k);
		V(c + 216 - 5, d + 92 - 2, 10, 2, k);
		V(c + 216 - 4, d + 92 + 0, 8, 2, k);
		V(c + 216 - 3, d + 92 + 2, 6, 2, k);
		V(c + 216 - 2, d + 92 + 4, 4, 2, k);
		V(c + 216 - 1, d + 92 + 6, 2, 2, k);
		L(c + 0, d + 136 - 1, c + 235, d + 136 - 1, 16777215);
		L(c + 120, d + 136 - 1, c + 120, d + 160, 16777215);
		Wf(c + 0 + 1, d + 136, 120, 24) && 0 != q[Gc] ? (g = z(w(q[Gc], Oc) / 8), Ef && (Ne(), pe.add(40, 200, 1, g, 0), q[Gc] = 0, Dc[Gc] = 0, Ec[Gc] = 0, te()), V(c + 0 + 1, d + 136, 119, 24, 10027008), yf(D, c + 60, d + 148, "" + g + "$ SELL", 16777215, 0)) : Wf(c + 0 + 1, d + 136, 120, 24) && 0 == q[Gc] && 0 == Jb ? (Ef && (Jb = 1), V(c + 0 + 1, d + 136, 119, 24, 10027008), yf(D, c + 60, d + 148, "CLICK TO SELL", 16777215, 0)) : Wf(c + 0 + 1, d + 136, 120, 24) && 0 == q[Gc] && 1 == Jb ? (Ef && (Jb = 0), V(c + 0 + 1, d + 136, 119, 24, 10027008), yf(D, c + 60, d + 148, "CANCEL", 16777215, 0)) : 1 == Jb ? yf(D, c + 60, d + 148, "CANCEL", 16777215, 0) : yf(D, c + 60, d + 148, "DRAG TO SELL", 16777215, 0);
		Wf(c + 120 + 1, d + 136, 114, 24) && (Ef && (Jb = 0, f = 52), V(c + 120 + 1, d + 136, 114, 24, 10027008));
		yf(D, c + 176, d + 148, "EXIT", 16777215, 0);
		Jf(1)
	}
	else if (54 == f) { //Book tab open
		Tf(0);
		sb = 0;
		k = 10;
		c = 80;
		d = 28;
		Xf = 1;
		17 == h ? V(c - 4, d - 4, 384, 178, 3422552064) : V(c - 4, d - 4, 384, 178, 2147483648);
		Xf = 0;
		bg(c + 0, d + 0, 377, 171, 16777215);
		L(c + 160, d + 0, c + 160, d + 170, 16777215);
		e = "WORLD MAP " + (100 > vb ? " " : "");
		e += "" + z(vb / k + 1) + "/" + z((jg.length - 1) / k + 1);
		D.b(c + 20, d + 4, e, -1, 32768);
		Wf(c + 8, d + 16, 144, 12 * k) && (a = z((fg - (d + 16)) / 12), Ef && (wb = a), V(c + 8, d + 16 + 12 * a, 144, 12, 10027008));
		for (a = 0; a < k; a++) e = jg[vb + a], 0 != e && (0 < (Ae[e] & Be) ? D.b(c + 8, d + 16 + 12 * a, Uf[e], 16777215, 0) : D.b(c + 8, d + 16 + 12 * a, "???", 16777215, 0));
		e = jg[vb + wb];
		0 != e && (0 < (Ae[e] & Be) ? D.b(c + 8, d + 16 + 12 * wb, Uf[e], 16711680, 0) : D.b(c + 8, d + 16 + 12 * wb, "???", 16711680, 0));
		L(c + 0, d + 140, c + 160, d + 140, 16777215);
		Wf(c + 8, d + 149 - 2, 48, 17) && (Ef && (vb = Zf(z(vb / k) - 1, 0, z((jg.length - 1) / k)) * k), V(c + 8, d + 149 - 2, 48, 17, 10027008));
		D.b(c + 16, d + 149 + 1, "Prev", 16777215, 0);
		Wf(c + 56, d + 149 - 2, 48, 17) && (Ef && (vb = Zf(z(vb / k) + 1, 0, z((jg.length - 1) / k)) * k), V(c + 56, d + 149 - 2, 48, 17, 10027008));
		D.b(c + 64, d + 149 + 1, "Next", 16777215, 0);
		Wf(c + 104, d + 149 - 2, 48, 17) && (Ef && (f = 52), V(c + 104, d + 149 - 2, 48, 17, 10027008));
		D.b(c + 112, d + 149 + 1, "EXIT", 16777215, 0);
		if (0 != e)
			if (0 < (Ae[e] & kg)) {
				k = Pe[e + 1] - Pe[e]; //Amount of different enemies in stage e
				for (a = k - 1; 0 <= a; a--) k -= B[Pe[e] + a][Re];
				g = c + 80 - 16 * k;
				Wf(g + 160, d + 0, 32 * k, 52) && (b = z((cg - (g + 160)) / 32), Ef && (xb = b), V(g + 160 + 32 * b + 2, d + 0 + 2, 28, 52, 10027008));
				V(g + 160 + 32 * xb + 2, d + 48 + 2, 28, 4, 10027008);
				xb = K(xb, 0, k - 1);
				for (a = 0; a < k; a++) ag(Pa[Me[e][Me[e].length - 1][0]], g + 164 + 32 * a, d + 44, 24, 8, 0, 0, 24, 8);
				k = Pe[e + 1] - Pe[e];
				for (b = a = 0; a < k; a++, b++) G.M(Pe[e] + a, g + 164 + 12 + 32 * b, d + 44 - 1, 0), a += B[Pe[e] + a][Re];
				e = Pe[e] + xb;
				D.b(c + 164, d + 56, "Lv   " + B[e][Qe], 16777215, 0);
				D.b(c + 164, d + 68, "LP   " + B[e][lg], 16777215, 0);
				D.b(c + 164, d + 80, "GOLD " + B[e][mg], 16777215, 0);
				D.b(c + 164, d + 92, "EXP  " + B[e][ng], 16777215, 0);
				D.b(c + 164, d + 108, "Drop Item", 16777215, 0);
				for (b = a = 0; 8 > a; a += 2) k = B[e][og + a], 0 != k && (dg = 2, eg(Ra, c + 164, d + 4 * (30 + 3 * b), 12, 12, 12 * w(k, Pc), 0, 12, 12, w(k, Sc)), dg = 0, hg(c + 164, d + 4 * (30 + 3 * b), "  " + u[k][Mc] + " " + (u[k][Nc] ? u[k][Nc] : ""), 16777215, 0, -1), b++);
				D.b(c + 256, d + 56, "strong", 16777215, 0); //ELEMENT book enemy resistances
				0 < B[e][pg				] && (hf.b(c + 256, d + 68 + 2, "Ph "						, 8421504, 0), 	hf.b(c + 256, d + 68 + 10, "" + B[e][pg], 8421504, 0));
				0 < B[e][qg				] && (hf.b(c + 256, d + 68 + 2, "   Fi "					, 16711680, 0), hf.b(c + 256, d + 68 + 10, "   " + B[e][qg], 16711680, 0));
				0 < B[e][rg				] && (hf.b(c + 256, d + 68 + 2, "      Ic "					, 2105599, 0), 	hf.b(c + 256, d + 68 + 10, "      " + B[e][rg], 2105599, 0));
				0 < B[e][sg				] && (hf.b(c + 256, d + 68 + 2, "         Th "				, 16777024, 0), hf.b(c + 256, d + 68 + 10, "         " + B[e][sg], 16777024, 0));
				0 < B[e][tg				] && (hf.b(c + 256, d + 68 + 2, "            Po "			, 65280, 0), 	hf.b(c + 256, d + 68 + 10, "            " + B[e][tg], 65280, 0));
				0 < B[e][ug				] && (hf.b(c + 256, d + 68 + 2, "               Fr "		, 12632319, 0), hf.b(c + 256, d + 68 + 10, "               " + B[e][ug], 12632319, 0));
				0 < B[e][gravityResistEn] && (hf.b(c + 256, d + 68 + 2, "                  Gr "		, 0x5F007F, 0), hf.b(c + 256, d + 68 + 10, "                  " + B[e][gravityResistEn], 0x5F007F, 0));
				0 < B[e][drainResistEn	] && (hf.b(c + 256, d + 68 + 2, "                     Dr "	, 0x7F0026, 0), hf.b(c + 256, d + 68 + 10, "                     " + B[e][drainResistEn], 0x7F0026, 0));
				D.b(c + 256, d + 84, "weak", 16777215, 0);
				0 > B[e][pg				] && (hf.b(c + 256, d + 92 + 6, "Ph "						, 8421504, 0), 	hf.b(c + 256, d + 92 + 14, "" + B[e][pg]*(-1), 8421504, 0));
				0 > B[e][qg				] && (hf.b(c + 256, d + 92 + 6, "   Fi "					, 16711680, 0), hf.b(c + 256, d + 92 + 14, "   " + B[e][qg]*(-1), 16711680, 0));
				0 > B[e][rg				] && (hf.b(c + 256, d + 92 + 6, "      Ic "					, 2105599, 0), 	hf.b(c + 256, d + 92 + 14, "      " + B[e][rg]*(-1), 2105599, 0));
				0 > B[e][sg				] && (hf.b(c + 256, d + 92 + 6, "         Th "				, 16777024, 0), hf.b(c + 256, d + 92 + 14, "         " + B[e][sg]*(-1), 16777024, 0));
				0 > B[e][tg				] && (hf.b(c + 256, d + 92 + 6, "            Po "			, 65280, 0), 	hf.b(c + 256, d + 92 + 14, "            " + B[e][tg]*(-1), 65280, 0));
				0 > B[e][ug				] && (hf.b(c + 256, d + 92 + 6, "               Fr "		, 12632319, 0), hf.b(c + 256, d + 92 + 14, "               " + B[e][ug]*(-1), 12632319, 0));
				0 > B[e][gravityResistEn] && (hf.b(c + 256, d + 92 + 6, "                  Gr "		, 0x5F007F, 0), hf.b(c + 256, d + 92 + 14, "                  " + B[e][gravityResistEn]*(-1), 0x5F007F, 0));
				0 > B[e][drainResistEn	] && (hf.b(c + 256, d + 92 + 6, "                     Dr "	, 0x7F0026, 0), hf.b(c + 256, d + 92 + 14, "                     " + B[e][drainResistEn]*(-1), 0x7F0026, 0))
			} else 0 < (Ae[e] & Be) ? (yf(D, c + 240 + 28, d + 40, "It's free,", 16777215, 0),
				g = 0/*1E3 * (vb + wb + 1)*/, Df(c + 240 + 28, d + 80, 160, 160) && (g <= dc && Ef && (Ne(), Ae[e] |= kg, dc -= g, te()), Hf(c + 240 + 28, d + 80, 120, 32, 10027008)), yf(D, c + 240 + 28, d + 80, "Acquire", 16777215, 0)) : (yf(D, c + 240 + 28, d + 40, "?????", 16777215, 0), yf(D, c + 240 + 28, d + 80, "???", 16777215, 0));
		Jf(1)
	}
	else if (55 == f) { //Forget tab open
		Tf(0);
		sb = 0;
		c = 80;
		d = 28;
		Xf = 1;
		V(c - 4, d - 4, 328, 168, 3422552064);
		Xf = 0;
		bg(c + 0, d + 0, 321, 161, 16777215);
		L(c + 160, d + 0, c + 160, d + 160, 16777215);
		c = 100;
		d = 60;
		for (a = 0; 4 > a; a++) Wf(c + 32 * a - 4, d + 0 - 4, 32, 32) ? (V(c + 32 * a, d + 0, 24, 24, 10027008), Ef && (vb = a)) : V(c + 32 * a, d + 0, 24, 24, 0), eg(Qa, c + 32 * a, d, 24, 24, 24 * w(q[s + a], Rc), 0, 24, 24, 16777215), Yf(c + 32 * a, d, 24 * w(q[s + a], Rc), w(q[s + a], Sc));
		bg(c + 32 * vb - 1, d - 1, 26, 26, 16711680);
		D.b(c, d - 16, Jc[w(q[s + vb], Rc)], 16777215, 0);
		c = 100;
		d = 74;
		D.b(c, d + 16, "LP  " + gc[vb], 16777215, 0);
		D.b(c, d + 28, "STR " + hc[vb], 16777215, 0);
		D.b(c, d + 40, "DEX " + ic[vb], 16777215, 0);
		D.b(c, d + 52, "MAG " + jc[vb], 16777215, 0);
		D.b(c, d + 68, "LV  " + Mb[0], 16777215, 0);
		D.b(c, d + 68, "        SP " + ac[vb], 16777215, 0);
		c = 80;
		d = 28;
		L(c + 0, d + 140, c + 160, d + 140, 16777215);
		Wf(c + 56, d + 144 - 2, 48, 17) && (Ef && (f = 52), V(c + 56, d + 144 - 2, 48, 17, 10027008));
		D.b(c + 64, d + 144 + 1, "EXIT", 16777215, 0);
		g = 1E2 * (gc[vb] + hc[vb] + ic[vb] + jc[vb]); //Reduced price
		Df(c + 240, d + 80, 120, 32) && 0 < g && (g <= dc && Ef && (Ne(), ac[vb] += gc[vb] + hc[vb] + ic[vb] + jc[vb], gc[vb] = 0, hc[vb] = 0, ic[vb] = 0, jc[vb] = 0, dc -= g, te()), Hf(c + 240, d + 80, 120, 32, 10027008));
		yf(D, c + 240, d + 72, "Forget", 16777215, 0);
		yf(D, c + 240, d + 88, "" + g + "$ BUY", 16777215, 0);
		Jf(1)
	}
	/*else if (56 == f) { //Forge tab open
		Tf(0);
		sb = 0;
		c = 96;
		d = 28;
		Xf = 1;
		V(c - 4, d - 4, 161 + 8, 161 + 8, 2147483648);
		Xf = 0;
		bg(c + 0, d + 0, 161, 161, 16777215);
		L(c + 1, d + 135, c + 160, d + 135, 16777215);
		D.b(c + 32, d + 4, "Fusion Forge", -1, 32768);
		
		Wf(c + 80, d + 136, 80, 24) && (Ef && (Jb = 0, f = 52), V(c + 80, d + 136, 80, 24, 10027008));
		yf(D, c + 120, d + 148, "EXIT", 16777215, 0);
		Jf(1)
	}*/
	else 59 == f && (Tf(0), Jf(0), Vf(z(255 * mb / 30)), mb++, 30 == mb && (mb = nb = sb = 0, f = 6, Ne(), Ae[h] |= Be, 0 < De[h][3] && (Ae[De[h][3]] |= Ce), 0 < De[h][4] && (Ae[De[h][4]] |= Ce), te(), he = se(0), fe = 1))
}
da.fff = xf;

function xf() { //Useless PVP screens
	var a, b, c;
	if (70 == f) h = 0, nb = 1, I.j(h) && (v.set(0, 26, I.o[0]), v.set(1, 30, I.o[1]), v.set(2, 34, I.o[2]), v.set(3, 38, I.o[3]), G.j(1), oe.index = 0, ne.index = 0, pe.index = 0, mb = sb = Ib = Hb = Gb = Fb = pe.J = 0, f++);
	else if (71 == f || 72 == f || 73 == f || 74 == f)
		if (I.b(), v.move(), pe.move(), ne.move(), oe.move(), pe.b(), v.b(), oe.b(), ne.b(), Jf(0), 71 == f) 0 == ua ? La ? vg(xa, "\u30b3\u30e1\u30f3\u30c8\u3092\u8a18\u5165\u3057\u3066\uff2f\uff2b\u3092\u62bc\u3057\u3066\u4e0b\u3055\u3044") : vg(xa, "Enter comments and click OK.") : La ? 100 == ua ? vg(xa,
				"\u30a2\u30c3\u30d7\u30ed\u30fc\u30c9\u304c\u5b8c\u4e86\u3057\u307e\u3057\u305f") : 1 == ua ? vg(xa, "\u30e6\u30fc\u30b6\u30fc\u767b\u9332\u304c\u5fc5\u8981\u3067\u3059") : 2 == ua ? vg(xa, "1\u65e5\u306b1\u56de\u306e\u307f\u3067\u3059") : 3 == ua ? vg(xa, "10\u4ef6\u4ee5\u4e0a\u30a2\u30c3\u30d7\u30ed\u30fc\u30c9\u51fa\u6765\u307e\u305b\u3093") : vg(xa, "\u30a2\u30c3\u30d7\u30ed\u30fc\u30c9\u51fa\u6765\u307e\u305b\u3093") : 100 == ua ? vg(xa, "The upload has been completed.") : 1 == ua ? vg(xa, "User registration is required.") : 2 == ua ?
			vg(xa, "1 time in 1 day only.") : 3 == ua ? vg(xa, "Cannot upload more than 10 posts.") : vg(xa, "Cannot upload."), f++;
		else if (72 == f) {
		if (Hf(256, 100, 300, 100, 8421504), yf(D, 256, 70, "UPLOAD", 16752800, 0), J(xa, 256, 90, xa.u, 16, 0, 0, xa.u, 16, 0), 0 == ua) {
			b = wg;
			V(136, 108, 240, 16, 16777215);
			bg(135, 107, 242, 18, 0);
			if (Wf(136, 108, 240, 16) && (bg(135, 107, 242, 18, 16711680), xg)) {
				c = null;
				try {
					c = prompt("UPLOAD", b)
				} catch (d) {}
				null != c && (b = c)
			}
			vg(yg, b);
			eg(yg, 137, 108, 238, 16, 0, 0, 238, 16, 0);
			wg = b;
			b = Df(256, 140, 16, 12);
			yf(D, 256, 140, "OK", b ? 16711680 : 16777215,
				0);
			if (b && xg)
				if (2 > wg.length) La ? vg(xa, "\u30b3\u30e1\u30f3\u30c8\u3092\uff12\u6587\u5b57\u4ee5\u4e0a\u8a18\u5165\u3057\u3066\u4e0b\u3055\u3044") : vg(xa, "The comment must be longer than 2 characters.");
				else {
					b = wg;
					c = 0;
					a = b.length;
					for (var e = 0; e < a; e++) {
						var g = b.charCodeAt(e);
						c = 0 <= g && 128 >= g || 65377 <= g && 65439 >= g ? c + 1 : c + 2
					}
					20 < c ? La ? vg(xa, "\u30b3\u30e1\u30f3\u30c8\u3092\uff11\uff10\u6587\u5b57\u4ee5\u4e0b\u3067\u8a18\u5165\u3057\u3066\u4e0b\u3055\u3044") : vg(xa, "The comment must be shorter than 10 characters.") : f++
				}
		}
	} else 73 ==
		f ? (b = encodeURIComponent(wg), 0 == b.length ? (La ? vg(xa, "\u30a8\u30e9\u30fc") : vg(xa, "Error"), f = 72) : 0 == q[s + 0] || 0 == q[s + 1] || 0 == q[s + 2] || 0 == q[s + 3] ? (La ? vg(xa, "\u6b66\u5668\u3092\u88c5\u5099\u3057\u3066\u4e0b\u3055\u3044") : vg(xa, "Equip a weapon."), f = 72) : (Ne(), he = se(1), c = zg(47, 115, 99, 111, 114, 101, 47, 114, 97, 110, 103, 101, 114, 95, 101, 110, 116, 114, 121, 46, 112, 104, 112, 63, 97, 61), c += ha, c += Ag + (La ? "0" : "1"), c += Bg + b, c += Cg + he, Ue(c), Dg(c), f++)) : 74 == f && 0 != Eg && (ua = "ok" == Fg[0] ? 100 : "err1" == Fg[0] ? 1 : "err2" == Fg[0] ? 2 : "err3" == Fg[0] ? 3 : "err4" ==
			Fg[0] ? 4 : "err5" == Fg[0] ? 5 : 6, f = 71);
	else if (60 == f) {
		if (h = 0, nb = 1, I.j(h)) {
			v.set(0, 10, I.o[0]);
			v.set(1, 11, I.o[1]);
			v.set(2, 12, I.o[2]);
			v.set(3, 13, I.o[3]);
			v.set(4, 53, I.o[0]);
			v.set(5, 52, I.o[1]);
			v.set(6, 51, I.o[2]);
			v.set(7, 50, I.o[3]);
			Cf();
			Ne();
			for (a = 0; 8 > a; a++) p[a] = kc[a];
			for (a = 0; 8 > a; a++) fc[a] = 0;
			dc = 9999999;
			te();
			G.j(1);
			oe.index = 0;
			ne.index = 0;
			pe.index = 0;
			mb = sb = Ib = Hb = Gb = Fb = pe.J = 0;
			f++
		}
	} else if (61 == f || 62 == f || 63 == f || 64 == f)
		for (I.b(), 61 == f && (v.fb = 1), v.move(), ne.move(), oe.move(), v.fb = 0, v.b(), oe.b(), ne.b(), Cf(), 61 == f ? (mb = K(mb +
				1, 0, 30), a = z(255 * mb / 30), L(0, 110, z(512 * mb / 30), 110, 8421504), L(512 - z(512 * mb / 30), 143, 512, 143, 8421504), Df(256, 127, 512, 32) && 30 == mb ? (Ef && (f++, mb = 0), Hf(256, 127, 512, 32, 8388608), Gf(D, 256, 128, "FIGHT", 255, 255, 255, 255, 0, 0, 0, 255, 16, 24)) : Gf(D, 256, 128, "READY", 255, 255, 255, a, 0, 0, 0, a, 16, 24), Xf = 1, b = 110, c = 120, vg(xa, ma), J(xa, b, c + 0 - 2, xa.u, 16, 0, 0, xa.u, 16, a << 24 | 16777215), vg(Aa, na), J(Aa, b, c + 16 - 2, Aa.u, 16, 0, 0, Aa.u, 16, a << 24 | 16777215), b = 402, vg(Ba, qa), J(Ba, b, c + 0 - 2, Ba.u, 16, 0, 0, Ba.u, 16, a << 24 | 16777215), vg(Da, ra), J(Da, b, c + 16 - 2, Da.u,
				16, 0, 0, Da.u, 16, a << 24 | 16777215), Xf = 0) : 62 == f ? 0 == p[0] + p[1] + p[2] + p[3] ? (sa = 2, f++) : 0 == p[4] + p[5] + p[6] + p[7] && (sa = 1, f++) : 63 == f ? (0 == ua && (ua = 1, c = zg(47, 115, 99, 111, 114, 101, 47, 114, 97, 110, 103, 101, 114, 95, 118, 115, 46, 112, 104, 112, 63, 97, 61), c += ha, c += Ag + (La ? "0" : "1"), c += Bg + la, c += Cg + oa, 0 != q[s + 0] && 0 != q[s + 1] && 0 != q[s + 2] && 0 != q[s + 3] && (c += Gg + Ee(sa)), Ue(c), Dg(c)), f++) : 64 == f && (mb = K(mb + 1, 0, 50), a = z(255 * mb / 50), Df(256, 128, 96, 32) && 50 == mb && (Ef && (f = 60), Hf(256, 128, 96, 32, 8388608)), If(256, 128, 96, 32, 0 | z(a / 2) << 16), Gf(D, 256, 129, "RETRY", 255,
				255, 255, a, 0, 0, 0, a, 16, 24), b = 60, c = 72, Xf = 1, eg(xa, b, c + 0 - 2, xa.u, 16, 0, 0, xa.u, 16, a << 24 | 16777215), Xf = 0, Gf(D, b + 60, c + 40, 1 == sa ? "WIN" : "LOSE", 255, 255, 255, a, 1 == sa ? 255 : 0, 0, 1 == sa ? 0 : 255, a, 32, 48), 0 != Eg && ("ok" == Fg[0] ? (D.M(b, c + 64, "" + Fg[1] + " win " + Fg[2] + " lose", 255, 255, 255, a, 0, 0, 0, a, 8, 12), D.M(b, c + 80, "Winning per " + Fg[3] + "%", 255, 255, 255, a, 0, 0, 0, a, 8, 12)) : D.M(b, c + 64, " RANKING ERROR", 255, 255, 255, a, 0, 0, 0, a, 8, 12)), b = 332, Xf = 1, eg(Ba, b, c + 0 - 2, Ba.u, 16, 0, 0, Ba.u, 16, a << 24 | 16777215), Xf = 0, Gf(D, b + 60, c + 40, 2 == sa ? "WIN" : "LOSE", 255, 255, 255,
				a, 2 == sa ? 255 : 0, 0, 2 == sa ? 0 : 255, a, 32, 48), 0 != Eg && ("ok" == Fg[0] ? (D.M(b, c + 64, "" + Fg[4] + " win " + Fg[5] + " lose", 255, 255, 255, a, 0, 0, 0, a, 8, 12), D.M(b, c + 80, "Winning per " + Fg[6] + "%", 255, 255, 255, a, 0, 0, 0, a, 8, 12)) : D.M(b, c + 64, " RANKING ERROR", 255, 255, 255, a, 0, 0, 0, a, 8, 12))), V(0, 257, 512, 126, [13407305, 9480368, 7241784, 10993609, 11302740, 24586, 7297069, 7297069, 10053120][Me[h][nb][0]]), hf.M(10, 374, Hg, 0, 0, 0, 0, 0, 0, 0, 128, 5, 7), Gf(D, 256, 328, "VS", 255, 255, 255, 255, 0, 0, 0, 255, 16, 24), b = 40, c = 268, eg(xa, b, c + 0 - 2, xa.u, 16, 0, 0, xa.u, 16, 0), D.b(b,
				c + 16, "LV " + Mb[0], 16777215, 0), D.b(b, c + 16, "        FP " + Nb[0], 16777215, 0), vg(Fa, "\u300c " + na + " \u300d"), J(Fa, b + 60, c + 88, Fa.u, 16, 0, 0, Fa.u, 16, 0), b = 206, Gf(D, b, c + 20 + 2, "Rank", 0, 0, 0, 0, 0, 0, 0, 128, 8, 12), Gf(D, b, c + 60, "" + Kc[$b[0]], 0, 0, 0, 0, 0, 0, 0, 80, 32, 48), b = 352, eg(Ba, b, c + 0 - 2, Ba.u, 16, 0, 0, Ba.u, 16, 0), D.b(b, c + 16, "LV " + Mb[1], 16777215, 0), D.b(b, c + 16, "        FP " + Nb[1], 16777215, 0), vg(Ga, "\u300c " + ra + " \u300d"), J(Ga, b + 60, c + 88, Ga.u, 16, 0, 0, Ga.u, 16, 0), b = 306, Gf(D, b, c + 20 + 2, "Rank", 0, 0, 0, 0, 0, 0, 0, 128, 8, 12), Gf(D, b, c + 60, "" + Kc[$b[1]],
				0, 0, 0, 0, 0, 0, 0, 80, 32, 48), b = 40, c = 316, a = 0; 8 > a; a++) 4 <= a && (b = 224), V(b + 32 * a, c - 12, z(24 * p[a] / kc[a]), 4, 8388608), e = ig(w(q[s + a], bd), 1), g = w(q[s + a], Rc), 4 != g && 5 != g && 6 != g && V(b + 32 * a, c - 6, z(23 * fc[a] / e) + 1, 2, 128), V(b + 32 * a, c + 0, 24, 24, 0), eg(Qa, b + 32 * a, c, 24, 24, 24 * w(q[s + a], Rc), 0, 24, 24, 16777215), Yf(b + 32 * a, c, 24 * w(q[s + a], Rc), w(q[s + a], Sc))
}

function Ff() { //Menu credits
	V(0, 368, 512, 16, 0);
	yf(D, 256, 376, Ve, -1, 6697728)
}
da.fff = Tf;

function Tf(a) { //Draw stage
	var b;
	I.b();
	if (0 == h && 1 == nb || 21 == h && 1 == nb || 20 == h && 50 <= f) 
		J(db, 400, 183, 117, 84, 0, 0, 78, 56, 16777215), 
		J(db, 40, 170, 156, 112, 0, 0, 78, 56, 16777215), 
		//h == 21 && J(fenceImg, 280, 208, 128, 32, 0, 0, 64, 16, 0xFFFFFF),
		yf(D, 400, 168, "INN", 16777215, 13800762), 
		(ec[l] == 10 && f == 52) && (yf(D, 255, 50, "SUMMON", 16777215, 13800762), yf(D, 251, 66, "SLOT: ", 16777215, 13800762), yf(D, 279, 66, "" + (selectedSummon[l] + 1), w(summons.weaponID[l][selectedSummon[l]], qd), 16777215), yf(D, 255, 82, "ALL", 16777215, 13800762), yf(D, 255, 98, "RESET", 16777215, 13800762)), //SUMMONER White summon text in town areas when selected player is a summoner
		0 == h ? yf(D, 40, 152, "SHOP", 16777215, 13800762) : 
		21 == h ? (yf(D, 40, 152, " COMPO SHOP", 16777215, 13800762)/*, yf(D, 280, 188, "FORGE", 16777215, 13800762)*/) : 
		20 == h ? yf(D, 40, 152, "      SHOP", 16777215, 13800762) :
		-2 == h ? yf(D, 40, 152, " JUNK SHOP", 16777215, 13800762) : 
		-2 == h && yf(D, 40, 152, " COMPO SHOP", 16777215, 13800762), 
		yf(D, 40, 184, "BOOK", 16777215, 13800762);
	17 == h && 1 == nb && (eg(hb, 140, -32, 256, 256, 0, 0, 64, 64, 16777215), 52 == f && (yf(D, 256, 160, "FORGET", 16777215, 1054740), yf(D, 256, 180, "INN", 16777215, 1054740)));
	0 == a && (v.move(), G.move(), pe.move(), ne.move(), oe.move());
	b = I;
	if (b.w != 16 && nb != Me[b.w].length - 1 || 0 == G.index) { //Superboss requires kill to move on
		var c;
		c = 7 == Me[h][nb][1] ? 8 * b.o[63] - 16 : 8 * b.I[63] - 16;
		ag(Wa, 480, c, 32, 24, 0, 0, 32, 24);
		nb == Me[b.w].length - 1 ? 
			-2 == b.w ? 
				yf(hf, 496, c + 8, "END", 0, -1) : 
				yf(hf, 496, c + 8, "MAP", 0, -1) : 
			(nb == Me[b.w].length - 2 && b.w != 16) ? 
				yf(hf, 496, c + 8, "BOSS", 0, -1) : 
				yf(hf, 496, c + 8, "NEXT", 0, -1)
	}
	G.b();
	pe.b();
	v.b();
	oe.b();
	var d = I,
		e, g, k;
	k = C;
	switch (d.w) {
		case 13: //mist
		case 14:
		case 15:
		case 16:
			Xf = 1;
			dg = 3;
			C = Ma.f;
			b = N(1.7, 3.69);
			b *= b * b * b;
			J(Za, N(0, 512), 256 - b, 256, 32, 96, 0, 16, 16, 150994943);
			e = 256 * ea;
			if (3 > A(100))
				for (b = 64 * ea; b < e; b++) C[b] = 250 * C[b] >> 8;
			C = k;
			for (b = 64 * ea; b < e; b++) d = Ma.f[b] & 255, c = C[b] >> 16 & 255, k = ((255 - c) * d >> 8) + c, c = C[b] >> 8 & 255, g = ((255 - c) * d >> 8) + c, c = C[b] & 255, c = ((255 - c) * d >> 8) + c, C[b] = k << 16 | g << 8 | c;
			Xf = dg = 0;
			break;
		case 100: //darkness
			C = Ma.f;
			e = 256 * ea;
			for (b = 0; b < e; b++) C[b] = 255;
			Xf = dg = 3;
			for (b = 0; 4 > b; b++) J(Za, v.a[b][0].x, v.a[b][0].y, 80, 80, 33, 1, 14, 14, 3238002687);
			for (b = 0; b < oe.index; b++) 1 != oe.F[b] && J(Za, oe.a[b].x, oe.a[b].y, 32, 32, 33, 1, 14, 14, 2164260863);
			for (b = 0; 4 > b; b++)
				if (8 == v.step[b])
					for (c = 0; 6 > c; c++) 0 != v.O[b][c] && J(Za, v.a[b][15 + c].x, v.a[b][15 + c].y, 32, 32, 33, 1, 14, 14, 2164260863);
			for (b = 0; b < pe.index; b++) J(Za, pe.a[b].x, pe.a[b].y - 6, 32, 32, 33, 1, 14, 14, 4294967295);
			J(Za, cg, fg, 80, 80, 33, 1, 14, 14, 3238002687);
			C = k;
			Xf = 1;
			for (b = 0; b < e; b++) d = Ma.f[b], 255 == d ? C[b] = 251658240 : (c = C[b] >> 16 & 255, k = (-c * d >> 8) + c, c = C[b] >> 8 & 255, g = (-c * d >> 8) + c, c = C[b] & 255, c = (-c * d >> 8) + c, C[b] = k << 16 | g << 8 | c);
			Xf = dg = 0;
			break;
		case 100: //desert
			b = 1 * Ig & 511;
			for (g = 0; 256 > g; g++) {
				c = 512 * g;
				k = ~~(4 * Xe[b][1] + 0.5);
				for (e = 0; 512 > e; e++) Ma.f[c + e] = C[c + K(e + k, 0, 511)];
				b = b + 6 & 511
			}
			e = 256 * ea;
			for (c = 0; c < e; c++) C[c] = Ma.f[c];
			break;
		case 100: //snow
			e = 1;
			57 == d.w ? e = 2 : 58 == d.w ? e = 2 : 59 == d.w ? e = 2 : 60 == d.w ? e = 3 : 61 == d.w && (e = 3);
			for (b = 0; b < e; b++) Ma.f[z(A(24576))] = 1;
			for (b = 224 * ea - 1; 0 <= b; b--) 1 == Ma.f[b] && ((g = I.e[b >> 12][(b & 511) >> 3], -1 == g || 0 == g && 3 > (b & 7) && 3 > (b >> 9 & 7) || 2 == g && 4 < (b & 7) && 3 > (b >> 9 & 7)) ? !(50 > A(100)) && (c = 57 == d.w || 58 == d.w || 61 == d.w ? b + ea + z(A(4)) - 2 : b + ea + z(A(3)) - 1, 1 != Ma.f[c] && (g = I.e[c >> 12][(c & 511) >> 3], -1 == g || 0 == g && 3 > (c & 7) && 3 > (c >> 9 & 7) || 2 == g && 4 < (c & 7) && 3 > (c >> 9 & 7))) && (Ma.f[c] = Ma.f[b], Ma.f[b] = 0) : Ma.f[b] = 0);
			C = Ma.f;
			for (b = 0; 4 > b; b++) 0 != p[b] && (Hf(v.a[b][0].x, v.a[b][0].y, 3, 3, 0), Hf(v.a[b][9].x, v.a[b][9].y, 1, 1, 0), Hf(v.a[b][10].x, v.a[b][10].y, 1, 1, 0));
			for (b = 0; b < oe.index; b++) 1 == oe.U[b] && Hf(oe.a[b].x, oe.a[b].y, 3, 3, 0);
			C = k;
			for (b = 224 * ea - 1; 0 <= b; b--) 1 == Ma.f[b] && (C[b] = 15266040)
	}
	ne.b();
	Xf = 1;
	V(4, 4, 8 * (Uf[h].length + 6) + 8, 20, 2151694400);
	Xf = 0;
	0 == h && 1 == nb || 17 == h && 1 == nb || 21 == h && 1 == nb || 20 == h && 10 == nb ? D.b(8, 8, Uf[h], 16777215, 0) : nb + 1 == Me[h].length ? D.b(8, 8, Uf[h] + ": BOSS", 16777215, 0) : D.b(8, 8, Uf[h] + ": " + (nb + 1), 16777215, 0);
	Xf = 1;
	V(364, 4, 56, 20, 2151694400);
	Xf = 0;
	D.b(368, 8, "Option", 16777215, 0);
	Xf = 1;
	V(428, 4, 80, 20, 2151694400);
	Xf = 0;
	D.b(432, 8, "World Map", 16777215, 0);
	if (0 < Hb && (0 == a && Hb--, V(196, 10, 120, 12, 3158064), V(196, 10, z(120 * Fb / Gb), 12, 6291456), 0 < (Ae[h] & kg))) {
		yf(hf, 256, 16, "" + Fb + "/" + Gb, 16777215, 0);
		G.M(Ib, 206, 33, 1);
		hf.b(216, 25, "DROP", 16777215, 0);
		for (b = a = 0; 8 > a; a += 2) c = B[Ib][og + a], 0 != c && (dg = 2, eg(Ra, 236 + 12 * b, 23, 12, 12, 12 * w(c, Pc), 0, 12, 12, w(c, Sc)), dg = 0, b++);
		a = Jg(G, Ib, 1);
		hf.b(284, 25, "EXP " + a, 16777215, 0)
	}
}
da.fff = Cf;

function Cf() { //Set ranger stats
	var a, b, summonCompoVal;
	Ne();
	Nb[0] = Mb[0];
	Nb[1] = Mb[1];
	for (a = 0; 4 > a; a++) Nb[0] += 2 * w(q[s + a], Nc) + w(Dc[s + a], Nc) + w(Ec[s + a], Nc);
	for (a = 4; 8 > a; a++) Nb[1] += 2 * w(q[s + a], Nc) + w(Dc[s + a], Nc) + w(Ec[s + a], Nc);
	$b[0] = 9 > z((Nb[0] - 1) / 20) ? z((Nb[0] - 1) / 20) : 9;
	$b[1] = 9 > z((Nb[1] - 1) / 20) ? z((Nb[1] - 1) / 20) : 9;
	var c = 1 != ga ? 4 : 8;
	for (a = 0; a < c; a++) {
		lc[a] = 0 + hc[a];
		mc[a] = 0 + ic[a];
		nc[a] = 0 + jc[a];
		x(s + a, md) && (lc[a] += y(s + a, t));
		x(s + a, nd) && (mc[a] += y(s + a, t));
		x(s + a, od) && (nc[a] += y(s + a, t));
		x(s + a, pd) && (lc[a] += y(s + a, t), mc[a] += y(s + a, t), nc[a] += y(s + a, t));
		b = w(q[s + a], Tc);
		var d = w(q[s + a], Uc),
			e = w(q[s + a], Wc),
			g = w(q[s + a], Xc),
			k = w(q[s + a], Yc);
		1 == ec[a] ? //Boxer
			(oc[a] = b + z(lc[a] / 2), 
			pc[a] = d + z(lc[a]), 
			qc[a] = e, 
			rc[a] = g, 
			tc[a] = k, 
			kc[a] = 50 + 10 * gc[a] + 4 * lc[a] + 3 * mc[a] + 2 * nc[a]) : 
		2 == ec[a] ? //Gladiator
			(pc[a] = d + z(lc[a] / 2), 
			oc[a] = b + z(lc[a] / 2), 
			qc[a] = e, 
			rc[a] = g, 
			tc[a] = k, 
			x(s + a, compoBlademaster) && (tc[a] += y(s + a, t)), 
			kc[a] = 50 + 10 * gc[a] + 4 * lc[a] + 3 * mc[a] + 2 * nc[a]) : 
		3 == ec[a] ? //Sniper
			(oc[a] = b + z(mc[a] / 4), 
			pc[a] = d + z(mc[a] / 3), 
			qc[a] = e, 
			rc[a] = g, 
			tc[a] = k + 2 * lc[a], 
			x(s + a, Id) && (tc[a] += y(s + a, t)), 
			kc[a] = 50 + 8 * gc[a] + 2 * lc[a] + 3 * mc[a] + 2 * nc[a]) : 
		4 == ec[a] ? //Magician
			(oc[a] = b + z(nc[a] / 4), 
			pc[a] = d + z(nc[a] / 3), 
			qc[a] = ig(e - mc[a], 50), 
			rc[a] = ig(g - mc[a], 60), 
			tc[a] = k + 2 * lc[a], 
			x(s + a, Id) && (tc[a] += y(s + a, t)), 
			kc[a] = 50 + 8 * gc[a] + 2 * lc[a] + 2 * mc[a] + 2 * nc[a]) : 
		5 == ec[a] ? //Priest
			(oc[a] = b, 
			pc[a] = d, 
			qc[a] = e, 
			rc[a] = g, 
			tc[a] = k, 
			x(s + a, Id) && (tc[a] += y(s + a, t)), 
			kc[a] = 50 + 8 * gc[a] + 2 * lc[a] + 2 * mc[a] + 2 * nc[a]) : 
		6 == ec[a] ? //Gunner
			(oc[a] = b + z(b * lc[a] / 50), 
			pc[a] = d + z(d * lc[a] / 50), 
			qc[a] = ig(z(50 * e / (mc[a] + 50)), 5), 
			rc[a] = ig(z(50 * g / (mc[a] + 50)), 10), 
			tc[a] = k, 
			x(s + a, Id) && (tc[a] += y(s + a, t)), 
			kc[a] = 50 + 8 * gc[a] + 2 * lc[a] + 2 * mc[a] + 2 * nc[a]) : 
		7 == ec[a] ? //Whipper
			(oc[a] = b, 
			pc[a] = d + z(lc[a] / 2), 
			qc[a] = e, 
			rc[a] = g, 
			tc[a] = k, 
			kc[a] = 50 + 10 * gc[a] + 3 * lc[a] + 3 * mc[a] + 2 * nc[a]) : 
		8 == ec[a] ? //Angel
			(oc[a] = b + z(lc[a] / 4), 
			pc[a] = d + z(lc[a] / 3), 
			qc[a] = e, 
			rc[a] = g, 
			tc[a] = k, 
			x(s + a, Id) && (tc[a] += y(s + a, t)), 
			kc[a] = 50 + 10 * gc[a] + 3 * lc[a] + 2 * mc[a] + 2 * nc[a]) : 
		10 == ec[a] ? //SUMMONER stats
			(oc[a] = b + z(lc[a] / 2), //minAT
			pc[a] = d + z(lc[a] / 2), //maxAT
			qc[a] = e, //minAGI
			rc[a] = g, //maxAGI
			tc[a] = k, //range
			x(s + a, Id) && (tc[a] += y(s + a, t)), //catapult's card
			kc[a] = 50 + 8 * gc[a] + 2 * lc[a] + 1 * mc[a] + 2 * nc[a]) : //LP
		11 == ec[a] && //REAPER stats
			(oc[a] = b + z(lc[a] / 2), //minAT
			pc[a] = d + lc[a], //maxAT
			qc[a] = e, //minAGI
			rc[a] = g, //maxAGI
			tc[a] = k, //range
			x(s + a, Id) && (tc[a] += y(s + a, t)), //catapult's card
			kc[a] = 50 + 10 * gc[a] + 3 * lc[a] + 2 * mc[a] + 2 * nc[a]); //LP
		
		//SUMMONER LP-boosting compos (and taking other-color stones' LP-boost into account)
		if (ec[a] == 10) {
			if (x(s + a, md)) kc[a] -= 2 * y(s + a, t); //Remove Red Stone LP
			if (x(s + a, nd)) kc[a] -= 1 * y(s + a, t); //Remove Green Stone LP
			if (x(s + a, od)) kc[a] -= 2 * y(s + a, t); //Remove Blue Stone LP
			if (x(s + a, pd)) kc[a] -= 5 * y(s + a, t); //Remove Black Stone LP
			//White Stone, Red, Green, Blue, Black for LP
			summonCompoVal = getDefenseCompoValues(a, ld, t) + 2 * getDefenseCompoValues(a, md, t) + getDefenseCompoValues(a, nd, t) + 2 * getDefenseCompoValues(a, od, t) + 5 * getDefenseCompoValues(a, pd, t);
			kc[a] += summonCompoVal;
			//Zombie's Card
			summonCompoVal = getDefenseCompoValues(a, Pd, t);
			kc[a] += z(summonCompoVal * kc[a] / 100);
		}
		else {
			x(s + a, ld) && (kc[a] += y(s + a, t));
			x(s + a, Pd) && (kc[a] += z(y(s + a, t) * kc[a] / 100));
			x(s + a, ce) && (kc[a] += y(s + a, id));
		}
		1 == w(q[s + a], Rc) || 
		2 == w(q[s + a], Rc) || 
		3 == w(q[s + a], Rc) || 
		7 == w(q[s + a], Rc) || 
		8 == w(q[s + a], Rc) ||
		(10 == w(q[s + a], Rc) && //SUMMONER MP-using (melee) summons
			(w(q[s + a], hd) == 0 || 
			w(q[s + a], hd) == 1 || 
			w(q[s + a], hd) == 2 || 
			w(q[s + a], hd) == 4 || 
			w(q[s + a], hd) == 6)) || 
		11 == w(q[s+a], Rc) ? //REAPER
		(x(s + a, qd) && (oc[a] += y(s + a, t), pc[a] += y(s + a, id)), x(s + a, rd) && (oc[a] += z(y(s + a, t) * oc[a] / 100), pc[a] += z(y(s + a, t) * pc[a] / 100)), x(s + a, ae) && (oc[a] += z(y(s + a, t) * oc[a] / 100), pc[a] += z(y(s + a, t) * pc[a] / 100))) : 
		4 == w(q[s + a], Rc) || 
		5 == w(q[s + a], Rc) ||
		(10 == w(q[s + a], Rc) && //SUMMONER ranged summons
			(w(q[s + a], hd) == 3 || 
			w(q[s + a], hd) == 5 || 
			w(q[s + a], hd) == 7 || 
			w(q[s + a], hd) == 8 || 
			w(q[s + a], hd) == 9 || 
			w(q[s + a], hd) == 10)) ? 
		(x(s + a, yd) && (oc[a] += y(s + a, t), pc[a] += y(s + a, id)), x(s + a, Ad) && (oc[a] += y(s + a, t), pc[a] += y(s + a, id)), x(s + a, Cd) && (oc[a] += y(s + a, t), pc[a] += y(s + a, id)), x(s + a, Dd) && (oc[a] += y(s + a, t), pc[a] += y(s + a, id))) : 
		6 == w(q[s + a], Rc) && (x(s + a, qd) && (oc[a] += y(s + a, t), pc[a] += y(s + a, id)), x(s + a, rd) && (oc[a] += z(y(s + a, t) * oc[a] / 100), pc[a] += z(y(s + a, t) * pc[a] / 100)), 0 == w(q[s + a], cd) && (x(s + a, yd) && (oc[a] += y(s + a, t), pc[a] += y(s + a, id)), x(s + a, Ad) && (oc[a] += y(s + a, t), pc[a] += y(s + a, id)), x(s + a, Cd) && (oc[a] += y(s + a, t), pc[a] += y(s + a, id)), x(s + a, Dd) && (oc[a] += y(s + a, t), pc[a] += y(s + a, id))));
		x(s + a, Gd) && (b = y(s + a, t), qc[a] -= z(qc[a] * b / 100), rc[a] -= z(rc[a] * b / 100));
		oc[a] += z(oc[a] * Ac[a] / 100);
		pc[a] += z(pc[a] * Ac[a] / 100);
		1 == ga && (kc[a] *= [1, 5, 5, 5, 5, 3, 4, 5, 5][ec[a]], kc[a] *= $b[1] + 1);
		p[a] = K(p[a], 0, kc[a])
	}
	for (a = 0; a < c; a++) Ac[a] = 0, Bc[a] = 0, Cc[a] = 0;
	for (a = 0; a < c; a++) {
		if (5 == ec[a] && 5 == w(q[s + a], Rc)/* && 0 != p[a]*/ && priestAuraTimer[a] > 0) {
			priestAuraTimer[a]--;
			for (b = a >> 2 << 2; b < (a >> 2 << 2) + 4; b++) 0 != p[b] && (Ac[b] += lc[a], Bc[b] += mc[a], Cc[b] += nc[a]);
		}
	}
	for (a = 0; a < c; a++) //SUMMONER update the summons' AT values with summoner's current aura
		if (ec[a] == 10) summons.applyAura(a);
	te()
}
da.fff = Jf;

function Jf(a) { //Draw UI
	var b, c, d, e, g;
	Lg && 256 <= fg ? ub = !0 : Lg && 256 > fg && (ub = !1);
	V(0, 257, 512, 126, [0xAE7E1F, 9480368, 0x726D35, 7630870, 11302740, 13599032, 10993609, 6322320, 1921195, 10053120, 6714227, 6313296, 6313296][Me[h][nb][0]]);
	hf.M(10, 374, Hg, 0, 0, 0, 0, 0, 0, 0, 128, 5, 7);
	e = 10;
	g = 260;
	var k = 4753E3;
	c = 9999999;
	if (98 > Mb[0]) {
		k = 0;
		for (b = 1; b < Mb[0]; b++) k += 1E3 * b;
		c = k + 1E3 * b
	}
	Cf();
	if (2 == a) {
		Ne();
		for (b = 0; 4 > b; b++) Ac[b] = 0, Bc[b] = 0, Cc[b] = 0;
		te()
	}
	if (4 > l) {
		b = "LP  " + p[l] + "/" + kc[l];
		d = "STR " + lc[l];
		var r = "DEX " + mc[l],
			m = "MAG " + nc[l];
		D.b(e, g + 0, Jc[w(q[s + l], Rc)], 16777215, 0);
		D.b(e, g + 16, b, 16777215, 0);
		if (v.step[l] != Mg)
			if (D.b(e, g + 28, d, 16777215, 0), 
			D.b(e, g + 40, r, 16777215, 0), 
			D.b(e, g + 52, m, 16777215, 0), 
			hf.b(e, g + 28 + 2, "              AT ", -1, 0), 
			hf.b(e, g + 40 + 2, "              AGI ", -1, 0), 
			hf.b(e, g + 52 + 2, "              RANGE ", -1, 0), 
			hf.b(e, g + 28 + 2, "                 " + oc[l] + "-" + pc[l], 0, -1), 
			hf.b(e, g + 40 + 2, "                  " + qc[l] + "-" + rc[l], 0, -1), 
			hf.b(e, g + 52 + 2, "                    " + tc[l], 0, -1), 
			5 == ec[l]) //Priest
				hf.b(e, g + 64 + 2, "AURA", -1, 0), 
				hf.b(e, g + 64 + 2, "    :(AT)" + lc[l] + "% (MP)" + (nc[l] / 4) + " (TIME)" + (1 + mc[l] / 5) + "s", 0, -1);

			else if (7 == ec[l]) //Whipper
				hf.b(e, g + 64 + 2, "              STARSTRIKE", -1, 0), 
				hf.b(e, g + 64 + 2, "                        :" + lc[l] + "%", 0, -1),
				hf.b(e, g + 64 + 2, "  BULLET", -1, 0), 
				hf.b(e, g + 64 + 2, "        :+" + mc[l] / 5, 0, -1);

			else if (10 == ec[l]) //SUMMONER
				hf.b(e, g + 64 + 2, "              SUMMONS", -1, 0), //Summon cap
				hf.b(e, g + 64 + 2, "                     :" + "" + K(2 + mc[l] / 20, 2, summons.maxSummons), 0, -1);

			else if (11 == ec[l]) { //REAPER
				var soulChance, soulTier, soulBAT;
				soulChance = K(mc[l], 0, 80);
				soulTier = z(mc[l]/20) + 1;
				soulTier>=4 ? soulBAT = 2*lc[l] :
				soulTier==3 ? soulBAT = lc[l] :
				soulBAT = 0;
				hf.b(e, g + 64, "TIER " + soulTier + " WRAITH SOUL CHANCE", -1, 0); 
				hf.b(e, g + 64, "                         :" + soulChance + "%", 0, -1); 
				hf.b(e, g + 64 + 8, "                       AT", -1, 0);
				hf.b(e, g + 64 + 8, "                         :" + 10 * lc[l], 0, -1);
				hf.b(e, g + 64 + 16, "                      BAT", -1, 0);
				hf.b(e, g + 64 + 16, "                         :" + soulBAT, 0, -1);
			} else if (2 == ec[l]) //GLADIATOR
				hf.b(e, g + 64 + 2, "              GREATSLASH", -1, 0), 
				hf.b(e, g + 64 + 2, "                        :" + (mc[l] * 2) + "%", 0, -1);
			else if (1 == ec[l]) //BOXER
				hf.b(e, g + 64 + 2, "              COMBO", -1, 0), 
				hf.b(e, g + 64 + 2, "                   :" + (mc[l]/4 + 1), 0, -1);

		else if (8 == ec[l]) { //Angel
			var n = 0,
				n = 10 > mc[l] ? 0 + (mc[l] - 0) / 10 : 
				    30 > mc[l] ? 1 + (mc[l] - 10) / 20 : 
					60 > mc[l] ? 2 + (mc[l] - 30) / 30 : 
					100 > mc[l] ? 3 + (mc[l] - 60) / 40 : 
					4;
			hf.b(e, g + 64 + 2, "  ECHOES", -1, 0), 
			hf.b(e, g + 64 + 2, "        :" + lc[l] / 10, 0, -1);
			hf.b(e, g + 64 + 2, "              RING", -1, 0);
			hf.b(e, g + 64 + 2, "                   +" + ("" + n).substring(0, 5 > ("" + n).length ? ("" + n).length : 5), 0, -1)
		}
		D.b(e, g + 76, "LV  " + Mb[0], 16777215, 0);
		D.b(e, g + 76, "        SP " + ac[l], 16777215, 0);
		D.b(e, g + 88, "EXP " + cc + "(" + z(100 * (cc - k) / (c - k)) + "%)", 16777215, 0);
		D.b(e, g + 100, "$$$ " + dc, 16777215, 0);
		hf.b(e + 105, g + 100 + 2, "FP " + Nb[0], -1, 0);
		v.step[l] == Mg ? (k = ig(z(dc / 10), 10 * Mb[0]), b = "Revival $ " + k, D.b(e, g + 40, b, 8421504, 0), Wf(e, g + 40, 8 * b.length, 12) && ub && (k <= dc && Ef && 0 != p[0] + p[1] + p[2] + p[3] && (Ne(), p[l] += z(kc[l] / 4), dc -= k, v.set(l, z(v.a[l][0].x / 8), z(v.a[l][0].y / 8)), te()), D.b(e, g + 40, b, 16711680, 0))) : 
		0 < ac[l] && 
			(k = Ef, 
			Ne(), 
			Wf(e, g + 16, 8 * b.length + 16, 12) && ub ? (k && (gc[l]++, ac[l]--), D.b(e, g + 16, b, 16711680, 0)) :
			Wf(e, g + 28, 8 * d.length + 16, 12) && ub ? (k && (hc[l]++, ac[l]--), D.b(e, g + 28, d, 16711680, 0)) : 
			Wf(e, g + 40, 8 * r.length + 16, 12) && ub ? (k && (ic[l]++, ac[l]--), D.b(e, g + 40, r, 16711680, 0)) : 
			Wf(e, g + 52, 8 * m.length + 16, 12) && ub && (k && (jc[l]++, ac[l]--), D.b(e, g + 52, m, 16711680, 0)), 
			te(), 
			D.b(e + 8 * b.length, g + 16, " +", 16711680, 0), 
			D.b(e + 8 * d.length, g + 28, " +", 16711680, 0), 
			D.b(e + 8 * r.length, g + 40, " +", 16711680, 0), 
			D.b(e + 8 * m.length, g + 52, " +", 16711680, 0))
	} else if (m = q[l], 8 <= l && 11 >= l && (m = Dc[s + l - 8]), 12 <= l && 15 >= l && (m = Ec[s + l - 12]), hg(e, g + 0, u[m][Mc] + " " + (u[m][Nc] ? u[m][Nc] : ""), 16777215, 0, -1), 0 != m && m != Ic)
		if (b = w(m, Rc), 9 == b) 
			D.b(e, g + 16, "Compo Item", -1, 0), 
			hg(e, g + 32, u[m][jd], 16777215, 0, -1), 
			hg(e, g + 44, u[m][kd], 16777215, 0, -1),
			w(m, hd) >= compoPhysTr && w(m, hd) <= compoGlitchTr && //Transmutations
				(hf.b(e, g + 60, "THERE MAY BE OTHER DAMAGE", 0, -1), 
				hf.b(e, g + 68, "CHANGES DEPENDING ON THE", 0, -1), 
				hf.b(e, g + 76, "SPECIFIC TYPE CONVERSION.", 0, -1));
		else { //ELEMENT weapon text on the UI
			var typeCol, itemID = m;
			D.b(e, g + 16, "AT " + u[m][Tc] + "-" + u[m][Uc], 0xFFFFFF, 0);
			D.b(e, g + 28, "AGI " + u[m][Wc] + "-" + u[m][Xc], 0xFFFFFF, 0);
			D.b(e, g + 40, "RANGE " + u[m][Yc], 0xFFFFFF, 0);
			c = w(m, $c); //Type
			d = w(m, ad); //Type parameter
			k = ig(w(m, bd), 0); //MP/Price
			r = w(m, dd); //Min BAT
			m = w(m, ed); //Max BAT
			
			if (c < 10) { //Single-types
				//Jewels
				if (1 == c || 2 == c || 3 == c || 4 == c || 5 == c || c == 6 || c == 7) /*Ruby*/x(l, yd) && (r += y(l, t), m += y(l, id)), /*Sapphire*/x(l, Ad) && (r += y(l, t), m += y(l, id)), /*Topaz*/x(l, Cd) && (r += y(l, t), m += y(l, id)), /*Emerald*/x(l, Dd) && (r += y(l, t), m += y(l, id)), /*Aquamarine*/x(l, Bd) && (d += y(l, t)), /*Peridot*/x(l, Ed) && (d += y(l, t)), /*Diamond*/x(l, Fd) && (d += y(l, t)), /*Hematite*/x(l, compoHematite) && (d += z(d * y(l, t) / 100)), /*Carnelian*/x(l, compoCarnelian) && (d += y(l, t));
				switch (c) { //Determine type color
					case 0: typeCol = 0xAAAAAA; break;
					case 1: typeCol = 0xFF6A00; break;
					case 2: typeCol = 0x66CBFF; break;
					case 3: typeCol = 0xFFFF00; break;
					case 4: typeCol = 0x00FF00; break;
					case 5: typeCol = 0xB2E5FF; break;
					case 6: typeCol = 0x7300CC; break;
					case 7: typeCol = 0xA50000; break;
					case 8:
						typeCol = errorCol;
						if (Kh%5 == 0) {
							errorName = $g(12), 
							errorCol = 0x888888 & 0x042069 * errorName,
							e += errorName,
							g += errorName - 5,
							errorName = "000;kRRRRMsd;[TYPE];ArrayIndexOutOfBounds;.ranger;physicalfireicethunderpoisonfreezegravitydrain;undefined;42;_;NO;Hey there, did you know that TowerClimb is my favorite indie game? It's an obscure, tough-as-nails platformer roguelite, simply put a harder but more fair Spelunky, although there's a lot more to it than that.;F".split(";")[errorName];
						}
						break;
				}
				D.b(e, g + 56, "TYPE " + ("physical;fire;ice;thunder;poison;freeze;gravity;drain;"+errorName).split(";")[c], typeCol, 0);
				if (m != 0 || k != 0) {
					D.b(e, g + 68, "AT " + r + "-" + m, 0xFFFFFF, 0);
					6 == b ? D.b(e, g + 80, "$$ " + k, 0xFFFFFF, 0) : D.b(e, g + 80, "MP " + k, 0xFFFFFF, 0);
				} else { //No residue or MP attack. Descriptions.
					var desc1 = "", desc2 = "";
					switch (itemID) {
						case 115:
							desc1 = "Greatslash:";
							desc2 = "[CORRUPTED]";
							break;
						case 123:
							desc1 = "Wraith Soul:";
							desc2 = "[CORRUPTED]";
							break;
					}
					D.b(e, g + 68, "" + desc1, 0xFFFFFF, 0);
					D.b(e, g + 80, "" + desc2, 0xFFFFFF, 0);
				}
				if (d != 0) {
					1 == c ? D.b(e, g + 80, "        BURN " + (z(100 * (d / 10)) / 100) + "%", typeCol, 0) : //BURN
					2 == c ? D.b(e, g + 80, "        SLOW " + d + "%", typeCol, 0) : 
					3 == c ? D.b(e, g + 80, "        ARC " + d + "%", typeCol, 0) : //ARC
					4 == c ? D.b(e, g + 80, "        TIME " + (z(100 * (d / 60)) / 100) + "s", typeCol, 0) : 
					5 == c ? D.b(e, g + 80, "        TIME " + (z(100 * (d / 60)) / 100) + "s", typeCol, 0) : 
					6 == c ? D.b(e, g + 80, "        FORCE " + d, typeCol, 0) : 
					8 == c ? D.b(e, g + 80, "        " + "E     ;     T; F    ;   E  ;  F   ;    C ".split(";")[Kh%6] + d, typeCol, 0) : 
					7 == c && D.b(e, g + 80, "        CHANCE " + d + "%", typeCol, 0);
				} else if (c == 1) D.b(e, g + 80, "        EXPLOSION", typeCol, 0);
			} else /*if (c < 100)*/{ //Dual-types
				var typeName, primaryEffect, secondaryEffect;
				x(l, yd) && (r += y(l, t), m += y(l, id)); //Ruby
				x(l, Ad) && (r += y(l, t), m += y(l, id)); //Sapphire
				x(l, Cd) && (r += y(l, t), m += y(l, id)); //Topaz
				x(l, Dd) && (r += y(l, t), m += y(l, id)); //Emerald
				x(l, compoRnbw) && (d += y(l, t)); //Rainbow Jewel
				switch (z(c / 10)) { //Secondary type
					case 1: typeName = "pierce";				secondaryEffect = "RATE " + d / 10 +"%";	break;
					case 2: typeName = "slow";					secondaryEffect = "SLOW " + d + "%";		break;
					case 3: typeName = "arc";					secondaryEffect = "ARC " + d + "%";			break;
					case 4: typeName = "poison";				secondaryEffect = "POISON " + d / 60 + "s";	break;
					case 5: typeName = "freeze";				secondaryEffect = "FREEZE " + d / 60 + "s";	break;
					case 6: typeName = "gravity";				secondaryEffect = "FORCE " + d;				break;
					case 7: typeName = "drain";					secondaryEffect = "CHANCE " + d + "%";		break;
				} switch (c % 10) { //Primary type
					case 0: typeName = "physical/" + typeName;	typeCol = 0xAAAAAA;	primaryEffect = "";							break;
					case 1: typeName = "fire/" + typeName;		typeCol = 0xFF6A00;	primaryEffect = "BURN " + d / 10 +"%";		break;
					case 2: typeName = "ice/" + typeName;		typeCol = 0x66CBFF;	primaryEffect = "SLOW " + d + "%";			break;
					case 3: typeName = "thunder/" + typeName;	typeCol = 0xFFFF00;	primaryEffect = "ARC " + d + "%";			break;
					case 4: typeName = "poison/" + typeName;	typeCol = 0x00FF00;	primaryEffect = "POISON " + d / 60 + "s";	break;
					case 5: typeName = "freeze/" + typeName;	typeCol = 0xB2E5FF;	primaryEffect = "FREEZE " + d / 60 + "s";	break;
					case 6: typeName = "gravity/" + typeName;	typeCol = 0x7300CC;	primaryEffect = "FORCE " + d;				break;
					case 7: typeName = "drain/" + typeName;		typeCol = 0xA50000;	primaryEffect = "CHANCE " + d + "%";		break;
				}
				D.b(e, g + 56, "TYPE " + typeName, typeCol, 0);
				D.b(e, g + 68, "AT " + r + "-" + m, 0xFFFFFF, 0);
				b == 6 ? D.b(e, g + 80, "$$ " + k, 0xFFFFFF, 0) : D.b(e, g + 80, "MP " + k, 0xFFFFFF, 0);
				D.b(e + 75, g + 68, primaryEffect, typeCol, 0);
				D.b(e + 75, g + 80, secondaryEffect, typeCol, 0);
			} /*else { //Special types
				
			}*/
			V(e + 0, g + 96, 12, 12, 0);
			V(e + 75, g + 96, 12, 12, 0);
			dg = 2;
			eg(Ra, e + 0, g + 96, 12, 12, 12 * w(Dc[l], Pc), 0, 12, 12, w(Dc[l], Sc)); //Small compo icons in the corner
			eg(Ra, e + 75, g + 96, 12, 12, 12 * w(Ec[l], Pc), 0, 12, 12, w(Ec[l], Sc));
			dg = 0;
			hf.b(e + 16, g + 96 + 3, u[Dc[l]][Mc].substring(0, 8 < u[Dc[l]][Mc].length ? 8 : u[Dc[l]][Mc].length) + " " + u[Dc[l]][Nc], -1, 0); //Small compo names in the corner
			hf.b(e + 75 + 16, g + 96 + 3, u[Ec[l]][Mc].substring(0, 8 < u[Ec[l]][Mc].length ? 8 : u[Ec[l]][Mc].length) + " " + u[Ec[l]][Nc], -1, 0)
		}
	e = 192;
	g = 271;
	Gf(hf, e - 15, g + 0 + 8, "PLA  ", 0, 0, 0, 0, 0, 0, 0, 128, 5, 7);
	Gf(hf, e - 15, g + 0 + 16, "  YER", 0, 0, 0, 0, 0, 0, 0, 128, 5, 7);
	Gf(hf, e - 15, g + 28 + 8, "WEA  ", 0, 0, 0, 0, 0, 0, 0, 128, 5, 7);
	Gf(hf, e - 15, g + 28 + 16, "  PON", 0, 0, 0, 0, 0, 0, 0, 128, 5, 7);
	Gf(hf, e - 15, g + 56 + 12, "COMPO", 0, 0, 0, 0, 0, 0, 0, 128, 5, 7);
	Gf(hf, e - 15, g + 84 + 12, "COMPO", 0, 0, 0, 0, 0, 0, 0, 128, 5, 7);
	for (b = 0; 4 > b; b++) 
		V(e + 32 * b, g - 12, 24, 4, 0), 
		V(e + 32 * b, g - 12, z(24 * p[b] / kc[b]), 4, 10027008), 
		k = ig(w(q[s + b], bd), 1), 
		c = w(q[s + b], Rc), 
		4 != c && 5 != c && 6 != c && V(e + 32 * b, g - 6, z(23 * fc[b] / k) + 1, 2, 128), 
		c == 5 && V(e + 32 * b, g - 6, z(23 * priestAuraTimer[b] / (60 + 12 * mc[b])) + 1, 2, 32768),
		V(e + 32 * b, g + 0, 24, 24, 0), 
		V(e + 32 * b, g + 28, 24, 24, 0), 
		Ng(b, 0) && V(e + 32 * b, g + 56, 24, 24, 0), 
		Ng(b, 1) && V(e + 32 * b, g + 84, 24, 24, 0), 
		eg(Qa, e + 32 * b, g, 24, 24, 24 * w(q[s + b], Rc), 0, 24, 24, 16777215), 
		Yf(e + 32 * b, g, 24 * w(q[s + b], Rc), w(q[s + b], Sc)), 
		dg = 2, 
		eg(Ua, e + 32 * b, g + 28, 24, 24, 24 * w(q[s + b], Qc), 0, 24, 24, w(q[s + b], Sc)), 
		Ng(b, 0) && eg(Ua, e + 32 * b, g + 56, 24, 24, 24 * w(Dc[s + b], Qc), 0, 24, 24, w(Dc[s + b], Sc)), 
		Ng(b, 1) && eg(Ua, e + 32 * b, g + 84, 24, 24, 24 * w(Ec[s + b], Qc), 0, 24, 24, w(Ec[s + b], Sc)), 
		dg = 0, 
		u[q[s + b]][Nc] && hf.b(e + 32 * b + 19, g + 28 + 17, "" + u[q[s + b]][Nc], 16777215, -1), 
		u[Dc[s + b]][Nc] && Ng(b, 0) && hf.b(e + 32 * b + 19, g + 56 + 17, "" + u[Dc[s + b]][Nc], 16777215, -1), 
		u[Ec[s + b]][Nc] && Ng(b, 1) && hf.b(e + 32 * b + 19, g + 84 + 17, "" + u[Ec[s + b]][Nc], 16777215, -1);
	bg(e + 32 * tb - 1, g - 1, 26, 26, 16711680);
	e = 344;
	g = 271;
	D.b(e, g + -12, "ITEM", 16777215, 0);
	for (b = 0; 24 > b; b++) V(e + b % 6 * 28, g + 28 * z(b / 6), 24, 24, 0), dg = 2, eg(Ua, e + b % 6 * 28, g + 28 * z(b / 6), 24, 24, 24 * w(q[Fc + b], Qc), 0, 24, 24, w(q[Fc + b], Sc)), dg = 0, u[q[Fc + b]][Nc] && hf.b(e + b % 6 * 28 + 19, g + 28 * z(b / 6) + 17, "" + u[q[Fc + b]][Nc], 16777215, -1);
	b = -1;
	e = 192;
	g = 271;
	Wf(e - 4, g - 4, 128, 112) && ub && (c = z((cg - e + 4) / 32), d = z((fg - g + 4) / 28), b = 4 * d + c, Og(e + 32 * c, g + 28 * d, 24, 24, 8388608));
	e = 344;
	g = 271;
	Wf(e - 4, g - 4, 168, 112) && ub && (c = z((cg - e + 4) / 28), d = z((fg - g + 4) / 28), b = Fc + 6 * d + c, Og(e + 28 * c, g + 28 * d, 24, 24, 8388608));
	Ne();
	if (0 <= b && 3 >= b && 0 == q[Gc] && Ef) tb = b;
	else if (s <= b && b < s + 4 && Ef) {
		if (0 == q[Gc] || w(q[Gc], Rc) == ec[b - 4]) a = q[b], q[b] = q[Gc], q[Gc] = a, a = Dc[b], Dc[b] = Dc[Gc], Dc[Gc] = a, a = Ec[b], Ec[b] = Ec[Gc], Ec[Gc] = a, fc[b - 4] = 0, v.pa[b - 4] = 0
	} else 8 <= b && 11 >= b && Ef ? 9 == w(q[Gc], Rc) && Ng(b - 8, 0) && (Dc[s + b - 8] = q[Gc], q[Gc] = 0, Dc[Gc] = 0, Ec[Gc] = 0, fc[b - 8] = 0) : 12 <= b && 15 >= b && Ef ? 9 == w(q[Gc], Rc) && Ng(b - 12, 1) && (Ec[s + b - 12] = q[Gc], q[Gc] = 0, Dc[Gc] = 0, Ec[Gc] = 0, fc[b - 12] = 0) : Fc <= b && b < Gc && Ef ? 1 == Jb && 0 != q[b] ? (k = z(w(q[b], Oc) / 8), Ef && (pe.add(40, 200, 1, k, 0), q[b] = 0, Dc[b] = 0, Ec[b] = 0)) : (a = q[b], q[b] = q[Gc], q[Gc] = a, a = Dc[b], Dc[b] = Dc[Gc], Dc[Gc] = a, a = Ec[b], Ec[b] = Ec[Gc], Ec[Gc] = a) : -1 == b && 0 != q[Gc] && Ef && 256 > fg && 0 == a && (pe.add(v.a[tb][0].x, v.a[tb][0].y, q[Gc], Dc[Gc], Ec[Gc]), q[Gc] = 0, Dc[Gc] = 0, Ec[Gc] = 0);
	te();
	l = -1 == b ? tb : b;
	0 != q[Gc] && (dg = 2, J(Ua, cg, fg, 24, 24, 24 * w(q[Gc], Qc), 0, 24, 24, w(q[Gc], Sc)), dg = 0);
	1 == Jb && (c = K(cg, 56, ea - 56), d = K(fg - 8, 10, fa - 10), Fc <= b && b < Gc ? (k = z(w(q[b], Oc) / 8), yf(D, c, d, "" + k + "$ SELL", 16777215, 0)) : yf(D, c, d, "CLICK TO SELL", 16777215, 0))
}

function Ng(a, b) { //Slot restriction
	if (0 == q[Gc] || 9 != w(q[Gc], Rc)) return !0;
	if (0 == q[s + a] || 0 == b && Dc[s + a] == Ic || 1 == b && Ec[s + a] == Ic) return !1;
	var c = w(q[Gc], hd);
	if (c >= compoPhysTr && c <= compoGlitchTr) { //Allow only one transmutation
		if ((0 == b && compoPhysTr <= w(Ec[s + a], hd) && compoGlitchTr >= w(Ec[s + a], hd)) || 
			1 == b && compoPhysTr <= w(Dc[s + a], hd) && compoGlitchTr >= w(Dc[s + a], hd)) return false;
	}
	return 0 == b && c == w(Ec[s + a], hd) || 1 == b && c == w(Dc[s + a], hd) ? !1 : (Oe(c, w(q[s + a], Rc), w(q[s + a], $c), w(q[s + a], Vc)) || (w(q[s + a], Rc) == 10 && checkSummonerCompoRestr(c, w(q[s + a], hd)))) //SUMMONER Take species-specific compo restrictions into account
}

function Oe(a, b, c, d) { //Compo restriction
	if (a == ld || a == md || a == nd || a == od || a == pd) return !0;
	if (a == qd) {
		if (1 == b || 2 == b || 3 == b || 6 == b || 7 == b || 8 == b || 11 == b) return !0 //REAPER compo restrictions 11 == b
	} else if (a == rd) {
		if (1 == b || 2 == b || 3 == b || 6 == b || 7 == b || 8 == b || 11 == b) return !0
	} else {
		if (a == sd || a == td || a == ud) return !0;
		if (a == vd) {
			if (1 == b || 2 == b || 7 == b) return !0
		} else if (a == wd) {
			if (1 == b || 2 == b || 7 == b) return !0
		} else if (a == xd) {
			if (1 == b || 2 == b || 7 == b) return !0
		} else if (a == yd) {
			if (1 == c % 10) return !0
		} else if (a == zd) {
			if (1 == c) return !0
		} else if (a == Ad) {
			if (2 == c % 10) return !0
		} else if (a == Bd) {
			if (2 == c) return !0
		} else if (a == Cd) {
			if (3 == c % 10) return !0
		} else if (a == Dd) {
			if (4 == c % 10) return !0
		} else if (a == Ed) {
			if (4 == c) return !0
		} else if (a == Fd) {
			if (5 == c) return !0
		} else if (a == compoHematite) { //ELEMENT compo restriction
			if (c == 6) return true;
		} else if (a == compoCarnelian) {
			if (c == 7) return true;
		} else if (a == compoRnbw) {
			if (c > 9) return true;	
		} else if (a == compoPhysTr) {
			if (c != 0 && d >= 1) return true;
		} else if (a == compoFireTr) {
			if (c != 1 && d >= 1) return true;
		} else if (a == compoIceTr) {
			if (c != 2 && d >= 1) return true;
		} else if (a == compoThunTr) {
			if (c != 3 && d >= 1) return true;
		} else if (a == compoPoisTr) {
			if (c != 4 && d >= 1) return true;
		} else if (a == compoFrzTr) {
			if (c != 5 && d >= 1) return true;
		} else if (a == compoGravTr) {
			if (c != 6 && d >= 1) return true;
		} else if (a == compoDrainTr) {
			if (c != 7 && d >= 1) return true;
		} else if (a == compoGlitchTr) {
			if (c != 8 && d >= 1) return true;
		} else {
			if (a == Gd) return !0;
			if (a == compoBlademaster) {
				if (2 == b) return !0
			} else if (a == Id) {
				if (3 == b || 4 == b || 5 == b || 6 == b || 8 == b || 11 == b) return !0
			} else if (a == Jd) {
				if (3 == b || 4 == b || 6 == b) return !0
			} else if (a == Kd) {
				if (3 == b || 4 == b || 6 == b) return !0
			} else if (a == Ld) {
				if (2 <= d) return !0
			} else if (a == Md) {
				if (1 == b || 3 == b || 6 == b || 8 == b) return !0
			} else if (a == Zd) {
				if (1 == b || 3 == b || 4 == b || 6 == b || 7 == b) return !0
			} else if (a == Od) {
				if (1 == b || 2 == b || 3 == b || 6 == b || 7 == b || 8 == b || 11 == b) return !0
			} else if (a == Nd) {
				if (1 == b || 2 == b || 7 == b) return !0
			} else if (a == $d) {
				if (3 == b || 4 == b || 6 == b || 7 == b || 8 == b) return !0
			} else {
				if (a == Pd || a == Qd || a == Rd || a == Sd || a == Td || a == Ud || a == Vd || a == Wd || a == Xd) return !0;
				if (a == Yd) {
					if (1 == b || 7 == b) return !0
				} else {
					if (a == be) return !0;
					if (a == ce) {
						if (8 == b) return !0
					} else if (a == de || a == ee) return !0
				}
			}
		}
	}
	return !1
}
var Mg = 9,
	v = new Pg;

function Pg() { //Player
	var a, b;
	this.a = Array(8);
	for (a = 0; 8 > a; a++) this.a[a] = Array(21);
	this.c = Array(8);
	for (a = 0; 8 > a; a++) this.c[a] = Array(21);
	this.step = new Int32Array(8);
	this.count = new Int32Array(8);
	this.h = new Int32Array(8);
	this.g = new Int32Array(8);
	this.l = new Int32Array(8);
	this.qa = new Int32Array(8);
	this.pa = new Int32Array(8);
	this.Za = new Int32Array(8);
	this.v = -1;
	this.T = 0;
	this.search = new Int32Array(8);
	this.L = this.fb = 0;
	//ELEMENT status effects on player
	this.C = new Int32Array(8);
	this.X = new Int32Array(8);
	this.D = new Int32Array(8);
	this.H = new Int32Array(8);
	this.B = new Int32Array(8);
	this.gravityForcePl = new Int32Array(8);
	this.gravityTimePl = new Int32Array(8);
	this.O = Array(8);
	for (a = 0; 8 > a; a++) this.O[a] = new Int32Array(6);
	this.aa = Array(8);
	for (a = 0; 8 > a; a++) this.aa[a] = new Int32Array(6);
	this.ba = Array(8);
	for (a = 0; 8 > a; a++) this.ba[a] = new Int32Array(6);
	for (a = 0; 8 > a; a++)
		for (b = 0; 21 > b; b++) this.a[a][b] = new Qg;
	for (a = 0; 8 > a; a++)
		for (b = 0; 21 > b; b++) this.c[a][b] = new Qg
}
Pg.prototype.j = function() { //Reset
	this.v = -1;
	this.T = 0
};
Pg.prototype.set = function(a, b, c) { //Spawn
	b *= 8;
	c *= 8;
	for (var d = 0; 21 > d; d++) Rg(this.a[a][d], b + A(4), c + A(4)), this.c[a][d].set(this.a[a][d]);
	this.step[a] = ec[a];
	this.count[a] = 0;
	this.h[a] = 0;
	this.g[a] = -1;
	this.l[a] = 0;
	this.qa[a] = 0;
	this.pa[a] = 0;
	this.Za[a] = 0;
	this.search[a] = 0;
	//ELEMENT status effects on player
	this.C[a] = 0;
	this.X[a] = 0;
	this.D[a] = 0;
	this.H[a] = 0;
	this.gravityForcePl[a] = 0;
	this.gravityTimePl[a] = 0;
	for (d = this.B[a] = 0; 6 > d; d++) this.O[a][d] = 0, this.aa[a][d] = 0, this.ba[a][d] = 0
};
da.fff = Pg.prototype.kb;
Pg.prototype.kb = function(a, b) { //Movement
	var help, c = this.a[a][b],
		d = new Qg;
	d.q(c, this.c[a][b]);
	c.set(this.c[a][b]);
	var e = (Sg(d) >> 2) + 1;
	Tg(d, 1 / e);
	var g, k, r;
	k = K(c.x, 0, 511) >> 3;
	r = K(c.y, 0, 383) >> 3;
	k = I.e[r][k];
	9 == k && (Tg(d, 0.95), this.h[a] |= 2);
	var m = 0.5;
	8 == Me[I.w][nb][0] && (m = 1);
	for (var n = 0; n < e; n++) 
		g = c.y + d.y, 
		k = K(c.x, 0, 511) >> 3, 
		r = K(g, 0, 383) >> 3, 
		help = I.e[r+1][k], //1 tile lower
		k = I.e[r][k], 
		384 <= g || (0 <= k && 8 >= k ? (d.x *= m, d.y = -d.y, this.h[a] |= 1) : c.y = g),
		384 <= g || (0 <= help && 8 >= help) && (this.h[a] |= 4), //Attack even if a little above the ground
		g = c.x + d.x, 
		k = K(g, 0, 511) >> 3, 
		r = K(c.y, 0, 383) >> 3, 
		help = I.e[r+1][k], //1 tile lower
		k = I.e[r][k], 
		0 > g || 512 <= g || (0 <= k && 8 >= k ? (d.y *= m, d.x = -d.x, this.h[a] |= 1) : c.x = g),
		0 > g || 512 <= g || (0 <= help && 8 >= help) && (this.h[a] |= 4) //Attack even if a little above the ground
};
Pg.prototype.m = function(a, b, c, d, e) { //Locate player
	var g = 0.5 * (a + c),
		k = 1E3,
		r = -1;
	if (1 == this.fb) return r;
	for (var m = e + 4; e < m; e++) {
		this.search[e] = 0;
		var n = this.a[e][2];
		this.step[e] == Mg || n.x - 5 > c || n.x + 5 < a || n.y - 10 > d || n.y + 10 < b || (this.search[e] = 1, Kg(n.x - g) < k && (k = Kg(n.x - g), r = e))
	}
	return r
};
Pg.prototype.K = function(a, b, c, d, e, g, k, r, m, n) { //Take damage
	var summonCompoVal, secondaryType, F = -1;
	this.L = 0;
	if (b > 9) { //Dual-typed
		secondaryType = z(b / 10);
		b = b % 10;
	}
	if (secondaryType == 4) {
		this.K(a, secondaryType, c, d, e, g, k, r, m, n);
	} else if (secondaryType > 0) {
		this.K(a, secondaryType, c, 0, 0, g, k, r, m, n);
	}
	r *= 0.5;
	m *= 0.5;
	
	for (var H = n + 4; n < H; n++)
		if (this.step[n] != Mg && !(this.a[n][2].x - 5 > g + r || this.a[n][2].x + 5 < g - r || this.a[n][2].y - 10 > k + m || this.a[n][2].y + 10 < k - m)) {
			var F = -1,
				M = d + z(A(e - d + 1));
			this.qa[n] = 2;
			var E = 16711680;
			4 <= n && (F = 1, E = 12632256);
			x(s + n, Nd) && (y(s + n, t) > A(100)) && (this.l[n] = 0); //Berserk instant attack
			var ka = 0;
			//ELEMENT status effects on player and compos' effects on them
			//SUMMONER damage and status effect altering compos
			if (ec[n] == 10) {
				switch(b){
					case 1:
						summonCompoVal = getDefenseCompoValues(n, Pd, id); //Zombie's Card fire weakness
						M += z(M * summonCompoVal / 100);
						break;
					case 2:
						summonCompoVal = getDefenseCompoValues(n, Ud, t); //Ice Ward
						if (summonCompoVal > A(100)) ka = 1;
						if (ka == 0) {
							this.C[n] = 500;
							this.X[n] = c;
							summonCompoVal = getDefenseCompoValues(n, td, t); //Purple Crystal vs duration
							this.C[n] -= z(this.C[n] * summonCompoVal / 100);
						}
						break;
					case 4:
						summonCompoVal = getDefenseCompoValues(n, Vd, t); //Poison Ward
						if (summonCompoVal > A(100)) ka = 1;
						if (ka == 0) {
							this.D[n] = c;
							this.H[n] = M;
							summonCompoVal = getDefenseCompoValues(n, td, t); //Purple Crystal vs duration and damage
							this.D[n] -= z(this.D[n] * summonCompoVal / 100);
							this.H[n] -= z(this.H[n] * summonCompoVal / 100);
						}
						F = n;
						continue;
						break;
					case 5:
						summonCompoVal = getDefenseCompoValues(n, Wd, t); //Freeze Ward
						if (summonCompoVal > A(100)) ka = 1;
						if (ka == 0) {
							this.B[n] = c;
							summonCompoVal = getDefenseCompoValues(n, td, t); //Purple Crystal vs duration
							this.B[n] -= z(this.B[n] * summonCompoVal / 100);
						}
						break;
					case 6:
						summonCompoVal = getDefenseCompoValues(n, compoGravWard, t); //Gravity Ward
						if (summonCompoVal > A(100)) ka = 1;
						if (ka == 0) {
							this.gravityTimePl[n] = 250; //Duration
							this.gravityForcePl[n] = c; //Force
							summonCompoVal = getDefenseCompoValues(n, td, t); //Purple Crystal vs duration and force
							this.gravityTimePl[n] -= z(this.gravityTimePl[n] * summonCompoVal / 100);
							this.gravityForcePl[n] -= z(this.gravityForcePl[n] * summonCompoVal / 100);
						}
						break;
				}
			}
			else { //non-summoners
				1 == b && //Fire
					x(s + n, Pd) && (M += z(M * y(s + n, id) / 100));
				if (2 == b) //Ice, slow
					x(s + n, Ud) && A(100) < y(s + n, t) && (ka = 1), 
					0 == ka && 
						(this.C[n] = 500, 
						this.X[n] = c, 
						x(s + n, td) && (this.C[n] -= z(this.C[n] * y(s + n, t) / 100)));
				else if (4 == b) { //Poison
					x(s + n, Vd) && A(100) < y(s + n, t) && (ka = 1);
					0 == ka && 
						(this.D[n] = c, 
						this.H[n] = M, 
						x(s + n, td) && (this.D[n] -= z(this.D[n] * y(s + n, t) / 100), this.H[n] -= z(this.H[n] * y(s + n, t) / 100)));
					F = n;
					continue
				} else 5 == b && //Freeze
					(x(s + n, Wd) && A(100) < y(s + n, t) && (ka = 1), 
					0 == ka && 
						(this.B[n] = c, //NOTE: Changed from c/10
						x(s + n, td) && (this.B[n] -= z(this.B[n] * y(s + n, t) / 100))));
				if (b == 6) { //Gravity
					x(s + n, compoGravWard) && A(100) < y(s + n, t) && (ka = 1);
					if (ka == 0) { //Not resisted
						this.gravityTimePl[n] = 250; //Duration
						this.gravityForcePl[n] = c; //Force
						if (x(s + n, td)) (this.gravityTimePl[n] -= z(this.gravityTimePl[n] * y(s + n, t) / 100)); //Purple crystal vs gravity duration
					}
				}
			}
			if (b == 7){ //Drain (same for all classes)
				enemyDrain(M, c);
			}
			//0 == b && (M = ig(1, M - z(Bc[n] / 5))); //Defense aura GONE
			
			//SUMMONER defensive crystals
			if (ec[n] == 10) {
				if (b == 0) {
					summonCompoVal = getDefenseCompoValues(n, sd, t); //White Crystal
					M = ig(1, M - summonCompoVal);
				}
				else {
					summonCompoVal = getDefenseCompoValues(n, td, t); //Purple Crystal vs damage
					M -= z(M * summonCompoVal / 100);
				}
				summonCompoVal = getDefenseCompoValues(n, ud, t); //Black Crystal
				if (summonCompoVal > A(100)) {
					M = 0;
					this.qa[n] = 0;
					ne.add(this.a[n][0].x, this.a[n][0].y, F, M, 16744576);
				}
			}
			else { //Non-summoners
				x(s + n, sd) && 0 == b && (M = ig(1, M - y(s + n, t)));
				x(s + n, td) && 0 != b && (M -= z(M * y(s + n, t) / 100));
				x(s + n, ud) && A(100) < y(s + n, t) && (M = 0, this.qa[n] = 0, E = 16744576);
			}
			Ne();
			p[n] = K(p[n] - M, 0, kc[n]);
			te();
			2 > wc && M > 0 && ne.add(this.a[n][0].x, this.a[n][0].y, F, M, E);
			this.L += M;
			F = n;
			if (0 == a) break
		}
	return F
};
function enemyDrain(drainDamage, drainChance){ //Drain effect for enemies
	var target,
		heal = ig(1, z(drainDamage/10)); //Heal at least 1
	while (drainChance > 0){ //Drain can happen multiple times when chance > 100, e.g. 250% drain chance is 2 guaranteed drains and 50% chance for a 3rd
		target = $g(G.index); //Pick a random target for healing (temporary solution? since currently there's no "attacker" parameter for damage functions)
		if (drainChance > A(100) && G.r[target] > 0){
			G.r[target] = K(G.r[target] + heal, 0, B[G.id[target]][lg]); //Don't heal over max LP
			if ((wc & 1) == 0) ne.add(G.a[target][0].x, G.a[target][0].y, 1, heal, 0x00FF00);
		}
		drainChance -= 100;
	}
}
da.fff = Pg.prototype.jb;
Pg.prototype.jb = function() { //Held ranger
	var a = new Qg,
		b, c;
	if (-1 == this.v && 1 != ga) {
		if (Ef) {
			b = 20;
			a.x = cg - this.c[tb][0].x;
			a.y = fg - (this.c[tb][0].y - 8);
			c = Sg(a);
			20 > c && c < b && (0 != p[tb] || 0 != zc) && (b = c, this.v = tb, this.T = 0);
			for (var d = 0; 4 > d; d++)
				if (0 != p[d] || 0 != zc)
					for (var e = 0; 10 > e; e++) a.x = cg - this.c[d][e].x, a.y = fg - this.c[d][e].y, c = Sg(a), 20 > c && c < b && (b = c, this.v = d, this.T = e, tb = d)
		}
	} else Ug || (this.v = -1, this.T = 0)
};
Pg.prototype.p = function(a, b, c, d) { //Projectile
	var help, e = new Qg,
		g = a;
	8 > a && (g = q[s + a]);
	var k = w(g, 8) % 100,
		r = z(w(g, 8) / 100),
		m = w(g, 17),
		n = w(g, 18),
		F = w(g, Zc),
		H = w(g, 20),
		M = w(g, 21),
		E = w(g, 22),
		ka = w(g, 23),
		Ja = w(g, 24),
		Ea = w(g, 25),
		Ca = w(g, 26),
		Z = w(g, 27),
		X = w(g, 28),
		$ = w(g, 29),
		ob = w(g, 30),
		pb = w(g, 31),
		Xa = w(g, 32),
		ta = w(g, 33),
		ya = 0,
		rb = w(g, 9),
		ia = 8 > a ? oc[a] : w(g, Tc),
		ja = 8 > a ? pc[a] : w(g, Uc),
		za = w(g, Vc),
		bb = w(g, 13),
		ab = w(g, $c),
		pa = w(g, ad),
		Ya = w(g, cd),
		Bb = w(g, 42),
		Cb = w(g, 43),
		Sa = w(g, fd),
		Oa = w(g, 45),
		Ob = w(g, 46),
		Pb = w(g, 47),
		Qb = w(g, 48),
		Rb = w(g, 49),
		Sb = w(g, 50),
		Tb = w(g, 51),
		qb = w(g, 52),
		Ub = w(g, 53),
		Vb = w(g, 54),
		Wb = w(g, 55),
		Xb = w(g, 56),
		Yb = w(g, 57),
		Zb = w(g, 38),
		ba = w(g, dd),
		U = w(g, ed),
		sc = w(g, 41),
		gd = ab,
		Ta = pa;
	if (8 > a) { //ELEMENT Jewel effects on projectiles
		var Db = help = w(q[s + a], Rc);
		1 == Db || 2 == Db || 7 == Db || 11 == Db ? //REAPER Melee class
			(ia = w(q[s + a], dd), 
			ja = w(q[s + a], ed), 
			x(s + a, yd) && (ia += y(s + a, t), ja += y(s + a, id)), 
			x(s + a, zd) && (Z += y(s + a, t)), 
			x(s + a, Ad) && (ia += y(s + a, t), ja += y(s + a, id)), 
			x(s + a, Bd) && (pa += y(s + a, t)), 
			x(s + a, Cd) && (ia += y(s + a, t), ja += y(s + a, id)), 
			x(s + a, Dd) && (ia += y(s + a, t), ja += y(s + a, id)), 
			x(s + a, Ed) && (pa += y(s + a, t)), 
			x(s + a, Fd) && (pa += y(s + a, t)), 
			x(s + a, compoHematite) && (pa += z(pa * y(s + a, t) / 100)), 
			x(s + a, compoCarnelian) && (pa += y(s + a, t)), 
			ia += z(ia * Ac[a] / 100), 
			ja += z(ja * Ac[a] / 100), 
			7 == Db && (za += z(mc[a] / 5))) : 
		3 == Db ? 
			(-1 != g && (pa = ab = 0), 
			Ne(), 
			g = w(q[s + a], bd), 
			fc[a] = fc[a] + nc[a] + z(Cc[a] / 4) < g ? fc[a] + nc[a] + z(Cc[a] / 4) : g, 
			fc[a] == g && 0 < g ? fc[a] = 0 : Ya = 0, 
			te(), 
			x(s + a, yd) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, zd) && (qb += y(s + a, t)), 
			x(s + a, Ad) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, Bd) && (Ta += y(s + a, t)), 
			x(s + a, Cd) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, Dd) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, Ed) && (Ta += y(s + a, t)), 
			x(s + a, Fd) && (Ta += y(s + a, t)), 
			x(s + a, compoHematite) && (Ta += z(Ta * y(s + a, t) / 100)), 
			x(s + a, compoCarnelian) && (Ta += y(s + a, t)), 
			ba += z(ba * Ac[a] / 100), 
			U += z(U * Ac[a] / 100), 
			x(s + a, Jd) && (pb = 1), 
			(x(s + a, Jd) || x(s + a, $d)) && (ta += y(s + a, t)), 
			x(s + a, Md) && A(100) < y(s + a, t) && (rb = 1), 
			x(s + a, Od) && A(100) < y(s + a, t) && (ia += z(y(s + a, id) * ia / 100), ja += z(y(s + a, id) * ja / 100))) : 
		4 == Db || 5 == Db ? 
			(x(s + a, yd) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, zd) && (Z += y(s + a, t), qb += y(s + a, t)), 
			x(s + a, Ad) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, Bd) && (pa += y(s + a, t), Ta += y(s + a, t)), 
			x(s + a, Cd) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, Dd) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, Ed) && (pa += y(s + a, t), Ta += y(s + a, t)), 
			x(s + a, Fd) && (pa += y(s + a, t), Ta += y(s + a, t)), 
			x(s + a, compoHematite) && (pa += z(pa * y(s + a, t) / 100), Ta += z(Ta * y(s + a, t) / 100)), 
			x(s + a, compoCarnelian) && (pa += y(s + a, t), Ta += y(s + a, t)), 
			ba += z(ba * Ac[a] / 100), 
			U += z(U * Ac[a] / 100), 
			x(s + a, Jd) && (pb = 1), 
			(x(s + a, Jd) || x(s + a, $d)) && (ta += y(s + a, t))) : 
		6 == Db ? 
			(0 != Ya && U != 0 && (pa = ab = 0), //GUNNER Visual residue (0 BAT) doesn't cause main projectile type to be physical
			x(s + a, yd) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, zd) && (qb += y(s + a, t)), 
			x(s + a, Ad) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, Bd) && (Ta += y(s + a, t)), 
			x(s + a, Cd) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, Dd) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, Ed) && (Ta += y(s + a, t)), 
			x(s + a, Fd) && (Ta += y(s + a, t)), 
			x(s + a, compoHematite) && (Ta += z(Ta * y(s + a, t) / 100)), 
			x(s + a, compoCarnelian) && (Ta += y(s + a, t)), 
			ba += z(ba * Ac[a] / 100), 
			U += z(U * Ac[a] / 100), 
			x(s + a, Jd) && (pb = 1), 
			(x(s + a, Jd) || x(s + a, $d)) && (ta += y(s + a, t)), 
			x(s + a, Md) && A(100) < y(s + a, t) && (rb = 1), 
			x(s + a, Od) && A(100) < y(s + a, t) && (ia += z(y(s + a, id) * ia / 100), ja += z(y(s + a, id) * ja / 100))) : 
		8 == Db && 
			(ia = w(q[s + a], dd), 
			ja = w(q[s + a], ed), 
			x(s + a, yd) && (ia += y(s + a, t), ja += y(s + a, id)), 
			x(s + a, yd) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, zd) && (Z += y(s + a, t), qb += y(s + a, t)), 
			x(s + a, Ad) && (ia += y(s + a, t), ja += y(s + a, id)), 
			x(s + a, Ad) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, Bd) && (pa += y(s + a, t), Ta += y(s + a, t)), 
			x(s + a, Cd) && (ia += y(s + a, t), ja += y(s + a, id)), 
			x(s + a, Cd) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, Dd) && (ia += y(s + a, t), ja += y(s + a, id)), 
			x(s + a, Dd) && (ba += y(s + a, t), U += y(s + a, id)), 
			x(s + a, Ed) && (pa += y(s + a, t), Ta += y(s + a, t)), 
			x(s + a, Fd) && (pa += y(s + a, t), Ta += y(s + a, t)), 
			x(s + a, compoHematite) && (pa += z(pa * y(s + a, t) / 100), Ta += z(Ta * y(s + a, t) / 100)), 
			x(s + a, compoCarnelian) && (pa += y(s + a, t), Ta += y(s + a, t)), 
			ia += z(ia * Ac[a] / 100), 
			ja += z(ja * Ac[a] / 100), 
			ba += z(ba * Ac[a] / 100), 
			U += z(U * Ac[a] / 100));
		x(s + a, Ld) && (za += y(s + a, t) + z(za * y(s + a, id) / 100));
		(3 == Db || 4 == Db || 6 == Db) && x(s + a, Zd) && A(100) < y(s + a, t) && (ya = y(s + a, id));
		x(s + a, $d) && (Xa = 2);
		for (i = 0; i < 9; i++) { //Transmutations
			if (x(s + a, compoPhysTr + i)) {
				var trDmgRatio = typeConversion(gd, i);
				gd = ab = i;
				ia = ig(1, z(ia * trDmgRatio / 100));
				ja = ig(1, z(ja * trDmgRatio / 100));
				ba = ig(1, z(ba * trDmgRatio / 100));
				U = ig(1, z(U * trDmgRatio / 100));
				Ta = pa = y(s + a, id);
				switch (i) {
					case 0:
						ia += z(ia * y(s + a, id) / 100);
						ja += z(ja * y(s + a, id) / 100);
						ba += z(ba * y(s + a, id) / 100);
						U += z(U * y(s + a, id) / 100);
						Sa = F = 0xFF9C9485;
						break;
					case 1:
						Sa = F = 0xAAFF6000;
						break;
					case 2:
						Sa = F = 0xBB77BBFF;
						break;
					case 3:
						ja += ia - 1;
						ia = 1;
						U += ba - 1;
						ba = 1;
						Sa = F = 0xAAFFFF51;
						break;
					case 4:
						Sa = F = 0xAA00FF00;
						break;
					case 5:
						Sa = F = 0xBBDFFFFF;
						break;
					case 6:
						Sa = F = 0xEE7000DF;
						break;
					case 7:
						Sa = F = 0xBBB70000;
						break;
					case 8:
						Sa = F = 0x88000000 | $g(16) * 0x110000 | $g(16) * 0x1100 | $g(16) * 0x11;
						break;
				}
			}
		}
	}
	Db = 0;
	1 != ga ? 6 == k ? (g = G.a[d][0].x, d = G.a[d][0].y) : (g = G.a[d][G.n].x, d = G.a[d][G.n].y) : (Db = 1 - (d >> 2), g = this.a[d][2].x, d = this.a[d][2].y);
	if (0 != k)
		if (1 == k) 
			k = b + 10 * e.x, 
			a = c + 10 * e.y, 
			oe.add(Db, k, a, 0, 0, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, ta, ya, rb, ia, ja, ab, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, U, sc, gd, Ta);
		else if (2 == k) {
			e = g - b;
			e /= Kg(e);
			k = b + 10 * e;
			a = c;
			for (var bc = e * bb * 0.1, eb = 0; eb < za; eb++) 
				oe.add(Db, k, a, bc, 0, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, ta, ya, rb, ia, ja, ab, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, U, sc, gd, Ta)
	} else if (3 == k) {
		Rg(e, g - b, d - c);
		for (var xe = 0 < r ? r : 16, r = z(512 * Vg(e) / Wg), r = r - z((za - 1) * xe / 2), eb = 0; eb < za; eb++) {
			e.x = Xe[r & 511][0];
			e.y = -Xe[r & 511][1];
			k = b + 10 * e.x;
			a = c + 10 * e.y;
			var bc = e.x * bb * 0.1,
				kf = e.y * bb * 0.1;
			oe.add(Db, k, a, bc, kf, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, ta, ya, rb, ia, ja, ab, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, U, sc, gd, Ta);
			r += xe
		}
	} else if (4 == k)
		for (eb = 0; eb < za; eb++) {
			Rg(e, g - b, d - c);
			xe = 0 < r ? r : za + 4;
			if (1 < za) {
				var bc = z(A(512)),
					lf = A(4) * xe;
				e.x += Xe[bc][0] * lf;
				e.y += Xe[bc][1] * lf
			}
			k = b;
			a = c;
			bc = e.x / bb;
			kf = (e.y - 0.5 * bb * bb * $ * 0.01) / bb;
			oe.add(Db, k, a, bc, kf, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, ta, ya, rb, ia, ja, ab, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, U, sc, gd, Ta)
	} else if (5 == k)
		for (eb = 0; eb < za; eb++) 
			0 == r ? 
				(k = b + N(-40, 40), a = c + N(-60, 0)) : 
				(k = b + N(-10 * (r - 1), 10 * (r - 1)), 
			a = c + N(-60, -50)), 
			Rg(e, g - k, d - a), 
			Xg(e), 
			Tg(e, bb), 
			oe.add(Db, k, a, e.x, e.y, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, ta, ya, rb, ia, ja, ab, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, U, sc, gd, Ta);
	else if (6 == k)
		for (eb = 0; eb < za; eb++) 
			k = g + N(-bb, bb), 
			a = d + N(-bb, bb), 
			oe.add(Db, k, a, 0, 0, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, ta, ya, rb, ia, ja, ab, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, U, sc, gd, Ta);
	else if (7 == k || 10 == k) //REAPER makes the projectiles come from the scythe blade for the reaper
		for (help == 11 ? 
				(e.x = b - this.a[a][12].x, e.y = c - this.a[a][12].y) : //Reaper
				(e.x = b - this.a[a][5].x, e.y = c - this.a[a][5].y), //Not reaper (gladiator)
			10 == k && 0 < e.y && (e.y = -e.y), 
			help == 11 ? 
				(k = this.a[a][12].x + e.x, a = this.a[a][12].y + e.y) : //Reaper
				(k = this.a[a][5].x + 0.5 * e.x, a = this.a[a][5].y + 0.5 * e.y), //Not reaper (gladiator)
			Xg(e), 
			Tg(e, 0.1 * bb), 
			eb = 0; eb < za; eb++) 
			oe.add(Db, k, a, e.x, e.y, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, ta, ya, rb, ia, ja, ab, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, U, sc, gd, Ta);
	else if (12 == k)
		for (e = b - this.a[a][0].x, e /= Kg(e), k = this.a[a][0].x, a = this.a[a][0].y, bc = e * bb * 0.1, eb = 0; eb < za; eb++) 
			oe.add(Db, k, a, bc, 0, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, ta, ya, rb, ia, ja, ab, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, U, sc, gd, Ta);
	else if (8 == k)
		for (eb = 0; eb < za; eb++) 
			k = 0 == r ? 
				g + N(-40, 40) : 
				g + N(-10 * (r - 1), 
			10 * (r - 1)), 
			a = d + N(-30, -60), 
			oe.add(Db, k, a, 0, 0, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, ta, ya, rb, ia, ja, ab, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, U, sc, gd, Ta);
	else if (9 == k)
		for (0 == r ? 
				(k = g, a = d) : 
				(k = b, a = c), 
			b = z(512 / za), 
			bc = z(A(b)), 
			eb = 0; eb < za; eb++) 
				e.x = Xe[bc][0] * bb, 
				e.y = Xe[bc][1] * bb, 
				oe.add(Db, k, a, e.x, e.y, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, ta, ya, rb, ia, ja, ab, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, U, sc, gd, Ta), bc += b;
	else if (11 == k)
		for (Rg(e, g - b, d - c), lf = Xg(e), xe = 0 < r ? r : 0, eb = 0; eb < za; eb++) 
			bc = N(-xe, xe), 
			k = b + e.x * lf / 2 + e.y * bc, 
			a = c + e.y * lf / 2 - e.x * bc, 
			bc = bb * (eb + 1) / za * e.x, 
			kf = bb * (eb + 1) / za * e.y, 
			oe.add(Db, k, a, bc, kf, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, ta, ya, rb, ia, ja, ab, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, U, sc, gd, Ta)
};

function typeConversion(fromType, toType) { //Damage modifier for type conversions
	var dmgMod = [10, 4, 10, 9, 1, 10, 10, 10, 8];
	return 100 * dmgMod[toType%10] / dmgMod[fromType%10];
}

function Yg(a, b) { //Walk
	if (0 != uc[b] || 1 == ga)
		if (0 < a.Za[b]) a.Za[b]--;
		else if (!(20 > z(100 * p[b] / kc[b]) && 1 != ga && 0 == vc)) {
		var c = 0.5 * (a.a[b][9].x + a.a[b][10].x),
			d = 0.5 * (a.a[b][9].y + a.a[b][10].y),
			e = tc[b],
			g;
		if (ec[b] == 10){ //SUMMONER range of sight determined by longest-range summon
			e = 0;
			for (i=0; i<swarm[b]; i++){
				if (e < summons.range[b][i] && summons.species[b][i] != 9){
					e = summons.range[b][i];
				}
			}
		}
		g = 1 != ga ? G.m(c - 200 - e, d - 20 - e, c + 200 + e, d + 100 + e) : v.m(c - 600, d - 300, c + 600, d + 300, 1 - (b >> 2) << 2); - 1 != g && (a.Za[b] = 15, e = 0.6, c < (1 != ga ? G.a[g][G.n].x : a.a[g][2].x) ? (c = z(K(c + 14, 0, 511) / 8), d = z(K(d - 6, 8, 383) / 8), 0 <= I.e[d][c] && 8 >= I.e[d][c] && (e = 2), 0 <= I.e[d - 1][c] && 8 >= I.e[d - 1][c] && (e = 4), a.a[b][9].x < a.a[b][10].x ? (a.a[b][7].x += 4, a.a[b][7].y -= 3 * e) : (a.a[b][8].x += 4, a.a[b][8].y -= 3 * e)) : (c = z(K(c - 14, 0, 511) / 8), d = z(K(d - 6, 8, 383) / 8), 0 <= I.e[d][c] && 8 >= I.e[d][c] && (e = 2), 0 <= I.e[d - 1][c] && 8 >= I.e[d - 1][c] && (e = 4), a.a[b][9].x > a.a[b][10].x ? (a.a[b][7].x -= 4, a.a[b][7].y -= 3 * e) : (a.a[b][8].x -= 4, a.a[b][8].y -= 3 * e)))
	}
}

function Zg(a, b) { //Swim
	if (0 != uc[b] && !(20 > z(100 * p[b] / kc[b]) && 0 == vc)) {
		var c = 0.5 * (a.a[b][9].x + a.a[b][10].x),
			d = 0.5 * (a.a[b][9].y + a.a[b][10].y),
			e = tc[b];
			if (ec[b] == 10){ //SUMMONER range of sight determined by longest-range summon
			e = 0;
			for (i=0; i<swarm[b]; i++){
				if (e < summons.range[b][i] && summons.species[b][i] != 9){
					e = summons.range[b][i];
				}
			}
		}
		e = 1 != ga ? G.m(c - 200 - e, d - 100 - e, c + 200 + e, d + 100 + e) : v.m(c - 600, d - 300, c + 600, d + 300, 1 - (b >> 2) << 2); - 1 != e && 9 == I.e[z(K(d, 8, 383) / 8)][z(K(c, 0, 511) / 8)] && (c < (1 != ga ? G.a[e][G.n].x : a.a[e][2].x) ? (a.a[b][0].x += 0.25, a.a[b][1].x += 0.25) : (a.a[b][0].x -= 0.25, a.a[b][1].x -= 0.25), d < (1 != ga ? G.a[e][G.n].y : a.a[e][2].y) ? (a.a[b][0].y += 0.25, a.a[b][1].y += 0.25) : (a.a[b][0].y -= 0.25, a.a[b][1].y -= 0.25), a.a[b][0].x += N(-0.25, 0.25), a.a[b][0].y += N(-0.25, 0.25), a.a[b][1].x += N(-0.25, 0.25), a.a[b][1].y += N(-0.25, 0.25))
	}
}
da.fff = Pg.prototype.move;
Pg.prototype.move = function() { //Main
	var a, b, c;
	this.jb();
	var d = 1 != ga ? 4 : 8;
	for (a = 0; a < d; a++) {
		//if (x(a, natureArtifact))
		//ELEMENT Status effects
		0 < this.D[a] && 0 < p[a] && (this.D[a]--, Ne(), p[a] = ig(p[a] - this.H[a], 0), te()); //Poison
		if (0 < this.B[a] && 0 < p[a]) this.B[a]--; //Freeze
		else {
			if (0 < this.C[a] && 0 < p[a] && (this.C[a]--, A(100) < this.X[a])) continue; //Slow
			if (this.gravityTimePl[a] > 0 && p[a] > 0){ //Gravity
				var xTile, yTile;
				this.gravityTimePl[a]--;
				for (i=0; i<8; i++){
					xTile = z(this.a[a][i].x/8);
					yTile = K(z(this.a[a][i].y/8), 0, 30);
					if (I.e[yTile+1][xTile] == -1 || I.e[yTile+1][xTile] == 9){ //If not on the ground
						if (this.a[a][i].y >= 0 && this.a[a][i].y <= 256) //Within level bounds
							this.a[a][i].y += this.gravityForcePl[a]/10; //Dragged down
					}
				}
			}
			0 != p[a] && (this.step[a] = 0 == q[s + a] ? 0 : ec[a]);
			if ((16 != h && nb != Me[h].length - 1 || 0 == G.index) && 0 < (this.h[a] & 1) && 0 != p[a]) { //Superboss requires kill to move on
				b = (this.a[a][9].x + this.a[a][10].x) / 2;
				c = (this.a[a][9].y + this.a[a][10].y) / 2;
				var e = I.I[63];
				7 == Me[h][nb][1] && (e = I.o[63]);
				500 < b && 10 > Kg(8 * e - c) && (sb = nb != Me[h].length - 1 ? 1 : 2)
			}
			this.count[a]++;
			if (0 == p[a])
				for (b = 0; 11 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
			else if (2 == this.h[a])
				for (b = 0; 11 > b; b++) W(this.a[a][b], this.c[a][b], 0.01, 0.99);
			else if (10 > this.count[a]) W(this.a[a][0], this.c[a][0], -0.2, 0.99), W(this.a[a][1], this.c[a][1], 0, 0.99), W(this.a[a][2], this.c[a][2], -0.1, 0.99), W(this.a[a][3], this.c[a][3], 0, 0.99), W(this.a[a][4], this.c[a][4], 0, 0.99), W(this.a[a][5], this.c[a][5], 0, 0.99), W(this.a[a][6], this.c[a][6], 0, 0.99), W(this.a[a][7], this.c[a][7], 0, 0.99), W(this.a[a][8], this.c[a][8], 0, 0.99), W(this.a[a][9], this.c[a][9], 0.3, 0.99), W(this.a[a][10], this.c[a][10], 0.3, 0.99);
			else
				for (b = 0; 11 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
			if (0 == p[a] && this.step[a] != Mg) {
				this.step[a] = Mg;
				for (b = 0; 11 > b; b++) this.a[a][b].x += N(-2, 2), this.a[a][b].y += N(-1, -3);
				if (1 == ga)
					for (e = 1 - (a >> 2) << 2, b = 0; 4 > b; b++) x(s + e + b, Xd) && A(100) < y(s + e + b, t) && (c = v.m(this.a[a][0].x - 600, this.a[a][0].y - 300, this.a[a][0].x + 600, this.a[a][0].y + 300, a >> 2 << 2), -1 != c && v.p(y(s + e + b, id), this.a[a][0].x, this.a[a][0].y, c))
			}
			this.v == a && 1 != ga && (this.a[this.v][this.T].x += (cg - this.a[this.v][this.T].x) * (0 == p[a] ? 0.04 : 0.2), this.a[this.v][this.T].y += (fg - this.a[this.v][this.T].y) * (0 == p[a] ? 0.04 : 0.2));
			0 == this.step[a] || 
			1 == this.step[a] ? this.sa(a) : 
			2 == this.step[a] ? this.ta(a) : 
			3 == this.step[a] ? this.ua(a) : 
			4 == this.step[a] ? this.ma(a) : 
			5 == this.step[a] ? this.na(a) : 
			6 == this.step[a] ? this.va(a) : 
			7 == this.step[a] ? this.wa(a) : 
			8 == this.step[a] ? this.xa(a) : 
			10 == this.step[a] ? this.summoner(a) : //SUMMONER
			11 == this.step[a] ? this.wraith(a) : //REAPER
			this.step[a] == Mg && (Y(this.a[a][1], this.a[a][2], 3.6, 0.5, 0.5), Y(this.a[a][3], this.a[a][5], 4.8, 0.5, 0.5), Y(this.a[a][4], this.a[a][6], 4.8, 0.5, 0.5), Y(this.a[a][7], this.a[a][9], 4.8, 0.5, 0.5), Y(this.a[a][8], this.a[a][10], 4.8, 0.5, 0.5));
			0 < (this.h[a] & 1) && (this.count[a] = 0);
			for (b = this.h[a] = 0; 11 > b; b++) this.kb(a, b)
		}
	}
};
da.fff = Pg.prototype.sa; //Boxer
Pg.prototype.sa = function(a) {
	var combo, b, c, d = new Qg,
		e = 1 - (a >> 2) << 2;
	b = oc[a];
	var g = pc[a],
		k = rc[a] - $g(6); //AGI
	c = tc[a];
	combo = boxerCombo[a];
	if (this.v != a && 0 < this.l[a]) this.l[a]--; //Allow reload reduction even when airborne (because of the kick move)
	if (0 != this.h[a] && 0 != this.step[a] && this.v != a) {
		var r = 0.5 * (this.a[a][9].x + this.a[a][10].x),
			m = 0.5 * (this.a[a][9].y + this.a[a][10].y);
		c = 1 != ga ? G.m(r - c, m - c, r + c, m) : v.m(r - c, m - c, r + c, m, e);
		if (0 == this.l[a] && -1 != c) {
			boxerATmodifier[a] *= 1.1; //BOXER combo
			if (combo == z(mc[a]/4)) boxerATmodifier[a] = 1;
			if (combo > 0) {
				k = qc[a];
				boxerCombo[a]--;
			} else {
				boxerCombo[a] = z(mc[a]/4);
			}
			this.l[a] = k;
			if (z(mc[a]/4) < 2 || boxerCombo[a] != 0) {
				r < (1 != ga ? G.a[c][G.n].x : this.a[c][2].x) ? 
					this.a[a][5].x < this.a[a][6].x ? 
						(this.a[a][5].x += 4, this.a[a][4].x -= 4, this.a[a][2].y += 1,this.g[a] = 5) : 
						(this.a[a][6].x += 4, this.a[a][3].x -= 4, this.a[a][2].y += 1, this.g[a] = 6) : 
					this.a[a][5].x > this.a[a][6].x ? 
						(this.a[a][5].x -= 4, this.a[a][4].x += 4, this.a[a][2].y += 1, this.g[a] = 5) : 
						(this.a[a][6].x -= 4, this.a[a][3].x += 4, this.a[a][2].y += 1, this.g[a] = 6);
			} else { //Last combo hit is a kick (if combo is 3 or bigger)
				if (r < G.a[c][G.n].x) {
					this.a[a][9].x += 5;
					this.a[a][9].y -= 4;
					this.a[a][2].x -= 5;
					this.g[a] = 9;
				}
				else {
					this.a[a][10].x -= 5;
					this.a[a][10].y -= 4;
					this.a[a][2].x += 5;
					this.g[a] = 10;
				}
				this.a[a][2].y += 4;
			}
			Ne();
			k = w(q[s + a], bd);
			fc[a] = fc[a] + nc[a] + z(Cc[a] / 4) < k ? fc[a] + nc[a] + z(Cc[a] / 4) : k;
			if (fc[a] == k && 0 < k || -1 == k) fc[a] = 0, this.p(a, this.a[a][this.g[a]].x, this.a[a][this.g[a]].y, c);
			x(s + a, be) && (k = y(s + a, t), p[a] = K(p[a] + k, 0, kc[a]), ne.add(this.a[a][0].x, this.a[a][0].y, 0, k, 65280));
			te()
		} -1 == c && Yg(this, a);
		Zg(this, a)
	}
	if (-1 != this.g[a] && 0 != this.step[a] && this.v != a && 
		(c = w(q[s + a], 9), //Splash
		x(s + a, Md) && A(100) < y(s + a, t) && (c = 1), //Expl card
		x(s + a, Od) && A(100) < y(s + a, t) && (b += z(y(s + a, id) * b / 100), g += z(y(s + a, id) * g / 100)), //Crit
		b = z(b * boxerATmodifier[a]),
		g = z(g * boxerATmodifier[a]),
		k = 12, 
		r = 8, 
		x(s + a, Yd) && (k += z(12 * y(s + a, t) / 100), r += z(8 * y(s + a, t) / 100)), //Big
		e = 1 != ga ? 
			G.K(c, 0, 0, b, g, this.a[a][this.g[a]].x, this.a[a][this.g[a]].y, k, r) : 
			v.K(c, 0, 0, b, g, this.a[a][this.g[a]].x, this.a[a][this.g[a]].y, k, r, e), -1 != e)) {
				this.g[a] = -1;
				x(s + a, vd) && (k = ig(1, z(this.L * y(s + a, t) / 100)), Ne(), p[a] = K(p[a] + k, 0, kc[a]), te(), ne.add(this.a[a][0].x, this.a[a][0].y, 0, k, 65280));
				x(s + a, wd) && 0 == ga && A(100) < y(s + a, t) && pe.add(this.a[a][0].x, this.a[a][0].y, 2, 0, 0);
				if (x(s + a, xd) && 0 == ga && A(100) < y(s + a, t)) {
					g = 100;
					for (b = 0; 4 > b; b++) x(s + b, Sd) && (g += y(s + b, t));
					pe.add(this.a[a][0].x, this.a[a][0].y, 1, z(this.L * g / 100), 0)
				}
				x(s + a, Zd) && A(100) < y(s + a, t) && (b = y(s + a, id), 1 != ga ? d.q(G.a[e][0], this.a[a][1]) : d.q(v.a[e][1], this.a[a][1]), Xg(d), Tg(d, 0.2 * b), 1 != ga ? Tg(d, ah[B[G.id[e]][bh]] / B[G.id[e]][ch]) : Tg(d, 0.1), 1 != ga ? G.c[e][0].sub(d) : v.c[e][0].sub(d))
			}
	Y(this.a[a][0], this.a[a][1], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][2], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][3], 4.8, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][4], 4.8, 0.5, 0.5);
	Y(this.a[a][3], this.a[a][5], 4.8, 0.5, 0.5);
	Y(this.a[a][4], this.a[a][6], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][7], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][8], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][9], 4.8, 0.5, 0.5);
	Y(this.a[a][8], this.a[a][10], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][8], 6, 0.1, 0.1)
};
da.fff = Pg.prototype.ta; //Gladiator
Pg.prototype.ta = function(a) {
	var b, c, d = new Qg,
		e = 1 - (a >> 2) << 2;
	b = oc[a];
	var g = pc[a],
		k = qc[a] + $g(rc[a] - qc[a] + 1),
		r = tc[a];
	if (0 != this.h[a] && this.v != a) {
		0 < this.l[a] && this.l[a]--;
		var m = 0.5 * (this.a[a][9].x + this.a[a][10].x),
			n = 0.5 * (this.a[a][9].y + this.a[a][10].y);
		c = 1 != ga ? G.m(m - r, n - r, m + r, n) : v.m(m - r, n - r, m + r, n, e);
		0 == this.l[a] && -1 != c && 
			(this.l[a] = k, 
			m < (1 != ga ? G.a[c][G.n].x : this.a[c][2].x) ? 
				(this.a[a][5].x += 3, this.a[a][5].y += 0.2 * (n - 2 - this.a[a][5].y), this.a[a][6].x = this.a[a][5].x - 2, this.a[a][6].y = this.a[a][5].y, this.a[a][1].x -= 3) : 
				(this.a[a][5].x -= 3, this.a[a][5].y += 0.2 * (n - 2 - this.a[a][5].y), this.a[a][6].x = this.a[a][5].x + 2, this.a[a][6].y = this.a[a][5].y, this.a[a][1].x += 3), 
			this.g[a] = 5, 
			Ne(), 
			k = w(q[s + a], bd), 
			fc[a] = fc[a] + nc[a] + z(Cc[a] / 4) < k ? fc[a] + nc[a] + z(Cc[a] / 4) : k, 
			fc[a] == k && 0 < k && (fc[a] = 0, this.pa[a] = w(q[s + a], 41)), 
			x(s + a, be) && (k = y(s + a, t), p[a] = K(p[a] + k, 0, kc[a]), ne.add(this.a[a][0].x, this.a[a][0].y, 0, k, 65280)), 
			te()); 
		-1 == c && Yg(this, a);
		Zg(this, a)
	}
	if (-1 != this.g[a] && 
		(x(s + a, Od) && A(100) < y(s + a, t) && (b += z(y(s + a, id) * b / 100), g += z(y(s + a, id) * g / 100)), //Critical
		d.q(this.a[a][5], this.a[a][6]), 
		Xg(d), 
		Tg(d, r), 
		c = this.a[a][6].x + d.x / 2, //Center of the sword
		k = this.a[a][6].y + d.y / 2, 
		-1 != (1 != ga ? G.K(1, 0, 0, b, g, c, k, Kg(d.x), Kg(d.y)) : v.K(1, 0, 0, b, g, c, k, Kg(d.x), Kg(d.y), e)) && //Attack hits
			(this.gladiatorGreatslash(a, c, k, d, b, g), //GLADIATOR Greatslash
			this.g[a] = -1, 
			x(s + a, vd) && (k = ig(1, z(this.L * y(s + a, t) / 100)), //Vampire
				Ne(), 
				p[a] = K(p[a] + k, 0, kc[a]), 
				te(), 
				ne.add(this.a[a][0].x, this.a[a][0].y, 0, k, 65280)), 
			x(s + a, wd) && 0 == ga && A(100) < y(s + a, t) && pe.add(this.a[a][0].x, this.a[a][0].y, 2, 0, 0), //Onigiri
			x(s + a, xd) && 0 == ga && A(100) < y(s + a, t)))) { //Gold rush
				g = 100;
				for (b = 0; 4 > b; b++) x(s + b, Sd) && (g += y(s + b, t));
				pe.add(this.a[a][0].x, this.a[a][0].y, 1, z(this.L * g / 100), 0)
			}
	Y(this.a[a][0], this.a[a][1], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][2], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][3], 4.8, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][4], 4.8, 0.5, 0.5);
	Y(this.a[a][3], this.a[a][5], 4.8, 0.5, 0.5);
	Y(this.a[a][4], this.a[a][6], 4.8, 0.5, 0.5);
	Y(this.a[a][3], this.a[a][4], 4.8, 0.01, 0.01);
	Y(this.a[a][5], this.a[a][6], 2.4, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][7], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][8], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][9], 4.8, 0.5, 0.5);
	Y(this.a[a][8], this.a[a][10], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][8], 6, 0.1, 0.1);
	0 < this.pa[a] && (this.pa[a]--, d.q(this.a[a][5], this.a[a][6]), Xg(d), Tg(d, r), d.add(this.a[a][6]), 1 != ga ? this.p(a, d.x, d.y, 0) : this.p(a, d.x, d.y, e))
};
Pg.prototype.gladiatorGreatslash = function(a, xCoord, yCoord, dir, minAT, maxAT) { //GLADIATOR
	if (2 * mc[a] > A(100)) {
		var sizeMod = tc[a] / 30, 
			slashType = 0, 
			slashTypeParam = 0, 
			slashCol = 0x88000000 | w(q[s + a], Sc),
			slashResMode = 0,
			slashResBullet = 0;
		if (x(s + a, compoBlademaster)) {
			slashResMode = 9;
			slashResBullet = y(s + a, id);
		}
		switch (q[s + a]) {
			case 115:
				slashType = 8;
				slashTypeParam = 50;
				slashCol = 0x88000000 | $g(16) * 0x110000 | $g(16) * 0x1100 | $g(16) * 0x11;
				break;
		}
		oe.add(
			0, //class_ID
			xCoord, //x_pos
			yCoord, //y_pos
			dir.x, //Xspd
			dir.y, //Yspd
			1, //orient
			35, //img
			slashCol, //color
			1, //transp
			z(sizeMod * 60), //width
			z(sizeMod * 52), //height
			z(sizeMod * 40), //box_width
			z(sizeMod * 40), //box_height
			5, //appear_delay
			5, //solid_delay
			10, //lifespan
			10, //disp_eff
			0, //grav
			10, //accel
			1, //pierce
			0, //bounce
			0, //homing
			0, //knockback
			1, //splash
			minAT, //AT_Min
			maxAT, //AT_Max
			slashType, //type
			slashTypeParam, //type_param
			slashResMode, //res_mode
			0, //res_orient
			30, //res_img
			0xAAA5FFE8, //Res_Color
			1, //res_transp
			32, //res_width
			32, //res_height
			20, //res_box_width
			20, //res_box_height
			20, //res_appear_delay
			0, //res_solid_delay
			120, //Res_Lifespan
			10, //res_fade_time
			0, //res_grav
			105, //res_accel
			1, //res_pierce
			0, //res_bounce
			0, //res_splash
			minAT, //res_ATmin
			maxAT, //res_ATmax
			slashResBullet, //res_bullet (MORE W/ HIGHER LV COMPO)
			10, //res_type
			70); //res_type_param
	}
}
da.fff = Pg.prototype.ua; //Sniper
Pg.prototype.ua = function(a) {
	var b;
	b = 1 - (a >> 2) << 2;
	var c = qc[a] + $g(rc[a] - qc[a] + 1),
		d = tc[a],
		e = 0.5 * (this.a[a][9].x + this.a[a][10].x),
		g = 0.5 * (this.a[a][9].y + this.a[a][10].y);
	b = 1 != ga ? G.m(e - d, g - d, e + d, g + d) : v.m(e - d, g - d, e + d, g + d, b); - 1 != b && (e < (1 != ga ? G.a[b][G.n].x : this.a[b][2].x) ? (this.a[a][6].x += 0.2, this.a[a][6].y -= 0.2, this.a[a][5].x -= 0.2) : (this.a[a][6].x -= 0.2, this.a[a][6].y -= 0.2, this.a[a][5].x += 0.2), this.a[a][5].y += 0.2);
	0 != this.h[a] && this.v != a && (0 < this.l[a] && this.l[a]--, 0 == this.l[a] && (-1 != b && (this.l[a] = c, Y(this.a[a][5], this.a[a][6], 2, 0.2, 0.2), this.g[a] = 6), -1 != this.g[a] && (this.p(a, this.a[a][6].x, this.a[a][6].y, b), this.g[a] = -1, x(s + a, be) && (c = y(s + a, t), Ne(), p[a] = K(p[a] + c, 0, kc[a]), te(), ne.add(this.a[a][0].x, this.a[a][0].y, 0, c, 65280)))), -1 == b && (Yg(this, a), Zg(this, a)));
	Y(this.a[a][0], this.a[a][1], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][2], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][3], 4.8, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][4], 4.8, 0.5, 0.5);
	Y(this.a[a][3], this.a[a][5], 4.8, 0.5, 0.5);
	Y(this.a[a][4], this.a[a][6], 4.8, 0.5, 0.5);
	Y(this.a[a][5], this.a[a][6], 9.6, 0.02, 0.02);
	Y(this.a[a][2], this.a[a][7], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][8], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][9], 4.8, 0.5, 0.5);
	Y(this.a[a][8], this.a[a][10], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][8], 6, 0.1, 0.1)
};
da.fff = Pg.prototype.ma; //Magician
Pg.prototype.ma = function(a) {
	var b;
	b = 1 - (a >> 2) << 2;
	var c = qc[a] + $g(rc[a] - qc[a] + 1),
		d = tc[a],
		e = 0.5 * (this.a[a][9].x + this.a[a][10].x),
		g = 0.5 * (this.a[a][9].y + this.a[a][10].y);
	b = 1 != ga ? G.m(e - d, g - d, e + d, g + d) : v.m(e - d, g - d, e + d, g + d, b); - 1 != b && (e < (1 != ga ? G.a[b][G.n].x : this.a[b][2].x) ? (this.a[a][5].x += 0.1, this.a[a][6].x += 0.1, this.a[a][1].x -= 0.2) : (this.a[a][5].x -= 0.1, this.a[a][6].x -= 0.1, this.a[a][1].x += 0.2));
	0 != this.h[a] && this.v != a && (0 < this.l[a] && this.l[a]--, 0 == this.l[a] && (-1 != b && (this.l[a] = c, e < (1 != ga ? G.a[b][G.n].x : this.a[b][2].x) ? (Y(this.a[a][5], this.a[a][6], 0, 0.1, 0.1), this.g[a] = 6) : (Y(this.a[a][5], this.a[a][6], 0, 0.1, 0.1), this.g[a] = 5)), -1 != this.g[a] && (this.p(a, this.a[a][6].x, this.a[a][6].y, b), this.g[a] = -1, x(s + a, be) && (c = y(s + a, t), Ne(), p[a] = K(p[a] + c, 0, kc[a]), te(), ne.add(this.a[a][0].x, this.a[a][0].y, 0, c, 65280)))), -1 == b && (Yg(this, a), Zg(this, a)));
	Y(this.a[a][0], this.a[a][1], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][2], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][3], 4.8, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][4], 4.8, 0.5, 0.5);
	Y(this.a[a][3], this.a[a][5], 4.8, 0.5, 0.5);
	Y(this.a[a][4], this.a[a][6], 4.8, 0.5, 0.5);
	Y(this.a[a][5], this.a[a][6], 10.8, 0.01, 0.01);
	Y(this.a[a][2], this.a[a][7], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][8], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][9], 4.8, 0.5, 0.5);
	Y(this.a[a][8], this.a[a][10], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][8], 6, 0.1, 0.1)
};
da.fff = Pg.prototype.na; //Priest
Pg.prototype.na = function(a) {
	var b, c, d = 1 - (a >> 2) << 2;
	b = qc[a] + $g(rc[a] - qc[a] + 1);
	c = tc[a];
	var e = 0.5 * (this.a[a][9].x + this.a[a][10].x),
		g = 0.5 * (this.a[a][9].y + this.a[a][10].y);
	c = 1 != ga ? G.m(e - c, g - c / 2, e + c, g + c / 2) : v.m(e - c, g - c / 2, e + c, g + c / 2, d);
	if (0 != this.h[a] && this.v != a) {
		0 < this.l[a] && this.l[a]--;
		if (0 == this.l[a] && -1 != c) {
			this.l[a] = b;
			this.a[a][6].y -= 2;
			this.a[a][5].y += 2;
			if (1 != ga) {
				priestAuraTimer[a] = 60 + (12 * mc[a]);
				for (b = 0; b < G.index; b++) 0 != G.search[b] && this.p(a, this.a[a][6].x, this.a[a][6].y, b);
			} else
				for (b = d; b < d + 4; b++) 0 != v.search[b] && this.p(a, this.a[a][6].x, this.a[a][6].y, b);
			if (x(s + a, be)) {
				d = y(s + a, t);
				Ne();
				for (b = a >> 2 << 2; b < (a >> 2 << 2) + 4; b++) a != b && 0 != p[b] && (p[b] = K(p[b] + d, 0, kc[b]), ne.add(this.a[b][0].x, this.a[b][0].y, 0, d, 65280));
				te()
			}
		} - 1 == c && (Yg(this, a), Zg(this, a))
	}
	Y(this.a[a][0], this.a[a][1], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][2], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][3], 4.8, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][4], 4.8, 0.5, 0.5);
	Y(this.a[a][3], this.a[a][5], 4.8, 0.5, 0.5);
	Y(this.a[a][4], this.a[a][6], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][7], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][8], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][9], 4.8, 0.5, 0.5);
	Y(this.a[a][8], this.a[a][10], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][8], 6, 0.1, 0.1)
};
da.fff = Pg.prototype.va; //Gunner
Pg.prototype.va = function(a) {
	var b, c, d = new Qg;
	c = 1 - (a >> 2) << 2;
	b = qc[a] + $g(rc[a] - qc[a] + 1);
	var e = tc[a],
		g = 0.5 * (this.a[a][9].x + this.a[a][10].x),
		k = 0.5 * (this.a[a][9].y + this.a[a][10].y);
	c = 1 != ga ? G.m(g - e, k - e, g + e, k + e) : v.m(g - e, k - e, g + e, k + e, c); - 1 != c && this.v != a && (1 != ga ? d.q(G.a[c][G.n], this.a[a][6]) : d.q(this.a[c][2], this.a[a][6]), Xg(d), this.a[a][5].x += 0.2 * d.x, this.a[a][5].y += 0.2 * d.y, this.a[a][6].x += 0.2 * d.x, this.a[a][6].y += 0.2 * d.y, this.a[a][1].x -= 0.4 * d.x, this.a[a][1].y -= 0.4 * d.y);
	if (0 != this.h[a] && this.v != a) {
		0 < this.l[a] && this.l[a]--;
		if (0 == this.l[a] && (-1 != c && (this.l[a] = b, this.a[a][5].y -= 1.5, this.a[a][6].y -= 1.5, this.a[a][3].y += 1.6, this.a[a][4].y += 1.6, this.g[a] = 6), -1 != this.g[a])) {
			e = w(q[s + a], bd);
			g = 1;
			258 == q[s + a] && (g = w(q[s + a], Vc), x(s + a, Ld) && (g += y(s + a, t) + z(g * y(s + a, id) / 100)));
			Ne();
			if (0 < e && (e = ig(e - nc[a] - z(Cc[a] / 4), 1), e * g <= dc)) {
				dc = K(dc - e * g, 0, 9999999);
				for (b = 0; b < g; b++) ne.add(this.a[a][6].x, this.a[a][6].y, 0 > d.x ? 0.5 : -0.5, e, 16776960);
				e = 0
			}
			0 == e && (this.p(a, this.a[a][6].x, this.a[a][6].y, c), x(s + a, be) && (d = y(s + a, t), p[a] = K(p[a] + d, 0, kc[a]), ne.add(this.a[a][0].x, this.a[a][0].y, 0, d, 65280)));
			te();
			this.g[a] = -1
		} - 1 == c && (Yg(this, a), Zg(this, a))
	}
	Y(this.a[a][0], this.a[a][1], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][2], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][3], 4.8, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][4], 4.8, 0.5, 0.5);
	Y(this.a[a][3], this.a[a][5], 4.8, 0.5, 0.5);
	Y(this.a[a][4], this.a[a][6], 4.8, 0.5, 0.5);
	Y(this.a[a][5], this.a[a][6], 1.2, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][7], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][8], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][9], 4.8, 0.5, 0.5);
	Y(this.a[a][8], this.a[a][10], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][8], 6, 0.1, 0.1)
};
da.fff = Pg.prototype.wa; //Whipper NOTE: I HATE WHIPPER AND HIS STUPID FLOPPY WHIP
Pg.prototype.wa = function(a) {
	var b, c = new Qg,
		d = 1 - (a >> 2) << 2,
		e = oc[a],
		g = pc[a],
		k = qc[a] + $g(rc[a] - qc[a] + 1),
		r = tc[a],
		rangeMod = (r / 40) * (r / 40);
	for (b = 11; 14 >= b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.95);
	if (0 != this.h[a] && this.v != a) {
		0 < this.l[a] && this.l[a]--;
		b = 0.5 * (this.a[a][9].x + this.a[a][10].x);
		var m = 0.5 * (this.a[a][9].y + this.a[a][10].y);
		var xTile, yTile;
		b = 1 != ga ? G.m(b - r, m - r - 20, b + r, m + 20) : v.m(b - r, m - r - 20, b + r, m + 20, d);
		0 == this.l[a] && -1 != b && 
			(this.l[a] = k, 
			this.a[a][5].x < this.a[a][6].x ? 
				(this.a[a][5].x += 4, this.a[a][6].x -= 4) : 
				(this.a[a][6].x += 4, this.a[a][5].x -= 4), 
			c.q(G.a[b][0], this.a[a][14]), 
			Xg(c), 
			Tg(c, 4 * rangeMod), 
			this.a[a][11].add(c), 
			this.a[a][12].add(c), 
			this.a[a][13].add(c), 
			Tg(c, 2), 
			this.a[a][14].add(c), 
			
			this.a[a][2].y += 1, 
			this.g[a] = 14, 
			Ne(), 
			k = w(q[s + a], bd), 
			fc[a] = fc[a] + nc[a] + z(Cc[a] / 4) < k ? fc[a] + nc[a] + z(Cc[a] / 4) : k, 
			(fc[a] == k && 0 < k || -1 == k) && //WHIPPER moved MP-attack activation here
				(fc[a] = 0, 
				r = this.a[a][this.g[a]].y, 
				xTile = z(K(this.a[a][this.g[a]].x, 0, 511) / 8), 
				yTile = z(K(this.a[a][this.g[a]].y, 0, 255) / 8), 
				0 <= yTile - I.o[xTile] ? r = 8 * I.o[xTile] + 7 : 3 >= Kg(yTile - I.I[xTile]) && (r = 8 * I.I[xTile] + 7), 
				this.p(a, this.a[a][this.g[a]].x, r, b)),
			x(s + a, be) && (k = y(s + a, t), p[a] = K(p[a] + k, 0, kc[a]), ne.add(this.a[a][0].x, this.a[a][0].y, 0, k, 65280)), 
			te()); 
		-1 == b && Yg(this, a);
		Zg(this, a)
	}
	if (-1 != this.g[a] && 
		(x(s + a, Od) && A(100) < y(s + a, t) && (e += z(y(s + a, id) * e / 100), g += z(y(s + a, id) * g / 100)), 
		k = 20, 
		x(s + a, Yd) && (k += z(20 * y(s + a, t) / 100)), 
		d = 1 != ga ? 
			G.K(1, 0, 0, e, g, this.a[a][this.g[a]].x, this.a[a][this.g[a]].y, k, k) : 
			v.K(1, 0, 0, e, g, this.a[a][this.g[a]].x, this.a[a][this.g[a]].y, k, k, d), 
			-1 != d)) {
				Ne();
				this.whipperStarstrike(a, this.a[a][14].x, this.a[a][14].y, e, g), //WHIPPER Starstrike
				k = w(q[s + a], bd);
				te();
				this.g[a] = -1;
				x(s + a, vd) && (k = ig(1, z(this.L * y(s + a, t) / 100)), Ne(), p[a] = K(p[a] + k, 0, kc[a]), te(), ne.add(this.a[a][0].x, this.a[a][0].y, 0, k, 65280));
				x(s + a, wd) && 0 == ga && A(100) < y(s + a, t) && pe.add(this.a[a][0].x, this.a[a][0].y, 2, 0, 0);
				if (x(s + a, xd) && 0 == ga && A(100) < y(s + a, t)) {
					e = 100;
					for (b = 0; 4 > b; b++) x(s + b, Sd) && (e += y(s + b, t));
					pe.add(this.a[a][0].x, this.a[a][0].y, 1, z(this.L * e / 100), 0)
				}
				x(s + a, Zd) && A(100) < y(s + a, t) && (e = y(s + a, id), 1 != ga ? c.q(G.a[d][0], this.a[a][1]) : c.q(v.a[d][1], this.a[a][1]), Xg(c), Tg(c, 0.2 * e), 1 != ga ? Tg(c, ah[B[G.id[d]][bh]] / B[G.id[d]][ch]) : Tg(c, 0.1), 1 != ga ? G.c[d][0].sub(c) : v.c[d][0].sub(c))
			}
	Y(this.a[a][0], this.a[a][1], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][2], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][3], 4.8, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][4], 4.8, 0.5, 0.5);
	Y(this.a[a][3], this.a[a][5], 4.8, 0.5, 0.5);
	Y(this.a[a][4], this.a[a][6], 4.8, 0.5, 0.5);
	Y(this.a[a][5], this.a[a][6], 14.4, 0.02, 0.02);
	
	Y(this.a[a][5], this.a[a][11], rangeMod * 4.8, 0, 0.3);
	Y(this.a[a][11], this.a[a][12], rangeMod * 4.8, 0, 0.3);
	Y(this.a[a][12], this.a[a][13], rangeMod * 4.8, 0, 0.3);
	Y(this.a[a][13], this.a[a][14], rangeMod * 4.8, 0, 0.3);
	
	Y(this.a[a][2], this.a[a][7], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][8], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][9], 4.8, 0.5, 0.5);
	Y(this.a[a][8], this.a[a][10], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][8], 6, 0.1, 0.1);
};
Pg.prototype.whipperStarstrike = function(a, xCoord, yCoord, minAT, maxAT) { //WHIPPER
	if (lc[a] > A(100)) {
		var xDir, yDir,
			bullet = 3 + z(mc[a]/5),
			rotationSector = z(512/bullet),
			rotation = z(A(rotationSector));
		for (i=0; i<bullet; i++) {
			minCritAT = minAT;
			maxCritAt = maxAT;
			xDir = Xe[rotation][0];
			yDir = Xe[rotation][1];
			oe.add(
				0, //class_ID
				xCoord, //x_pos
				yCoord, //y_pos
				xDir, //Xspd
				yDir, //Yspd
				1, //orient
				22, //img
				0xDDFFE97F, //color
				2, //transp
				16, //width
				24 + 4*bullet, //height
				20, //box_width
				20, //box_height
				0, //appear_delay
				5, //solid_delay
				10, //lifespan
				20, //disp_eff
				0, //grav
				100, //accel
				1, //pierce
				0, //bounce
				0, //homing
				0, //knockback
				0, //splash
				z(minAT/2), //AT_Min
				z(maxAT/2), //AT_Max
				0, //type
				0, //type_param
				0, //res_mode
				0, //res_orient
				0, //res_img
				0, //Res_Color
				0, //res_transp
				0, //res_width
				0, //res_height
				0, //res_box_width
				0, //res_box_height
				0, //res_appear_delay
				0, //res_solid_delay
				0, //Res_Lifespan
				0, //res_fade_time
				0, //res_grav
				0, //res_accel
				0, //res_pierce
				0, //res_bounce
				0, //res_splash
				0, //res_ATmin
				0, //res_ATmax
				0, //res_bullet
				0, //res_type
				0); //res_type_param
			rotation += rotationSector;
		}
	}
}
da.fff = Pg.prototype.xa; //Angel
Pg.prototype.xa = function(a) {
	var b, c, d = new Qg,
		e = 1 - (a >> 2) << 2,
		g = oc[a],
		k = pc[a],
		r = qc[a] + $g(rc[a] - qc[a] + 1),
		m = tc[a],
		n;
	n = 10 > mc[a] ? 1 : 30 > mc[a] ? 2 : 60 > mc[a] ? 3 : 100 > mc[a] ? 4 : 5;
	x(s + a, ce) && (n += 1);
	for (b = 11; 14 >= b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.95);
	for (b = 15; 20 >= b; b++) W(this.a[a][b], this.c[a][b], 0, 1);
	this.a[a][11].x -= 0.1;
	this.a[a][11].y -= 0.1;
	this.a[a][12].x -= 0.1;
	this.a[a][12].y += 0.1;
	this.a[a][13].x += 0.1;
	this.a[a][13].y -= 0.1;
	this.a[a][14].x += 0.1;
	this.a[a][14].y += 0.1;
	if (0 != this.h[a] && this.v != a) {
		0 < this.l[a] && this.l[a]--;
		b = 0.5 * (this.a[a][9].x + this.a[a][10].x);
		c = 0.5 * (this.a[a][9].y + this.a[a][10].y);
		c = 1 != ga ? G.m(b - m, c - m, b + m, c + m) : v.m(b - m, c - m, b + m, c + m, e);
		for (b = 0; b < n && 0 != this.O[a][b]; b++);
		0 == this.l[a] && -1 != c && b != n && 
			(this.l[a] = r, 
			this.O[a][b] = 1, 
			this.aa[a][b] = z(m / 2) + 20, 
			this.ba[a][b] = 0, 
			this.a[a][12].x -= 2, 
			this.a[a][14].x += 2, 
			this.g[a] = 15 + b, 
			this.a[a][this.g[a]].set(this.a[a][0]), 
			this.a[a][this.g[a]].y -= 5, 
			this.c[a][this.g[a]].set(this.a[a][this.g[a]]), 
			1 != ga ? d.q(G.a[c][G.n], this.a[a][this.g[a]]) : d.q(this.a[c][1], this.a[a][this.g[a]]), 
			Xg(d), 
			Tg(d, 2), 
			this.a[a][this.g[a]].add(d)); 
		-1 == c && (Yg(this, a), 
		Zg(this, a))
	}
	for (b = 0; b < n; b++)
		if (0 != this.O[a][b] && 
			(this.g[a] = 15 + b, 
			this.aa[a][b]--, 
			0 >= this.aa[a][b] && 
				(1 == this.O[a][b] ? 
					(this.O[a][b]++, 
					d.set(this.a[a][0]), 
					d.y -= 5, 
					this.c[a][this.g[a]].set(this.a[a][this.g[a]]), 
					d.q(d, this.a[a][this.g[a]]), 
					r = Xg(d), 
					Tg(d, 2), 
					this.a[a][this.g[a]].add(d), 
					this.aa[a][b] = z(r / 2)) : 
					(this.O[a][b] = 0, 
					this.aa[a][b] = 0, 
					this.ba[a][b] = 0)), 
				this.ba[a][b]--, 
				!(0 < this.ba[a][b]) && 
					(r = 0, 
					x(s + a, Md) && A(100) < y(s + a, t) && (r = 1), //Explosion's card
					x(s + a, Od) && A(100) < y(s + a, t) && (g += z(y(s + a, id) * g / 100), k += z(y(s + a, id) * k / 100)), //Critical's card
					r = 1 != ga ? 
						G.K(r, 0, 0, g, k, this.a[a][this.g[a]].x, this.a[a][this.g[a]].y, 10, 10) : 
						v.K(r, 0, 0, g, k, this.a[a][this.g[a]].x, this.a[a][this.g[a]].y, 10, 10, e), 
					-1 != r))) {
						this.angelEcho(a, G.a[r][0].x, G.a[r][0].y, g, k); //ANGEL echoes
						Ne();
						m = w(q[s + a], bd);
						fc[a] = fc[a] + nc[a] + z(Cc[a] / 4) < m ? fc[a] + nc[a] + z(Cc[a] / 4) : m;
						if (fc[a] == m && 0 < m || -1 == m) fc[a] = 0, this.p(a, this.a[a][this.g[a]].x, this.a[a][this.g[a]].y, r);
						x(s + a, be) && (r = y(s + a, t), p[a] = K(p[a] + r, 0, kc[a]), ne.add(this.a[a][0].x, this.a[a][0].y, 0, r, 65280));
						te();
						this.ba[a][b] = w(q[s + a], 7)
					}
	Y(this.a[a][0], this.a[a][1], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][2], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][3], 4.8, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][4], 4.8, 0.5, 0.5);
	Y(this.a[a][3], this.a[a][5], 4.8, 0.5, 0.5);
	Y(this.a[a][4], this.a[a][6], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][7], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][8], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][9], 4.8, 0.5, 0.5);
	Y(this.a[a][8], this.a[a][10], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][8], 6, 0.1, 0.1);
	Y(this.a[a][1], this.a[a][11], 3.6, 0, 0.1);
	Y(this.a[a][1], this.a[a][12], 12, 0, 0.1);
	Y(this.a[a][11], this.a[a][12], 9.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][13], 3.6, 0, 0.1);
	Y(this.a[a][1], this.a[a][14], 12, 0, 0.1);
	Y(this.a[a][13], this.a[a][14], 9.6, 0.5, 0.5)
};
Pg.prototype.angelEcho = function(a, xCoord, yCoord, minAT, maxAT) { //ANGEL
	var direction = new Qg, 
		echoes = z(lc[a] / 10),
		echoCol = 0xFF000000 | w(q[s + a], Sc);
	while (echoes > 0) {
		direction.x = N(-1, 1);
		direction.y = N(-1, 1);
		Xg(direction);
		Tg(direction, 5);
		oe.add(
			0, //class_ID
			xCoord, //x_pos
			yCoord, //y_pos
			direction.x, //Xspd
			direction.y, //Yspd
			1, //orient
			26, //img
			echoCol, //color
			1, //transp
			16, //width
			16, //height
			12, //box_width
			12, //box_height
			0, //appear_delay
			5, //solid_delay
			120, //lifespan
			5, //disp_eff
			0, //grav
			100, //accel
			0, //pierce
			2, //bounce
			0, //homing
			0, //knockback
			0, //splash
			minAT, //AT_Min
			maxAT, //AT_Max
			30, //type
			lc[a], //type_param
			0, //res_mode
			0, //res_orient
			0, //res_img
			0, //Res_Color
			0, //res_transp
			0, //res_width
			0, //res_height
			0, //res_box_width
			0, //res_box_height
			0, //res_appear_delay
			0, //res_solid_delay
			0, //Res_Lifespan
			0, //res_fade_time
			0, //res_grav
			0, //res_accel
			0, //res_pierce
			0, //res_bounce
			0, //res_splash
			0, //res_ATmin
			0, //res_ATmax
			0, //res_bullet
			0, //res_type
			0); //res_type_param
		echoes--;
	}
}
da.fff = Pg.prototype.summoner;	//SUMMONER
Pg.prototype.summoner = function(a) {
	
	swarm[a] = z(K(2 + mc[a] / 20, 1, summons.maxSummons)); //DEX increases amount of summons
	summons.movement(a);
	if (this.h[a] != 0 && this.v != a) {	//Grounded and not held
		summons.attack(a);
	}
	if (this.v == a) {					//Held
		for (i=0; i<swarm[a]; i++) {
			summons.focusJoint[a][i] = -1; //Avoid a 'whipper situation' where hitbox stays active
			if (this.h[a] == 0)	{		//Not grounded
				summons.movementDetail[a][i] = 1; //Set movementDetail to default to avoid summons staying in place
			}
		}
	}
	summons.attackHit(a);
	
	Y(this.a[a][0], this.a[a][1], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][2], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][3], 4.8, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][4], 4.8, 0.5, 0.5);
	Y(this.a[a][3], this.a[a][5], 4.8, 0.5, 0.5);
	Y(this.a[a][4], this.a[a][6], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][7], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][8], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][9], 4.8, 0.5, 0.5);
	Y(this.a[a][8], this.a[a][10], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][8], 6, 0.1, 0.1)
};
da.fff = Pg.prototype.wraith; //REAPER
Pg.prototype.wraith = function(a) {
	var b, c, d = new Qg, scytheAngle = new Qg;
		b = oc[a]; //min AT
	var	g = pc[a], //max AT
		k = qc[a] + $g(rc[a] - qc[a] + 1), //AGI
		r = tc[a]; //range
		wraithSoul[a] = mc[a]; //Wraith Soul chance (DEX)
	scytheClock[a] += 1;
	if (scytheClock[a] >= 512) scytheClock[a] = 0;
	if (this.pa[a] > 0) scytheClock[a] += 9;
	if (0 != this.h[a] && this.v != a) { //Grounded and not held
		if (this.l[a] > 0) this.l[a]--; //Decrease reload
		var m = 0.5 * (this.a[a][9].x + this.a[a][10].x); //Character center coordinates
			n = 0.5 * (this.a[a][9].y + this.a[a][10].y);
		c = G.m(m - r, n - r, m + r, n); //Find target
		if (c != -1) { //Target found
			scytheClock[a] += 9; //Spin faster when attacking
			d.q(G.a[c][0], this.a[a][11]);
			Xg(d);
			if (this.l[a] == 0) { //If ready to attack
				this.l[a] = k;
				if (m > this.a[a][5].x) { //Left hand positioning determines hand rotation direction
					this.a[a][5].x += 1;
					this.a[a][5].y -= 1;
					this.a[a][6].x -= 1;
					this.a[a][6].y += 1;
				} else {
					this.a[a][5].x -= 1;
					this.a[a][5].y += 1;
					this.a[a][6].x += 1;
					this.a[a][6].y -= 1;
				}
				this.a[a][2].y += 1; //Move body down to stay grounded
				
				Tg(d, 6);
				
				this.g[a] = 11; //Focus point
				k = w(q[s + a], bd); //Weapon MP
				if (fc[a] + nc[a] + z(Cc[a] / 4) < k) fc[a] += nc[a] + z(Cc[a] / 4); //If weapon MP isn't reached, increase MP bar
				else fc[a] = k;
				if (fc[a] == k && k > 0) { //Magic attack
					fc[a] = 0; //MP to 0
					this.pa[a] = w(q[s + a], 41); //Set residue count
				}
				if (x(s + a, be)) { //Heal's card
					k = y(s + a, t); 
					p[a] = K(p[a] + k, 0, kc[a]); 
					ne.add(this.a[a][0].x, this.a[a][0].y, 0, k, 65280);
				}
			} else {
				Tg(d, 0.2);
			}
			scytheFlightDir[a].add(d);
		}
		if (c == -1) Yg(this, a); //If no target, walk
		Zg(this, a); //Swim
	}
	if (this.g[a] != -1) { //If focus point
		if (x(s + a, Od) && y(s + a, t) > A(100)) { //Critical's card
			b += z(y(s + a, id) * b / 100); //Increase min and max AT
			g += z(y(s + a, id) * g / 100);
		}
		if (G.K(1, 0, 0, b, g, this.a[a][this.g[a]].x, this.a[a][this.g[a]].y, 16, 16) != -1) { //If attack hits
			/*if (this.pa[a] > 0) { //Magic attack
				this.pa[a]--;
				this.p(a, 0.5 * (this.a[a][13].x + this.a[a][12].x), 0.5 * (this.a[a][13].y + this.a[a][12].y), 0);
			}*/
			//Tg(scytheFlightDir[a], 0.6); //Reduce flight speed
			this.g[a] = -1; //Unset focus point
			this.reaperSpawnSoul(a, 0);
		}
	}
	Y(this.a[a][0], this.a[a][1], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][2], 3.6, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][3], 4.8, 0.5, 0.5);
	Y(this.a[a][1], this.a[a][4], 4.8, 0.5, 0.5);
	Y(this.a[a][3], this.a[a][5], 4.8, 0.5, 0.5);
	Y(this.a[a][4], this.a[a][6], 4.8, 0.5, 0.5);
	Y(this.a[a][3], this.a[a][4], 4.8, 0.01, 0.01);
	Y(this.a[a][2], this.a[a][7], 4.8, 0.5, 0.5);
	Y(this.a[a][2], this.a[a][8], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][9], 4.8, 0.5, 0.5);
	Y(this.a[a][8], this.a[a][10], 4.8, 0.5, 0.5);
	Y(this.a[a][7], this.a[a][8], 6, 0.1, 0.1);
	Y(this.a[a][1], this.a[a][11], 16, 0, 0.1); //Scythe attached to body
	
	scytheAngle.x = Xe[scytheClock[a]&511][0]; //Scythe's angle, it rotates
	scytheAngle.y = Xe[scytheClock[a]&511][1];
	
	this.a[a][11].x += scytheFlightDir[a].x; //Move scythe
	this.a[a][11].y += scytheFlightDir[a].y;
	
	this.a[a][12].x = this.a[a][11].x + 16 * scytheAngle.x; //Scythe handle
	this.a[a][12].y = this.a[a][11].y + 16 * scytheAngle.y;
	
	b = 1;
	if (q[s + a] == 123) b = -1; //Crazy 3D movement
	this.a[a][13].x = this.a[a][12].x + Xe[scytheClock[a]*b+180&511][0]*24; //Scythe blade coords
	this.a[a][13].y = this.a[a][12].y + Xe[scytheClock[a]*b+180&511][1]*24;
	
	if (c == -1) {
		if (scytheClock[a]%73 < 1) {
			scytheFlightDir[a].x = N(-1, 1);
			scytheFlightDir[a].y = N(-1, 1);
			Xg(scytheFlightDir[a]);
			Tg(scytheFlightDir[a], 0.2);
		}
	}
	
	/*this.a[a][11].x = K(this.a[a][11].x, 1, 511); //Keep scythe within the level (Looks bad on the class select screen)
	this.a[a][11].y = K(this.a[a][11].y, 1, 254);*/
	
	if (this.pa[a] > 0) { //Magic attack emission similar to gladiator
		if ((Kh+1) % w(q[s + a], hd) == 0) { //8th weapon parameter determines the frequency (min 1/1 frame, max 1/60 frames) (Use 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60 for consistency)
			this.pa[a]--;
			b = 0.5 * (this.a[a][13].x + this.a[a][12].x);
			c = 0.5 * (this.a[a][13].y + this.a[a][12].y);
			this.p(a, b, c, 0);
		}
	}
}
Pg.prototype.reaperSpawnSoul = function(a, recursion) { //REAPER
	var wraithSoulChance = K(wraithSoul[a], 0, 80);
	if (wraithSoulChance > A(100)) {
		var soulSize = ig(5, 16 - recursion),
			soulCol = 0xAAD2FFFF,
			soulSplash = 0,
			soulType = 0,
			soulTypeParam = 0,
			soulResMode = 0,
			soulResAT = lc[a],
			soulResBullet = 3;
		switch (q[s + a]) { //Weapon-specific changes
			case 123:
				soulType = 8;
				soulTypeParam = 33;
				soulCol = 0x88000000 | $g(16) * 0x110000 | $g(16) * 0x1100 | $g(16) * 0x11;
				break;
		}
		if (wraithSoul[a] >= 20 && recursion == 0) { //Bigger and splash damage
			soulSize = 24;
			soulSplash = 1;
			if (wraithSoul[a] >= 40) { //Explodes into 3 residue
				soulResMode = 7;
				if (wraithSoul[a] >= 60) { //More residue and more residue damage
					soulResAT *= 2;
					soulResBullet += 2;
				}
			}
		} if (wraithSoul[a] >= 80 + 5 * recursion) { //Chance for additional weaker souls, 1 per 5 DEX after 80 reached
			this.reaperSpawnSoul(a, recursion + 1);
		}
		oe.add(
			0, //class_ID
			this.a[a][11].x, //x_pos
			this.a[a][11].y, //y_pos
			K(N(-recursion, recursion), -4, 4), //Xspd
			-2, //Yspd
			1, //orient
			33, //img
			soulCol, //color
			1, //transp
			soulSize, //width
			soulSize, //height
			soulSize-4, //box_width
			soulSize-4, //box_height
			0, //appear_delay
			20, //solid_delay
			300, //lifespan
			10, //disp_eff
			0, //grav
			100, //accel
			1, //pierce
			0, //bounce
			160, //homing
			0, //knockback
			soulSplash, //splash
			10 * lc[a] / ((recursion + 1) * (recursion + 1)), //AT_Min
			10 * lc[a] / ((recursion + 1) * (recursion + 1)), //AT_Max
			soulType, //type
			soulTypeParam, //type_param
			soulResMode, //res_mode
			1, //res_orient
			22, //res_img
			0xAAD2FFFF, //Res_Color
			1, //res_transp
			16, //res_width
			24, //res_height
			12, //res_box_width
			12, //res_box_height
			0, //res_appear_delay
			0, //res_solid_delay
			50, //Res_Lifespan
			5, //res_fade_time
			0, //res_grav
			85, //res_accel
			1, //res_pierce
			0, //res_bounce
			0, //res_splash
			soulResAT, //res_ATmin
			soulResAT, //res_ATmax
			soulResBullet, //res_bullet
			0, //res_type
			0); //res_type_param
	}
}

da.fff = Pg.prototype.b;
Pg.prototype.b = function() { //Draw stickmen
	var a, b, c = new Qg,
		d = new Qg,
		e = 1 != ga ? 4 : 8;
	for (a = 0; a < e; a++) {
		var g = w(q[s + a], Yc),
			k = w(q[s + a], Sc),
			r = 15908203,
			m = 16777215;
		x(s + a, Pd) && (r = 13421772, m = 3342438);
		//ELEMENT statuses' effect on body color
		/*Gravity:*/0 < this.gravityTimePl[a] ? (r = 0x5F007F, m = 0x340049) : /*Freeze:*/0 < this.B[a] ? (r = 1989840, m = 5934817) : /*Slow:*/0 < this.C[a] ? (r = 9840, m = 1989840) : /*Poison*/0 < this.D[a] && (r = 3381504, m = 3407616);
		0 < this.qa[a] && (this.qa[a]--, m = 16711680);
		dg = Xf = 1;
		if (a == tb && 0 == ga && 2 == yc)
			for (b = 0; 11 > b; b++) J(cb, z(this.a[a][b].x), z(this.a[a][b].y), 12, 12, 0, 0, 12, 12, 1358888960);
		else if (0 < Lb) {
			Lb--;
			var n = 64 > Lb ? Lb : 64;
			for (b = 0; 11 > b; b++) J(cb, z(this.a[a][b].x),
				z(this.a[a][b].y), 24, 24, 0, 0, 12, 12, n << 24 | 16777062);
			120 < Lb && (b = $g(11), v.p(563, v.a[a][b].x, v.a[a][b].y, 0))
		} else
			for (b = 0; 11 > b; b++) J(cb, z(this.a[a][b].x), z(this.a[a][b].y), 12, 12, 0, 0, 12, 12, 1073741824);
		Xf = dg = 0;
		8 == this.step[a] && (b = (k & 16711680) >> 17 << 16 | (k & 65280) >> 9 << 8 | (k & 255) >> 1, L(this.a[a][1].x, this.a[a][1].y, this.a[a][11].x, this.a[a][11].y, b), L(this.a[a][1].x, this.a[a][1].y, this.a[a][12].x, this.a[a][12].y, b), L(this.a[a][11].x, this.a[a][11].y, this.a[a][12].x, this.a[a][12].y, b), L(this.a[a][1].x, this.a[a][1].y, this.a[a][13].x, this.a[a][13].y, b), L(this.a[a][1].x, this.a[a][1].y, this.a[a][14].x, this.a[a][14].y, b), L(this.a[a][13].x, this.a[a][13].y, this.a[a][14].x, this.a[a][14].y, b));
		L(this.a[a][1].x, this.a[a][1].y, this.a[a][2].x, this.a[a][2].y, m);
		this.step[a] != Mg && (L(this.a[a][1].x, this.a[a][1].y, this.a[a][3].x, this.a[a][3].y, m), L(this.a[a][1].x, this.a[a][1].y, this.a[a][4].x, this.a[a][4].y, m));
		L(this.a[a][3].x, this.a[a][3].y, this.a[a][5].x, this.a[a][5].y, m);
		L(this.a[a][4].x, this.a[a][4].y, this.a[a][6].x, this.a[a][6].y, m);
		this.step[a] != Mg && (L(this.a[a][2].x, this.a[a][2].y, this.a[a][7].x, this.a[a][7].y, m), L(this.a[a][2].x, this.a[a][2].y, this.a[a][8].x, this.a[a][8].y, m));
		L(this.a[a][7].x, this.a[a][7].y, this.a[a][9].x, this.a[a][9].y, m);
		L(this.a[a][8].x, this.a[a][8].y, this.a[a][10].x, this.a[a][10].y, m);
		bg(z(this.a[a][0].x) - 2, z(this.a[a][0].y) - 2, 5, 5, r);
		dg = 2;
		x(s + a, de) && eg(Ra, z(this.a[a][0].x) - 6, z(this.a[a][0].y) - 6 - 6, 12, 12, 228, 0, 12, 12, 16766720);
		x(s + a, ee) && eg(Ra, z(this.a[a][0].x) - 6, z(this.a[a][0].y) - 6 - 6, 12, 12, 228, 0, 12, 12, 14540253);
		dg = 0;
		if (1 == this.step[a]) g = 3, x(s + a, Yd) && (g = 5), V(z(this.a[a][5].x) - 1, z(this.a[a][5].y) - 1, g, g, k), V(z(this.a[a][6].x) - 1, z(this.a[a][6].y) - 1, g, g, k);
		else if (2 == this.step[a]) x(s + a, compoBlademaster) && (g += y(s + a, t)), c.q(this.a[a][5], this.a[a][6]), Xg(c), Tg(c, g), c.add(this.a[a][6]), L(this.a[a][6].x, this.a[a][6].y, c.x, c.y, k);
		else if (3 == this.step[a]) c.q(this.a[a][6], this.a[a][5]), Xg(c), d.set(c), dh(d), Tg(c, 18), c.add(this.a[a][5]), L(this.a[a][5].x, this.a[a][5].y, c.x, c.y, k), Tg(d, 8), eh(c, this.a[a][6], d), L(this.a[a][5].x, this.a[a][5].y, c.x, c.y, 8421504), d.q(this.a[a][6], d), L(this.a[a][5].x, this.a[a][5].y, d.x, d.y, 8421504), L(c.x, c.y, d.x, d.y, 12632256);
		else if (4 == this.step[a]) eh(c, this.a[a][5], this.a[a][6]), Tg(c, 0.5), V(z(c.x) - 1, z(c.y) - 1, 3, 3, k);
		else if (5 == this.step[a]) c.x = this.a[a][0].x + N(-10, 10), c.y = this.a[a][0].y + N(-10, 0), c.q(this.a[a][6], this.a[a][4]), Xg(c), dh(c), Tg(c, 8), L(this.a[a][6].x - c.x, this.a[a][6].y - c.y, this.a[a][6].x + c.x, this.a[a][6].y + c.y, 8421504), V(z(this.a[a][6].x + c.x) - 1, z(this.a[a][6].y + c.y) - 1, 3, 3, k);
		else if (6 == this.step[a]) g = z(K(z(this.a[a][6].x) - z(this.a[a][1].x), -8, 8) / 2), -4 == g ? V(z(this.a[a][6].x) - 5, z(this.a[a][6].y) - 2, 7, 2, k) : -3 == g ? V(z(this.a[a][6].x) - 4, z(this.a[a][6].y) - 2, 6, 2, k) : -2 == g ? V(z(this.a[a][6].x) - 3, z(this.a[a][6].y) - 2, 5, 2, k) : -1 == g ? V(z(this.a[a][6].x) - 2, z(this.a[a][6].y) - 2, 3, 2, k) : 0 == g ? V(z(this.a[a][6].x) - 1, z(this.a[a][6].y) - 3, 2, 2, k) : 1 == g ? V(z(this.a[a][6].x) - 1, z(this.a[a][6].y) - 2, 3, 2, k) : 2 == g ? V(z(this.a[a][6].x) - 2, z(this.a[a][6].y) - 2, 5, 2, k) : 3 == g ? V(z(this.a[a][6].x) - 2, z(this.a[a][6].y) - 2, 6, 2, k) : 4 == g && V(z(this.a[a][6].x) - 2, z(this.a[a][6].y) - 2, 7, 2, k), V(z(this.a[a][6].x) - 1, z(this.a[a][6].y) - 2, 2, 4, k);
		else if (7 == this.step[a]) g = 3, x(s + a, Yd) && (g = 5), b = (k & 16711680) >> 17 << 16 | (k & 65280) >> 9 << 8 | (k & 255) >> 1, L(this.a[a][5].x, this.a[a][5].y, this.a[a][11].x, this.a[a][11].y, b), L(this.a[a][11].x, this.a[a][11].y, this.a[a][12].x, this.a[a][12].y, b), L(this.a[a][12].x, this.a[a][12].y, this.a[a][13].x, this.a[a][13].y, b), L(this.a[a][13].x, this.a[a][13].y, this.a[a][14].x, this.a[a][14].y, b), V(z(this.a[a][14].x) - 1, z(this.a[a][14].y) - 1, g, g, k);
		else if (8 == this.step[a]) {
			g = 10 > mc[a] ? 1 : 30 > mc[a] ? 2 : 60 > mc[a] ? 3 : 100 > mc[a] ? 4 : 5;
			x(s + a, ce) && (g += 1);
			for (b = 0; b < g && 0 != this.O[a][b]; b++);
			b != g && J(cb, z(this.a[a][0].x), z(this.a[a][0].y) - 5, 7, 3, 33, 0, 7, 3, k);
			for (b = 0; b < g; b++) 0 != this.O[a][b] && J(cb, z(this.a[a][15 + b].x), z(this.a[a][15 + b].y), 7, 3, 33, 0, 7, 3, k)
		}
		else if (10 == this.step[a]) summons.draw(a); //SUMMONER Draw summons whenever the rangers are drawn
		else if (11 == this.step[a]) { //REAPER Draw scythe
			b = 1;
			c.q(this.a[a][12], this.a[a][11]);
			if (q[s + a] == 123) { //Black-Green flashing
				b = 2;
				k = Kh*0x000800;
				if (Kh > 29) k = (60-Kh)*0x000800;
			}
			L(this.a[a][11].x + 0.6 * c.x, this.a[a][11].y + 0.6 * c.y, this.a[a][13].x, this.a[a][13].y, k);
			L(this.a[a][12].x, this.a[a][12].y, this.a[a][13].x, this.a[a][13].y, k);
			L(this.a[a][12].x, this.a[a][12].y, this.a[a][11].x - b * c.x, this.a[a][11].y - b * c.y, 0x808080);
		}
		40 != f && (0 < Ac[a] + Cc[a] && (Xf = 2, dg = 1, k = Ac[a], k < Bc[a] && (k = Bc[a]), k < Cc[a] && (k = Cc[a]), k = 4278190080 | 255 * Ac[a] / k << 16 | 255 * Bc[a] / k << 8 | 255 * Cc[a] / k, J(cb, z(z(this.a[a][9].x + this.a[a][10].x) / 2), z(z(this.a[a][9].y + this.a[a][10].y) / 2), 20, 12, 12, 0, 20, 12, k), Xf = dg = 0), 0 < (xc & 1) && 0 < p[a] && (V(z(this.a[a][0].x) - 6, z(this.a[a][0].y) - 6, 13, 2, 10027008), V(z(this.a[a][0].x) - 6, z(this.a[a][0].y) - 6, z(13 * p[a] / kc[a]), 2, 52224)), a == tb && 0 == ga && (0 == yc ? V(z(this.a[a][0].x) - 1, z(this.a[a][0].y) - 8, 3, 3, 16776960) : 1 == yc && (L(z(this.a[a][0].x) - 3, z(this.a[a][0].y) - 14, z(this.a[a][0].x) + 3, z(this.a[a][0].y) - 14, 16776960), L(z(this.a[a][0].x) - 3, z(this.a[a][0].y) - 14, z(this.a[a][0].x) + 0.5, z(this.a[a][0].y) - 7, 16776960), L(z(this.a[a][0].x) + 3.5, z(this.a[a][0].y) - 14, z(this.a[a][0].x) + 0.5, z(this.a[a][0].y) - 7, 16776960))))
	}
};

var summons = new summon; //SUMMONER The summon class and its various functions
function summon() {
	this.maxJoints = 9;
	this.maxSummons = 7;
	this.joint = Array(4);				//joint[rangerNumber][summonNumber][jointNumber]
	//this.jointDestination = Array(4);	//jointDestination[rangerNumber][summonNumber][jointNumber]
	this.focusJoint = Array(4);			//focusJoint[rangerNumber][summonNumber]
	this.species = Array(4);			//species[rangerNumber[summonNumber]
	this.minAT = Array(4);				//minAT[rangerNumber][summonNumber]
	this.minATbase = Array(4);			//minATbase[rangerNumber][summonNumber] (For AT aura updates)
	this.maxAT = Array(4);				//maxAT[rangerNumber][summonNumber]
	this.maxATbase = Array(4);			//maxATbase[rangerNumber][summonNumber] (For AT aura updates)
	this.minAGI = Array(4);				//minAGI[rangerNumber][summonNumber]
	this.maxAGI = Array(4);				//maxAGI[rangerNumber][summonNumber]
	this.range = Array(4);				//range[rangerNumber][summonNumber]
	this.MAG = Array(4);				//MAG[rangerNumber][summonNumber]
	this.MP = Array(4);					//MP[rangerNumber][summonNumber]
	this.reloadTicks = Array(4);		//reloadTicks[rangerNumber][summonNumber]
	this.weaponID = Array(4);			//weaponID[rangerNumber][summonNumber]
	this.compoID1 = Array(4);			//compoID1[rangerNumber][summonNumber]
	this.compoID2 = Array(4);			//compoID2[rangerNumber][summonNumber]
	this.movementDetail = Array(4);		//movementDetail[rangerNumber][summonNumber]	Used to alter certain movement AI when attacking/not attacking
	this.clock = new Int32Array(4);		//clock[rangerNumber]							Used for time-based movement, such as circular motion
	
	for (i=0; i<4; i++) {
		this.joint[i] = Array(this.maxSummons);
		//this.jointDestination[i] = Array(this.maxSummons);
		this.focusJoint[i] = new Int32Array(this.maxSummons);
		this.species[i] = new Int32Array(this.maxSummons);
		this.minAT[i] = new Int32Array(this.maxSummons);
		this.minATbase[i] = new Int32Array(this.maxSummons);
		this.maxAT[i] = new Int32Array(this.maxSummons);
		this.maxATbase[i] = new Int32Array(this.maxSummons);
		this.minAGI[i] = new Int32Array(this.maxSummons);
		this.maxAGI[i] = new Int32Array(this.maxSummons);
		this.range[i] = new Int32Array(this.maxSummons);
		this.MAG[i] = new Int32Array(this.maxSummons);
		this.MP[i] = new Int32Array(this.maxSummons);
		this.reloadTicks[i] = new Int32Array(this.maxSummons);
		this.weaponID[i] = new Int32Array(this.maxSummons);
		this.compoID1[i] = new Int32Array(this.maxSummons);
		this.compoID2[i] = new Int32Array(this.maxSummons);
		this.movementDetail[i] = new Int32Array(this.maxSummons);
		this.clock[i] = 0;
		
		for (j=0; j<this.maxSummons; j++) {
			this.joint[i][j] = Array(this.maxJoints);
			//this.jointDestination[i][j] = Array(this.maxJoints);
			this.focusJoint[i][j] = -1;
			this.species[i][j] = -1;
			this.reloadTicks[i][j] = 0;
			this.movementDetail[i][j] = 1;
			
			for (k=0; k<this.maxJoints; k++) {
				this.joint[i][j][k] = new Qg;
				//this.jointDestination[i][j][k] = new Qg;
			}
		}
	}
}
summon.prototype.setPos = function(a, b){
	for (j=0; j<this.maxJoints; j++){
		Rg(this.joint[a][b][j], v.a[a][1].x, v.a[a][1].y);
		//this.jointDestination[a][b][j].set(this.joint[a][b][j]);
	}
}

summon.prototype.spawn = function(a, b){
	var weaponID = q[s+a];
	if (weaponID == 0) return; //Skip if no weapon equipped
	if (w(weaponID, hd) == 9){ //If weapon species is armor
		for (j=0; j<this.maxSummons; j++){
			if (this.species[a][j] == 9){ //Skip if armor
				return;
			}
		}
	}
	this.species[a][b] = w(weaponID, hd);
	this.minAT[a][b] = this.minATbase[a][b] = oc[a] / (1 + Ac[a] / 100); //Remove effects of AT aura, it gets applied elsewhere
	this.maxAT[a][b] = this.maxATbase[a][b] = pc[a] / (1 + Ac[a] / 100);
	this.minAGI[a][b] = qc[a];
	this.maxAGI[a][b] = rc[a];
	this.range[a][b] = tc[a];
	this.MAG[a][b] = nc[a];
	this.MP[a][b] = 0;
	this.weaponID[a][b] = weaponID;
	this.compoID1[a][b] = Dc[s+a];
	this.compoID2[a][b] = Ec[s+a];
	
	this.setPos(a, b);
}

summon.prototype.despawn = function(a, b){
	this.focusJoint[a][b] = -1;
	this.species[a][b] = -1;
	this.minAT[a][b] = this.minATbase[a][b] = 0;
	this.maxAT[a][b] = this.maxATbase[a][b] = 0;
	this.minAGI[a][b] = 0;
	this.maxAGI[a][b] = 0;
	this.range[a][b] = 0;
	this.MAG[a][b] = 0;
	this.MP[a][b] = 0;
	this.weaponID[a][b] = 0;
	this.compoID1[a][b] = 0;
	this.compoID2[a][b] = 0;
}

summon.prototype.movement = function(a){
	var b, c, k;
	this.clock[a] += 1;
	if (this.clock[a] >= 512) this.clock[a] = 0;
	k = this.clock[a];
	for (i=0; i<swarm[a]; i++){
		if (this.species[a][i] == -1) continue; //Skip if not spawned
		b = 0;
		for (j=0; j<i; j++)
			if (this.species[a][j] == this.species[a][i]) b += 1; //Number of this species before this slot
		switch (this.species[a][i]){
			case 2:	//Bird
				//Body and wing connections:
				Y(this.joint[a][i][0], this.joint[a][i][1], 3.6, 0, 0.5);		//Body to left wing's top corner
				Y(this.joint[a][i][0], this.joint[a][i][2], 10, 0, 0.5);		//Body to left wing's bottom corner
				Y(this.joint[a][i][1], this.joint[a][i][2], 9.6, 0.1, 0.1);		//Left wing's top corner to bottom corner
				Y(this.joint[a][i][0], this.joint[a][i][3], 3.6, 0, 0.5);		//Body to right wing's top corner
				Y(this.joint[a][i][0], this.joint[a][i][4], 10, 0, 0.5);		//Body to right wing's bottom corner
				Y(this.joint[a][i][3], this.joint[a][i][4], 9.6, 0.1, 0.1);		//Right wing's top corner to bottom corner
				Y(this.joint[a][i][0], this.joint[a][i][5], 25, 0.05, 0.1); 	//Invisible joint to pull the body smoothly
				
				//Body movement:
				this.joint[a][i][0].x += 0.01 * (v.a[a][1].x - this.joint[a][i][0].x) + (-1)**b * 0.5 * Xe[b<<4][1]; //Pulled towards ranger, offset depending on number of this species
				this.joint[a][i][0].y += 0.01 * (v.a[a][1].y - 64 - this.joint[a][i][0].y) + 30 * ((Kh + 43 * (a + b)) % 60 - 30) / (60 + (((Kh + 43 * (a + b)) % 60 - 30)**2));	//Pulled towards 64px above ranger, wave movement with a sin(x) approximation (well, something akin to that at least: x/(x^2 + 1)).
				//Wing movement:																																					//The +43*(a+b) so different summons are at different phases of the wave movement.
				this.joint[a][i][1].x += -1;	//Left wing's top corner
				this.joint[a][i][1].y += -0.5;
				
				this.joint[a][i][2].x += -0.5;	//Left wing's bottom corner
				this.joint[a][i][2].y += 0.5;
				
				this.joint[a][i][3].x += 1;		//Right wing's top corner
				this.joint[a][i][3].y += -0.5;
				
				this.joint[a][i][4].x += 0.5;	//Right wing's bottom corner
				this.joint[a][i][4].y += 0.5;
				break;
			case 1: //Snake
					if (this.species[a][j] == 1) b += 1; //Number of this species before this slot
				for (j=0; j<4; j++)
					Y(this.joint[a][i][j], this.joint[a][i][j+1], 4, 0, 0.3);	//Connect segments
				Y(this.joint[a][i][0], this.joint[a][i][5], 25, 0.05, 0.1);		//Invisible joint
				
				this.joint[a][i][0].x += this.movementDetail[a][i] * 0.05 * (v.a[a][1].x - this.joint[a][i][0].x) + 0.5 * ((Kh + 43 * b) % 60 - 30) / (1 + (((Kh + 43 * b) % 60 - 30)**2) / 60); //Towards ranger, slithering motion with x/(x^2 + 1)
				
				for (j = 0; j < 5; j++){ //All joints except invisible joint
					b = K(this.joint[a][i][j].x, 0, 511)>>3; //Joint's horizontal tile number
					c = K(this.joint[a][i][j].y, 0, 255)>>3; //Vertical
					if (I.hb[b] < I.o[b] && Kg(c - I.hb[b]) <= 3 && I.e[c][b] != 9 && I.e[c+1][b] != 9)	//If aerial floor tile exists and joint is within 3 tiles of it and joint is not in/just above water
						this.joint[a][i][j].y += (z((I.hb[b]<<3) + 4 + j - this.joint[a][i][j].y)<<1) / (Kg(z((I.hb[b]<<3) + 4 + j - this.joint[a][i][j].y)) + 1); //Stay on the floor
					else if (c - I.o[b] < -1) //If 1 or more tiles above floor
						this.joint[a][i][j].y += 5 - j; //High gravity (less on smaller tail joints)
					else this.joint[a][i][j].y += (z((I.o[b]<<3) + 4 + j - this.joint[a][i][j].y)<<1) / (Kg(z((I.o[b]<<3) + 4 + j - this.joint[a][i][j].y)) + 1); //Stay on the floor
				}
				break;
			case 0: //Melee Spider
			case 8: //Projectile Spider
				for (j=1; j<3; j++){
					Y(this.joint[a][i][0], this.joint[a][i][j], 4, 1, 1); //Body to knees
					Y(this.joint[a][i][0], this.joint[a][i][j+2], 6, 1, 1);
					Y(this.joint[a][i][j], this.joint[a][i][j+4], 5, 1, 1); //Knees to legs
					Y(this.joint[a][i][j+2], this.joint[a][i][j+6], 7, 1, 1);
				}
				c = this.movementDetail[a][i] * 0.03 * ((v.a[a][1].x - this.joint[a][i][0].x) + (-1)**b * 20 * Xe[b<<4][1]); //Body's distance from the ranger, offset depending on number of this species
				
				this.joint[a][i][0].x += c; //Move body towards ranger
				this.joint[a][i][0].y += 1;	//Gravity on the body
				
				//Leg positioning/movement towards ranger:
				this.joint[a][i][1].x += -1.2 + c;
				this.joint[a][i][1].y += -1.8;
				
				this.joint[a][i][2].x += 1.2 + c;
				this.joint[a][i][2].y += -1.8;
				
				this.joint[a][i][3].x += -1.2 + c;
				this.joint[a][i][3].y += -1.8;
				
				this.joint[a][i][4].x += 1.2 + c;
				this.joint[a][i][4].y += -1.8;
				
				this.joint[a][i][5].x += -0.8 + c;
				this.joint[a][i][5].y += 1;
				
				this.joint[a][i][6].x += 0.8 + c;
				this.joint[a][i][6].y += 1;
				
				this.joint[a][i][7].x += -0.8 + c;
				this.joint[a][i][7].y += 1;
				
				this.joint[a][i][8].x += 0.8 + c;
				this.joint[a][i][8].y += 1;
				
				if ((Kh + 4 * i)%10 < 5) this.joint[a][i][0].y += 2;									//Body scuttling motion
				for (j=1; j<9; j++) this.joint[a][i][j].y += 0.3 * (10 - ((Kh + 15 * (j + i)) % 20));	//Legs scuttling motion
				
				for (j=5; j<9; j++){ //Make the legs stay on top of the surface
					b = K(this.joint[a][i][j].x, 0, 511)>>3; 	//Joint's horizontal tile number
					c = K(this.joint[a][i][j].y, 0, 255)>>3; 	//Vertical
					if (I.hb[b] < I.o[b] && Kg(c - I.hb[b]) <= 3 && I.e[c][b] != 9 && I.e[c+1][b] != 9)	//If aerial floor tile exists and joint is within 3 tiles of it and joint is not in water
						this.joint[a][i][j].y += (z((I.hb[b]<<3) + 6 - this.joint[a][i][j].y)<<1) / (Kg(z((I.hb[b]<<3) + 6 - this.joint[a][i][j].y)) + 1); //Stay on the floor
					else if (c - I.o[b] < -1) //If 1 or more tiles above floor
						this.joint[a][i][j].y += 6, //High gravity
						this.joint[a][i][0].y += 1.5; //Also on body
					else this.joint[a][i][j].y += (z((I.o[b]<<3) + 6 - this.joint[a][i][j].y)<<1) / (Kg(z((I.o[b]<<3) + 6 - this.joint[a][i][j].y)) + 1); //Stay on the floor
				}
				break;
			case 3: //Dragon
				for (j=0; j<4; j++){
					Y(this.joint[a][i][j], this.joint[a][i][j+1], 10, 0, 0.5); //Connect main body joints
				}
				for (j=5; j<7; j++){
					Y(this.joint[a][i][1], this.joint[a][i][j], 4, 0, 0.5); //Connect arms
					Y(this.joint[a][i][j], this.joint[a][i][j+2], 3, 0, 0.5);
					this.joint[a][i][j].x += (-1)**j * 0.5; //Arm gravity and positioning
					this.joint[a][i][j].y += 0.5;
					this.joint[a][i][j+2].x += (-1)**j;
					this.joint[a][i][j+2].y += 1;
				}
				this.joint[a][i][0].x += this.movementDetail[a][i] * 0.03 * (v.a[a][1].x - this.joint[a][i][0].x) + 3 * Xe[2 * (2 * k + 73 * b) &511][0]; //Circular/Elliptic motion
				this.joint[a][i][0].y += this.movementDetail[a][i] * 0.03 * (v.a[a][1].y - 80 - this.joint[a][i][0].y) + 3 * Xe[4 * k + 73 * b &511][1];
				
				b = K(this.joint[a][i][0].x, 0, 511)>>3; //Head's horizontal tile number
				c = K(this.joint[a][i][0].y, 0, 255)>>3; //Vertical
				if (I.$[b] >= c){ //Above ceiling (e.g. in a cavern level)
					this.joint[a][i][0].y += 0.1 * ((I.$[b]<<3) + 8 - this.joint[a][i][0].y); //Stay below ceiling
				}
				else if (I.I[b] <= c && I.I[b] < I.o[b]){ //Below ground that is not the floor
					this.joint[a][i][0].y += 0.05 * ((I.o[b]<<3) - this.joint[a][i][0].y); //Float closer to the floor
				}
				break;
			case 7: //Fused Dragon
				c = this.getSpeciesMember(a, this.species[a][i], 1); //Head's slot
				Y(this.joint[a][c][0], this.joint[a][i][0], 0, 0, 1);
				
				switch (b){
					case 0: //Main body
						for (j=0; j<8; j++){
							Y(this.joint[a][i][j], this.joint[a][i][j+1], 8, 0, 0.5); //Connect main body joints
						}
						b = K(this.joint[a][i][0].x, 0, 511)>>3; //Head's horizontal tile number
						c = K(this.joint[a][i][0].y, 0, 255)>>3; //Vertical
						if (I.$[b] >= c){ //Above ceiling (e.g. in a cavern level)
							this.joint[a][i][0].y += 0.2 * ((I.$[b]<<3) + 8 - this.joint[a][i][0].y); //Stay below ceiling
						}
						else if (I.I[b] <= c && I.I[b] < I.o[b]){ //Below ground that is not the floor
							this.joint[a][i][0].y += 0.1 * ((I.o[b]<<3) - this.joint[a][i][0].y); //Float closer to the floor
						}
						break;
					case 1: //Wings
						for (j=0; j<2; j++){ //2 sets
							Y(this.joint[a][c][2+3*j], this.joint[a][i][1+j], 10, 0, 0.5);		//Body to left wing's top corner
							Y(this.joint[a][c][2+3*j], this.joint[a][i][3+j], 20, 0, 0.5);		//Body to left wing's bottom corner
							Y(this.joint[a][i][1+j], this.joint[a][i][3+j], 15, 0.1, 0.1);		//Left wing's top corner to bottom corner
							Y(this.joint[a][c][2+3*j], this.joint[a][i][5+j], 10, 0, 0.5);		//Body to right wing's top corner
							Y(this.joint[a][c][2+3*j], this.joint[a][i][7+j], 20, 0, 0.5);		//Body to right wing's bottom corner
							Y(this.joint[a][i][5+j], this.joint[a][i][7+j], 15, 0.1, 0.1);		//Right wing's top corner to bottom corner
							
							this.joint[a][i][1+j].x += -2;		//Left wing's top corner
							this.joint[a][i][1+j].y += -2;
							
							this.joint[a][i][3+j].x += -1;		//Left wing's bottom corner
							this.joint[a][i][3+j].y += -1;
							
							this.joint[a][i][5+j].x += 2;		//Right wing's top corner
							this.joint[a][i][5+j].y += -2;
							
							this.joint[a][i][7+j].x += 1;		//Right wing's bottom corner
							this.joint[a][i][7+j].y += -1;
						}
						break;
					case 2: //Limbs
						for (j=1; j<5; j++){ //4 limbs with 2 joints
							Y(this.joint[a][c][2+3*(j%2)], this.joint[a][i][j], 8, 0, 0.5); //Front limbs 2 6, 4 8; Back limbs 1 5, 3 7
							Y(this.joint[a][i][j], this.joint[a][i][4+j], 5, 0, 0.5);
							this.joint[a][i][j].x += (-1)**(j%3) * 0.5; //Arm gravity and positioning
							this.joint[a][i][j].y += 1;
							this.joint[a][i][4+j].x += (-1)**(j%3);
							this.joint[a][i][4+j].y += 2;
						}
						break;
					case 3: //Front claws
					case 4: //Back claws
						c = this.getSpeciesMember(a, this.species[a][i], 3); // Limbs' slot
						for (j=1; j<5; j++){ //4 claws with 2 joints
							Y(this.joint[a][c][9 - b + 2 * (j%2)], this.joint[a][i][j], 2, 0, 1); //First hand claws 1 5, 3 7; Second hand claws 2 6, 4 8
							Y(this.joint[a][i][j], this.joint[a][i][4+j], 3, 0, 1);
							this.joint[a][i][j].x += 2*(-1)**(j%3); //Claw gravity and position
							this.joint[a][i][j].y += 2;
							this.joint[a][i][4+j].x += (-1)**(j%3) * 0.5;
							this.joint[a][i][4+j].y += 3;
						}
						break;
					case 5: //Spines 1
					case 6: //Spines 2
						for (j=1; j<8; j++){ //7 Spines
							Y(this.joint[a][c][j], this.joint[a][i][j], 2, 0, 0.5);
							this.joint[a][i][j].x += 5.5 - b;
							this.joint[a][i][j].y -= 1;
						}
				}
				this.joint[a][i][0].x += this.movementDetail[a][i] * 0.03 * (v.a[a][1].x - this.joint[a][i][0].x) + 4 * Xe[4*k &511][0];
				this.joint[a][i][0].y += this.movementDetail[a][i] * 0.03 * (v.a[a][1].y - 64 - this.joint[a][i][0].y) + 3 * Xe[8*k &511][1];
				break;
			case 6: //Hydra
				c = this.getSpeciesMember(a, this.species[a][i], 1); //Body's slot
				Y(this.joint[a][i][0], this.joint[a][i][1], 5, 0.5, 0.5);	//Head to neck joint 1
				Y(this.joint[a][i][1], this.joint[a][i][2], 5, 0.5, 0.5);	//Neck joint 1 to neck joint 2
				Y(this.joint[a][i][2], this.joint[a][c][3], 5, 0.5, 0);		//Neck to body
				Y(this.joint[a][i][0], this.joint[a][i][8], 25, 0.05, 0.1);	//Invisible joint to pull the head smoothly
				
				this.joint[a][i][0].x += this.movementDetail[a][i] * 0.1 * (v.a[a][1].x - this.joint[a][i][0].x) + b * (-1)**b + 2 * Xe[4*k&511][0];
				this.joint[a][i][0].y += 0.1 * (this.joint[a][c][3].y - 40 - this.joint[a][i][0].y);
				
				switch(b){
					case 0: //Body and wings
						this.joint[a][i][3].x += this.movementDetail[a][i] * 0.03 * (v.a[a][1].x - this.joint[a][i][3].x) + Xe[4*k&511][0];
						this.joint[a][i][3].y += this.movementDetail[a][i] * 0.03 * (v.a[a][1].y - 40 - this.joint[a][i][3].y) + 2 * Xe[8*k&511][1];
						
						Y(this.joint[a][i][3], this.joint[a][i][4], 5, 0, 0.5);		//Body to left wing's top corner
						Y(this.joint[a][i][3], this.joint[a][i][5], 20, 0, 0.5);	//Body to left wing's bottom corner
						Y(this.joint[a][i][4], this.joint[a][i][5], 10, 0.1, 0.1);	//Left wing's top corner to bottom corner
						Y(this.joint[a][i][3], this.joint[a][i][6], 5, 0, 0.5);		//Body to right wing's top corner
						Y(this.joint[a][i][3], this.joint[a][i][7], 20, 0, 0.5);	//Body to right wing's bottom corner
						Y(this.joint[a][i][6], this.joint[a][i][7], 10, 0.1, 0.1);	//Right wing's top corner to bottom corner
						
						this.joint[a][i][4].x += -2;	//Left wing's top corner
						this.joint[a][i][4].y += -2;
						
						this.joint[a][i][5].x += -2;	//Left wing's bottom corner
						this.joint[a][i][5].y += 1;
						
						this.joint[a][i][6].x += 2;		//Right wing's top corner
						this.joint[a][i][6].y += -2;
						
						this.joint[a][i][7].x += 2;		//Right wing's bottom corner
						this.joint[a][i][7].y += 1;
						break;
					case 1: //Front limbs
					case 2: //Back limbs
						for (j=0; j<2; j++){ //2 limbs
							Y(this.joint[a][c][3], this.joint[a][i][3+j], 12-2*b, 0, 0.5);		//Limb 1: 3 5, Limb 2: 4 6
							Y(this.joint[a][i][3+j], this.joint[a][i][5+j], 10-2*b, 0, 0.5);
							this.joint[a][i][3+j].x += (3-b) * (-1)**j
							this.joint[a][i][3+j].y += 2;
							this.joint[a][i][5+j].y += 2;
						}
						break;
					case 3: //Tail
						Y(this.joint[a][c][3], this.joint[a][i][3], 3, 0, 1);
						Y(this.joint[a][i][3], this.joint[a][i][4], 3, 0.5, 0.5);
						Y(this.joint[a][i][4], this.joint[a][i][5], 3, 0.5, 0.5);
						this.joint[a][i][5].y += 2;
						break;
					case 4: //Front claws
					case 5: //Back claws
						c = this.getSpeciesMember(a, this.species[a][i], b-2); //Limbs
						for (j=0; j<2; j++){ //2 claws
							Y(this.joint[a][c][5+j], this.joint[a][i][3+j], 3, 0, 1);
							Y(this.joint[a][c][5+j], this.joint[a][i][5+j], 3, 0, 1);
							this.joint[a][i][3+j].x += 2; //Claw gravity and position
							this.joint[a][i][3+j].y += 3;
							this.joint[a][i][5+j].x += -2;
							this.joint[a][i][5+j].y += 3;
						}
						break;
					case 6: //Tail spines
						c = this.getSpeciesMember(a, this.species[a][i], 4); //Tail
						for (j=0; j<2; j++){
							Y(this.joint[a][c][3], this.joint[a][i][3+j], 5, 0, 1);
							Y(this.joint[a][c][4], this.joint[a][i][5+j], 5, 0, 1);
							this.joint[a][i][3+j].x += (-1)**j * 0.5;
							this.joint[a][i][3+j].y += -1;
							this.joint[a][i][5+j].x += (-1)**j * 0.5;
							this.joint[a][i][5+j].y += -1;
						}
				}
				break;
			case 5: //Beholder
				Y(this.joint[a][i][1], this.joint[a][i][0], 0, 1, 0); //Pupil to head/eyeball
				this.joint[a][i][0].x += 0.03 * (v.a[a][1].x - this.joint[a][i][0].x) + 0.2 * b * (-1)**b;
				this.joint[a][i][0].y += 0.03 * (v.a[a][1].y - 40 - this.joint[a][i][0].y) + 0.5 * Xe[k + 73*b&511][1];
				this.joint[a][i][1].x = this.joint[a][i][0].x;
				this.joint[a][i][1].y = this.joint[a][i][0].y;
				for (j=0; j<3; j++){
					Y(this.joint[a][i][0], this.joint[a][i][j+2], 5, 0, 0.5); //Tentacles
					Y(this.joint[a][i][j+2], this.joint[a][i][j+5], 5, 0.5, 0.5);
					this.joint[a][i][j+2].x += 2*j - 2;
					this.joint[a][i][j+2].y += 2;
					this.joint[a][i][j+5].y += 2;
				}
				b = K(this.joint[a][i][0].x, 0, 511)>>3; //Head's horizontal tile number
				c = K(this.joint[a][i][0].y, 0, 255)>>3; //Vertical
				if (I.$[b] >= c){ //Above ceiling (e.g. in a cavern level)
					this.joint[a][i][0].y += 0.1 * ((I.$[b]<<3) + 8 - this.joint[a][i][0].y); //Stay below ceiling
				}
				else if (I.I[b] <= c && I.I[b] < I.o[b]){ //Below ground that is not the floor
					this.joint[a][i][0].y += 0.05 * ((I.o[b]<<3) - this.joint[a][i][0].y); //Float closer to the floor
				}
				break;
			case 4: //Fish
				for (j=0; j<4; j++){
					Y(this.joint[a][i][j], this.joint[a][i][j+1], 8, 0, 1); //Body
				}
				Y(this.joint[a][i][0], this.joint[a][i][6], 25, 0.05, 0.1); //Invisible joint to pull the body smoothly
				/*if (Kg(v.a[a][1].x - this.joint[a][i][0].x) > 24) */this.joint[a][i][0].x += this.movementDetail[a][i] * 0.05 * (v.a[a][1].x - this.joint[a][i][0].x);
				/*if (Kg(v.a[a][1].y - this.joint[a][i][0].y) > 24) */this.joint[a][i][0].y += this.movementDetail[a][i] * 0.05 * (v.a[a][1].y - this.joint[a][i][0].y);
				
				this.joint[a][i][0].x += 3 * Xe[k + 73*b&511][0];
				this.joint[a][i][0].y += 1 * Xe[k + 73*b&511][1];
				
				Y(this.joint[a][i][1], this.joint[a][i][5], 12, 0, 1); //Top fin
				Y(this.joint[a][i][2], this.joint[a][i][5], 8, 0, 1);
				this.joint[a][i][5].y -= 2;
				
				//Y(this.joint[a][i][1], this.joint[a][i][6], 10, 0, 1); //Bottom fin
				//Y(this.joint[a][i][2], this.joint[a][i][6], 6, 0, 1);
				//this.joint[a][i][6].y += 2;
				
				Y(this.joint[a][i][4], this.joint[a][i][7], 4, 0, 1); //Tail fin
				Y(this.joint[a][i][4], this.joint[a][i][8], 4, 0, 1);
				Y(this.joint[a][i][3], this.joint[a][i][7], 16, 0, 1);
				Y(this.joint[a][i][3], this.joint[a][i][8], 16, 0, 1);
				
				this.joint[a][i][7].y -= 1;
				this.joint[a][i][8].y += 1;
				
				break;
			/*case 9: //Armor
				//Nothing for now
				break;*/
			case 10: //Primordial Spirit
				this.joint[a][i][0].x += 0.05 * (v.a[a][1].x - this.joint[a][i][0].x);
				this.joint[a][i][0].y += 0.05 * (v.a[a][1].y - 32 - this.joint[a][i][0].y) - 0.5 * Xe[k &511][1];
				this.joint[a][i][0].x += 0.1 * Xe[k + 73*b&511][0];
				this.joint[a][i][0].y += 0.1 * Xe[k + 73*b&511][1];
				for (j=1; j<6; j++){
					this.joint[a][i][j].x += (this.joint[a][i][0].x - this.joint[a][i][j].x) + 10 * Xe[3 * (3 * k + 73 * j) + 73 * b &511][0]
					this.joint[a][i][j].y += (this.joint[a][i][0].y - this.joint[a][i][j].y) + 10 * Xe[9 * k + 73 * j + 73 * b &511][1];
				}
				if (I.$[b] >= c){ //Above ceiling (e.g. in a cavern level)
					this.joint[a][i][0].y += 0.1 * ((I.$[b]<<3) + 8 - this.joint[a][i][0].y); //Stay below ceiling
				}
				else if (I.I[b] <= c && I.I[b] < I.o[b]){ //Below ground that is not the floor
					this.joint[a][i][0].y += 0.05 * ((I.o[b]<<3) - this.joint[a][i][0].y); //Float closer to the floor
				}
				break;
		}
	}
}

summon.prototype.draw = function(a){
	var b, c, d, k;
	for (i=swarm[a]-1; i>-1; i--){
		if (this.species[a][i] == -1) continue; //Skip if not spawned
		c = w(this.weaponID[a][i], Sc);
		k = 0;
		for (j=0; j<i; j++)
			if (this.species[a][j] == this.species[a][i]) k += 1; //Number of this species before this slot
		
		if (this.species[a][i] != 6 && this.species[a][i] != 7) c = c | (0x111111 * k); //Slight color change depending on summon number (If species is not Fused Dragon or Hydra)
		b = ((c & 0xFF0000) >> 17 << 16 | (c & 0x00FF00) >> 9 << 8 | (c & 0x0000FF) >> 1); //Darkened color
		switch (this.species[a][i]){
			case 2:	//Bird
				L(this.joint[a][i][0].x, this.joint[a][i][0].y, this.joint[a][i][1].x, this.joint[a][i][1].y, b); //Wings
				L(this.joint[a][i][0].x, this.joint[a][i][0].y, this.joint[a][i][2].x, this.joint[a][i][2].y, b);
				L(this.joint[a][i][1].x, this.joint[a][i][1].y, this.joint[a][i][2].x, this.joint[a][i][2].y, b);
				L(this.joint[a][i][0].x, this.joint[a][i][0].y, this.joint[a][i][3].x, this.joint[a][i][3].y, b);
				L(this.joint[a][i][0].x, this.joint[a][i][0].y, this.joint[a][i][4].x, this.joint[a][i][4].y, b);
				L(this.joint[a][i][3].x, this.joint[a][i][3].y, this.joint[a][i][4].x, this.joint[a][i][4].y, b);
				V(z(this.joint[a][i][0].x) - 1, z(this.joint[a][i][0].y) - 1, 4, 4, c); //Body
				//V(z(this.joint[a][i][5].x) - 1, z(this.joint[a][i][5].y) - 1, 4, 4, c); //Invisible joint
				break;
			case 1: //Snake
				for (j=1; j<5; j++) (V(z(this.joint[a][i][j].x) - 1, z(this.joint[a][i][j].y) - 1, 6 - j, 6 - j, b)) //Tail segments using the darkened color
				V(z(this.joint[a][i][0].x) - 1, z(this.joint[a][i][0].y) - 1, 6, 6, c) //Head
				//V(z(this.joint[a][i][5].x) - 1, z(this.joint[a][i][5].y) - 1, 4, 4, c); //Invisible joint
				break;
			case 0: //Melee Spider
			case 8: //Projectile Spider
				for (j=1; j<5; j++){
					L(this.joint[a][i][0].x, this.joint[a][i][0].y, this.joint[a][i][j].x, this.joint[a][i][j].y, b);			//Body to knees
					L(this.joint[a][i][j].x, this.joint[a][i][j].y, this.joint[a][i][j + 4].x, this.joint[a][i][j + 4].y, b);	//Knees to legs
					V(z(this.joint[a][i][j + 4].x) - 1, z(this.joint[a][i][j + 4].y) - 1, 2, 2, c); //Leg endpoints
				}
				V(z(this.joint[a][i][0].x) - 1, z(this.joint[a][i][0].y) - 1, 5, 5, c); //Head
				break;
			case 3: //Dragon
				for (j=0; j<4; j++){
					L(this.joint[a][i][j].x, this.joint[a][i][j].y, this.joint[a][i][j+1].x, this.joint[a][i][j+1].y, b);	//Main body lines
				}
				for (j=5; j<7; j++){
					L(this.joint[a][i][1].x, this.joint[a][i][1].y, this.joint[a][i][j].x, this.joint[a][i][j].y, b);		//Arms
					L(this.joint[a][i][j].x, this.joint[a][i][j].y, this.joint[a][i][j+2].x, this.joint[a][i][j+2].y, b);
					V(z(this.joint[a][i][j+2].x) - 0.6, z(this.joint[a][i][j+2].y) - 0.6, 3, 3, c); //Hands
				}
				V(z(this.joint[a][i][0].x) - 1, z(this.joint[a][i][0].y) - 1, 5, 5, c); //Head
				V(z(this.joint[a][i][4].x) - 0.6, z(this.joint[a][i][4].y) - 0.6, 3, 3, c); //Tail end
				break;
			case 7: //Fused Dragon
				d = this.getSpeciesMember(a, this.species[a][i], 1); //Head's slot
				switch (k){
					case 0: //Body
						for (j=0; j<8; j++){
							L(this.joint[a][i][j].x, this.joint[a][i][j].y, this.joint[a][i][j+1].x, this.joint[a][i][j+1].y, b); //Lines
						}
						V(z(this.joint[a][i][0].x) - 1, z(this.joint[a][i][0].y) - 1, 5, 5, c); //Head
						V(z(this.joint[a][i][8].x) - 0.6, z(this.joint[a][i][8].y) - 0.6, 3, 3, c); //Tail end
						break;
					case 1: //Wings
						for (j=0; j<2; j++){
							L(this.joint[a][d][2+3*j].x, this.joint[a][d][2+3*j].y, this.joint[a][i][1+j].x, this.joint[a][i][1+j].y, c);
							L(this.joint[a][d][2+3*j].x, this.joint[a][d][2+3*j].y, this.joint[a][i][3+j].x, this.joint[a][i][3+j].y, c);
							L(this.joint[a][i][1+j].x, this.joint[a][i][1+j].y, this.joint[a][i][3+j].x, this.joint[a][i][3+j].y, c);
							L(this.joint[a][d][2+3*j].x, this.joint[a][d][2+3*j].y, this.joint[a][i][5+j].x, this.joint[a][i][5+j].y, c);
							L(this.joint[a][d][2+3*j].x, this.joint[a][d][2+3*j].y, this.joint[a][i][7+j].x, this.joint[a][i][7+j].y, c);
							L(this.joint[a][i][5+j].x, this.joint[a][i][5+j].y, this.joint[a][i][7+j].x, this.joint[a][i][7+j].y, c);
						}
						break;
					case 2: //Limbs
						for (j=1; j<5; j++){
							L(this.joint[a][d][2+3*(j%2)].x, this.joint[a][d][2+3*(j%2)].y, this.joint[a][i][j].x, this.joint[a][i][j].y, b);
							L(this.joint[a][i][j].x, this.joint[a][i][j].y, this.joint[a][i][4+j].x, this.joint[a][i][4+j].y, b);
							V(z(this.joint[a][i][4+j].x) - 0.6, z(this.joint[a][i][4+j].y) - 0.6, 3, 3, c);
						}
						break;
					case 3: //Claws
					case 4:
						d = this.getSpeciesMember(a, this.species[a][i], 3); // Limbs' slot
						for (j=1; j<5; j++){
							L(this.joint[a][d][9-k+2*(j%2)].x, this.joint[a][d][9-k+2*(j%2)].y, this.joint[a][i][j].x, this.joint[a][i][j].y, c);
							L(this.joint[a][i][j].x, this.joint[a][i][j].y, this.joint[a][i][4+j].x, this.joint[a][i][4+j].y, c);
						}
						break;
					case 5: //Spines
					case 6:
						for (j=1; j<8; j++) L(this.joint[a][d][j].x, this.joint[a][d][j].y, this.joint[a][i][j].x, this.joint[a][i][j].y, c);
				}
				break;
			case 6: //Hydra
				d = this.getSpeciesMember(a, this.species[a][i], 1); //Body's slot
				
				L(this.joint[a][i][0].x, this.joint[a][i][0].y, this.joint[a][i][1].x, this.joint[a][i][1].y, b); //Necks
				L(this.joint[a][i][1].x, this.joint[a][i][1].y, this.joint[a][i][2].x, this.joint[a][i][2].y, b);
				L(this.joint[a][i][2].x, this.joint[a][i][2].y, this.joint[a][d][3].x, this.joint[a][d][3].y, b);
				V(z(this.joint[a][i][0].x) - 1, z(this.joint[a][i][0].y) - 1, 5, 5, c); //Heads
				
				switch(k){
					case 0: //Body and wings
						V(z(this.joint[a][i][3].x) - 3, z(this.joint[a][i][3].y) - 2, 8, 6, c);
						V(z(this.joint[a][i][3].x) - 2, z(this.joint[a][i][3].y) - 3, 6, 8, c);
						for (j=0; j<2; j++){
							L(this.joint[a][i][3].x, this.joint[a][i][3].y, this.joint[a][i][4+2*j].x, this.joint[a][i][4+2*j].y, c);
							L(this.joint[a][i][3].x, this.joint[a][i][3].y, this.joint[a][i][5+2*j].x, this.joint[a][i][5+2*j].y, c);
							L(this.joint[a][i][4+2*j].x, this.joint[a][i][4+2*j].y, this.joint[a][i][5+2*j].x, this.joint[a][i][5+2*j].y, c);
						}
						break;
					case 1: //Limbs
					case 2:
						for (j=0; j<2; j++){
							L(this.joint[a][d][3].x, this.joint[a][d][3].y, this.joint[a][i][3+j].x, this.joint[a][i][3+j].y, b);
							L(this.joint[a][i][3+j].x, this.joint[a][i][3+j].y, this.joint[a][i][5+j].x, this.joint[a][i][5+j].y, b);
							V(z(this.joint[a][i][5+j].x) - 1, z(this.joint[a][i][5+j].y) - 1, 3, 3, c);
						}
						break;
					case 3: //Tail
						for (j=0; j<3; j++){
							V(z(this.joint[a][i][3+j].x) - 1, z(this.joint[a][i][3+j].y) - 1, 5-j, 5-j, b);
						}
						break;
					case 4: //Claws
					case 5:
						d = this.getSpeciesMember(a, this.species[a][i], k-2); //Limbs
						for (j=0; j<2; j++){
							L(this.joint[a][d][5+j].x, this.joint[a][d][5+j].y, this.joint[a][i][3+j].x, this.joint[a][i][3+j].y, c);
							L(this.joint[a][d][5+j].x, this.joint[a][d][5+j].y, this.joint[a][i][5+j].x, this.joint[a][i][5+j].y, c);
						}
						break;
					case 6: //Tail spines
						d = this.getSpeciesMember(a, this.species[a][i], 4); //Tail
						for (j=0; j<2; j++){
							L(this.joint[a][d][3].x, this.joint[a][d][3].y, this.joint[a][i][3+j].x, this.joint[a][i][3+j].y, c);
							L(this.joint[a][d][4].x, this.joint[a][d][4].y, this.joint[a][i][5+j].x, this.joint[a][i][5+j].y, c);
						}
				}
				//for (j=0; j<this.maxJoints; j++) V(z(this.joint[a][i][j].x), z(this.joint[a][i][j].y), 2, 2, 0xFFFFFF);
				break;
			case 5: //Beholder
				for (j=0; j<3; j++){
					L(this.joint[a][i][0].x, this.joint[a][i][0].y, this.joint[a][i][j+2].x, this.joint[a][i][j+2].y, b);
					L(this.joint[a][i][j+2].x, this.joint[a][i][j+2].y, this.joint[a][i][j+5].x, this.joint[a][i][j+5].y, b);
				}
				V(this.joint[a][i][0].x - 7, this.joint[a][i][0].y - 5, 15, 11, c);
				V(this.joint[a][i][0].x - 5, this.joint[a][i][0].y - 7, 11, 15, c);
				V(this.joint[a][i][0].x - 6, this.joint[a][i][0].y - 6, 13, 13, c);
				V(this.joint[a][i][0].x - 5, this.joint[a][i][0].y - 3, 11, 7, 0x000000);
				V(this.joint[a][i][0].x - 3, this.joint[a][i][0].y - 5, 7, 11, 0x000000);
				V(this.joint[a][i][0].x - 4, this.joint[a][i][0].y - 4, 9, 9, 0x000000);
				V(this.joint[a][i][1].x, this.joint[a][i][1].y, 2, 2, c);
				
				//for (j=0; j<this.maxJoints; j++) V(z(this.joint[a][i][j].x), z(this.joint[a][i][j].y), 2, 2, 0xFFFFFF);
				break;
			case 4: //Fish
				for (j=0; j<4; j++) L(this.joint[a][i][j].x, this.joint[a][i][j].y, this.joint[a][i][j+1].x, this.joint[a][i][j+1].y, b);
				L(this.joint[a][i][1].x, this.joint[a][i][1].y, this.joint[a][i][5].x, this.joint[a][i][5].y, c); //Top fin
				L(this.joint[a][i][2].x, this.joint[a][i][2].y, this.joint[a][i][5].x, this.joint[a][i][5].y, c);
				//L(this.joint[a][i][1].x, this.joint[a][i][1].y, this.joint[a][i][6].x, this.joint[a][i][6].y, c); //Bottom fin
				//L(this.joint[a][i][2].x, this.joint[a][i][2].y, this.joint[a][i][6].x, this.joint[a][i][6].y, c);
				L(this.joint[a][i][4].x, this.joint[a][i][4].y, this.joint[a][i][7].x, this.joint[a][i][7].y, c); //Tail fin
				L(this.joint[a][i][4].x, this.joint[a][i][4].y, this.joint[a][i][8].x, this.joint[a][i][8].y, c);
				L(this.joint[a][i][7].x, this.joint[a][i][7].y, this.joint[a][i][8].x, this.joint[a][i][8].y, c);
				
				V(this.joint[a][i][0].x-1, this.joint[a][i][0].y-1, 3, 3, c); //Body
				V(this.joint[a][i][1].x-2, this.joint[a][i][1].y-2, 5, 5, c);
				V(this.joint[a][i][2].x-2, this.joint[a][i][2].y-2, 5, 5, c);
				V(this.joint[a][i][3].x-1, this.joint[a][i][3].y-1, 3, 3, c);
				V(this.joint[a][i][4].x, this.joint[a][i][4].y, 2, 2, c);
				//for (j=0; j<this.maxJoints; j++) V(z(this.joint[a][i][j].x), z(this.joint[a][i][j].y), 2, 2, 0xFFFFFF);
				break;
			/*case 9: //Armor
				//Nothing for now
				break;*/
			case 10: //Primordial Spirit
				V(this.joint[a][i][0].x-1, this.joint[a][i][0].y-1, 5, 5, 0xFFFFFF);
				V(this.joint[a][i][1].x-1, this.joint[a][i][1].y-1, 3, 3, 0x0000FF);
				V(this.joint[a][i][2].x-1, this.joint[a][i][2].y-1, 3, 3, 0x00FFFF);
				V(this.joint[a][i][3].x-1, this.joint[a][i][3].y-1, 3, 3, 0x00FF00);
				V(this.joint[a][i][4].x-1, this.joint[a][i][4].y-1, 3, 3, 0xFFFF00);
				V(this.joint[a][i][5].x-1, this.joint[a][i][5].y-1, 3, 3, 0xFF0000);
				break;
		}
	}
}

summon.prototype.attack = function(a){
	var b, c, d, e, k, helpVect = new Qg;
	
	for (i=0; i<swarm[a]; i++){
		if (this.species[a][i] == -1) continue; //Skip if not spawned
		if (this.reloadTicks[a][i] > 0) //Attack reload reduction
				(this.reloadTicks[a][i]--);
		b = (3 * v.a[a][0].x + this.joint[a][i][0].x) / 4; 	//Ranger's standing location's and summon's head's location's average (horizontal, weighted towards ranger)
		c = (v.a[a][9].y + v.a[a][10].y) / 2;
		d = this.range[a][i];	//Summon's range
		e = this.minAGI[a][i] + $g(this.maxAGI[a][i] - this.minAGI[a][i] + 1);
		b = G.m(b - d, c - d - 20, b + d, c + 20);		//Set target
		if (b != -1) { //Has a target
			switch (this.species[a][i]){
				case 2:	//Bird
					this.joint[a][i][0].x -= (G.a[b][0].x - this.joint[a][i][0].x) / (Kg(G.a[b][0].x - this.joint[a][i][0].x) + 1);	//Float away from target
					//this.joint[a][i][0].y -= 5 / K(G.a[b][0].y - this.joint[a][i][0].y, 1, 40);	//Float above target
					if (this.reloadTicks[a][i] == 0) {	//Ready to attack
						this.reloadTicks[a][i] = e;	//AGI
						this.focusJoint[a][i] = 0;	//Focus point
						this.joint[a][i][5].x += (G.a[b][0].x - this.joint[a][i][0].x) * 5;	//Invisible joint flings towards target
						this.joint[a][i][5].y += (G.a[b][0].y - this.joint[a][i][0].y) * 4;
						summonerHeals(a, i); //Heal's Card
					}
					break;
				case 1: //Snake
					this.movementDetail[a][i] = 0;
					//this.joint[a][i][0].x += 2 * signum(v.a[a][0].x - this.joint[a][i][0].x);		//Slither back to ranger
					if (this.reloadTicks[a][i] == 0) {
						this.reloadTicks[a][i] = e;	//AGI
						this.focusJoint[a][i] = 0;	//Focus point
						this.joint[a][i][5].x += (G.a[b][0].x - this.joint[a][i][0].x) * 4;	//Invisible joint flings towards target
						this.joint[a][i][5].y += K((G.a[b][0].y - 24 - this.joint[a][i][0].y)<<2, -240, 240); //Limited jumping power to keep from attacking high-flying enemies
						summonerHeals(a, i); //Heal's Card
					}
					break;
				case 0: //Melee Spider
				case 8: //Projectile Spider
					this.movementDetail[a][i] = 0;
					if (Kg(G.a[b][0].x - this.joint[a][i][0].x) >= 4)
						for (j=0; j<9; j++) this.joint[a][i][j].x += 2 * signum(G.a[b][0].x - this.joint[a][i][0].x); //All joints towards target
					if (this.reloadTicks[a][i] == 0) {
						this.reloadTicks[a][i] = e;	//AGI
						if (this.species[a][i] == 0) this.focusJoint[a][i] = 0;	//Focus point for melee spider
						if (this.species[a][i] == 8) this.projectileAttack(a, i, this.joint[a][i][0].x, this.joint[a][i][0].y, b); //Projectile shoot for projectile spider
						summonerHeals(a, i); //Heal's Card
					}
					break;
				case 3: //Dragon
				case 7: //Fused Dragon
					this.movementDetail[a][i] = 0;
					this.joint[a][i][0].x += 0.03 * (G.a[b][0].x - this.joint[a][i][0].x);
					this.joint[a][i][0].y += 0.03 * (G.a[b][0].y - 80 - this.joint[a][i][0].y);
					if (this.reloadTicks[a][i] == 0) {
						this.reloadTicks[a][i] = e;	//AGI
						this.projectileAttack(a, i, this.joint[a][i][0].x, this.joint[a][i][0].y, b); //Projectile shoot
						summonerHeals(a, i); //Heal's Card
					}
					break;
				case 6: //Hydra
					this.movementDetail[a][i] = 0;
					d = this.getSpeciesMember(a, this.species[a][i], 1);
					if (i == d && Kg(G.a[b][0].x - this.joint[a][d][3].x) >= 24) this.joint[a][d][3].x += 0.03 * (G.a[b][0].x - this.joint[a][d][3].x);
					if (i == d && Kg(G.a[b][0].y - this.joint[a][d][3].y) >= 24) this.joint[a][d][3].y += 0.03 * (G.a[b][0].y - this.joint[a][d][3].y);
					
					if (this.reloadTicks[a][i] == 0 && Kg(G.a[b][0].x - this.joint[a][d][3].x) <= 32 && Kg(G.a[b][0].y - this.joint[a][d][3].y) <= 32) {
						this.reloadTicks[a][i] = e;	//AGI
						this.focusJoint[a][i] = 0;	//Focus point
						this.joint[a][i][8].x += (G.a[b][0].x - this.joint[a][i][0].x) * 10;
						this.joint[a][i][8].y += (G.a[b][0].y - this.joint[a][i][0].y) * 10;
						summonerHeals(a, i); //Heal's Card
					}
					break;
				case 5: //Beholder
					helpVect.x = G.a[b][0].x - this.joint[a][i][0].x;
					helpVect.y = G.a[b][0].y - this.joint[a][i][0].y;
					Xg(helpVect); //Normalize
					this.joint[a][i][1].x += helpVect.x; //Pupil looks at target
					this.joint[a][i][1].y += helpVect.y;
					if (this.reloadTicks[a][i] == 0) {
						this.reloadTicks[a][i] = e;	//AGI
						this.projectileAttack(a, i, this.joint[a][i][1].x, this.joint[a][i][1].y, b); //Projectile shoot
						summonerHeals(a, i); //Heal's Card
					}
					break;
				case 4: //Fish
					this.movementDetail[a][i] = 0;
					this.joint[a][i][0].x -= 0.5 * signum(G.a[b][0].x - this.joint[a][i][0].x);
					this.joint[a][i][0].y -= 0.5 * signum(G.a[b][0].y - this.joint[a][i][0].y);
					if (this.reloadTicks[a][i] == 0) {
						this.reloadTicks[a][i] = e;	//AGI
						this.focusJoint[a][i] = 0;	//Focus point
						this.joint[a][i][6].x += (G.a[b][0].x - this.joint[a][i][0].x) * 5;	//Invisible joint flings towards target
						this.joint[a][i][6].y += (G.a[b][0].y - this.joint[a][i][0].y) * 5;
						summonerHeals(a, i); //Heal's Card
					}
					break;
				case 9: //Armor
					if (this.reloadTicks[a][i] == 0) {
						this.reloadTicks[a][i] = e;	//AGI
						for (j=0; j<swarm[a]; j++){
							if (this.species[a][j] != -1 && this.species[a][j] != 9){ //j is summoned and not armor
								this.projectileAttack(a, i, this.joint[a][j][0].x, this.joint[a][j][0].y, b); //Projectile from j's main joint
							}
						}
					}
					break;
				case 10: //Primordial Spirit
					if (this.reloadTicks[a][i] == 0) {
						this.reloadTicks[a][i] = e;	//AGI
						this.projectileAttack(a, i, this.joint[a][i][0].x, this.joint[a][i][0].y, b); //Projectile shoot
						summonerHeals(a, i); //Heal's Card
						changeSpiritType(this.weaponID[a][i]); //Change elemental type
					}
					break;
			}
			continue;
		}
		this.movementDetail[a][i] = 1; //If summon i doesn't have a target, set movementDetail to default and allow ranger to walk/swim
		k = -1;
	}
	if (k == -1) 
		Yg(v, a),
		Zg(v, a);
}

summon.prototype.attackHit = function(a){
	var b, c, d, g = new Qg;
	
	for (i=0; i<swarm[a]; i++){
		if (this.species[a][i] == -1) continue; //Skip if not spawned
		var e;
		b = this.minAT[a][i];
		c = this.maxAT[a][i];
		d = w(this.weaponID[a][i], 9); //Splash damage
		
		if (this.focusJoint[a][i] != -1){ //The currently attacking summon has a focus point
			switch (this.species[a][i]){
				case 0: //Melee summons
				case 1:
				case 2:
				case 4:
				case 6:
					if (checkSummonCompos(a, i, Od) && A(100) < getSummonCompoEffect(a, i, t)){ //Critical's card
						b += z(y(s + a, id) * b / 100);
						c += z(y(s + a, id) * c / 100);
					}
					if (checkSummonCompos(a, i, Md) && A(100) < getSummonCompoEffect(a, i, t)) //Explosion's card
						d = 1;
					//Detect attack hit
					e = G.K(d, 0, 0, b, c, this.joint[a][i][this.focusJoint[a][i]].x, this.joint[a][i][this.focusJoint[a][i]].y, 8, 8);
					if (e != -1) {	//Attack hits
						b = w(this.weaponID[a][i], bd); 	//Weapon MP cost
						if (b > this.MP[a][i] + this.MAG[a][i] + z(Cc[a] / 4))	//Does attack fill MP
							this.MP[a][i] += this.MAG[a][i] + z(Cc[a] / 4);	//If not, add MAG to MP bar
						else this.MP[a][i] = b;
						if (this.MP[a][i] == b && 0 < b || -1 == b) { //MP bar is full or bonus attack is free
							this.MP[a][i] = 0; //Reset MP bar
							b = this.joint[a][i][this.focusJoint[a][i]].y;						//Focus point's y coord
							c = z(K(this.joint[a][i][this.focusJoint[a][i]].x, 0, 511) / 8);	//Focus point's horizontal tile
							d = z(K(this.joint[a][i][this.focusJoint[a][i]].y, 0, 255) / 8);	//Vertical tile
							if (d - I.o[c] >= 0)			//Spawn the projectiles not inside the ground
								b = (I.o[c]<<3) + 7;
							else if (Kg(d - I.I[c]) <= 3)
								b = (I.I[c]<<3) + 7;
							this.projectileAttack(a, i, this.joint[a][i][this.focusJoint[a][i]].x, b, e); //Projectile shoot
						}
						this.focusJoint[a][i] = -1; //Unset focus point for the currently attacking summon
						
						if (checkSummonCompos(a, i, Zd) && A(100) < getSummonCompoEffect(a, i, t)) { //Knockback's card
							b = getSummonCompoEffect(a, i, id);
							g.q(G.a[e][0], this.joint[a][i][0]);
							Xg(g);
							Tg(g, 0.2 * b);
							Tg(g, ah[B[G.id[e]][bh]] / B[G.id[e]][ch]);
							G.c[e][0].sub(g);
						}
					}
					break;
			}
		}
	}
}

summon.prototype.projectileAttack = function(a/*ranger*/, i/*summon*/, attackFocPosX, attackFocPosY, target){ //Similar to player projectile function (Special thanks to Dire's Vanilla Translation for help with this)
	var enemyPosX, enemyPosY, pDir = new Qg,
		attackWeapon = this.weaponID[a][i],
		attackMode = w(attackWeapon, 8) % 100,
		pAngle = z(w(attackWeapon, 8) / 100),
		pSpeed = w(attackWeapon, 13),
		pOrientation = w(attackWeapon, 17),
		pImage = w(attackWeapon, 18),
		pColor = w(attackWeapon, Zc),
		pOpacity = w(attackWeapon, 20),
		pWidth = w(attackWeapon, 21),
		pHeight = w(attackWeapon, 22),
		pHitboxWidth = w(attackWeapon, 23),
		pHitboxHeight = w(attackWeapon, 24),
		pAppearanceDelay = w(attackWeapon, 25),
		pEffectiveDelay = w(attackWeapon, 26),
		pLifespan = w(attackWeapon, 27),
		pDisappearDelay = w(attackWeapon, 28),
		pGravity = w(attackWeapon, 29),
		pAccel = w(attackWeapon, 30),
		pPierce = w(attackWeapon, 31),
		pBounce = w(attackWeapon, 32),
		pHome = w(attackWeapon, 33),
		pKnockback = 0,
		pSplash = w(attackWeapon, 9),
		pMinAT = this.minAT[a][i],
		pMaxAT = this.maxAT[a][i],
		pBullet = w(attackWeapon, Vc),
		pType = w(attackWeapon, $c),
		pTypeParam = w(attackWeapon, ad),
		resMode = w(attackWeapon, cd),
		resOrientation = w(attackWeapon, 42),
		resImage = w(attackWeapon, 43),
		resColor = w(attackWeapon, fd),
		resOpacity = w(attackWeapon, 45),
		resWidth = w(attackWeapon, 46),
		resHeight = w(attackWeapon, 47),
		resHitboxWidth = w(attackWeapon, 48),
		resHitboxHeight = w(attackWeapon, 49),
		resAppearanceDelay = w(attackWeapon, 50),
		resEffectiveDelay = w(attackWeapon, 51),
		resLifespan = w(attackWeapon, 52),
		resDisappearDelay = w(attackWeapon, 53),
		resGravity = w(attackWeapon, 54),
		resAccel = w(attackWeapon, 55),
		resPierce = w(attackWeapon, 56),
		resBounce = w(attackWeapon, 57),
		resSplash = w(attackWeapon, 38),
		minBAT = w(attackWeapon, dd),
		maxBAT = w(attackWeapon, ed),
		resBullet = w(attackWeapon, 41),
		bonusType = pType,
		bonusTypeParam = pTypeParam,
		attackerSpecies = this.species[a][i];
	switch (attackerSpecies){ //AT and BAT calculations
		//Melee summons
		case 0: //Spider (Melee)
		case 1: //Snake
		case 2: //Bird
		case 4: //Fish
		case 6: //Hydra
			pMinAT = w(attackWeapon, dd);
			pMaxAT = w(attackWeapon, ed);
			if (checkSummonCompos(a, i, yd)){ //Ruby
				pMinAT += getSummonCompoEffect(a, i, t);
				pMaxAT += getSummonCompoEffect(a, i, id);
			}
			if (checkSummonCompos(a, i, zd)) //Garnet
				pLifespan += getSummonCompoEffect(a, i, t);
			
			if (checkSummonCompos(a, i, Ad)){ //Sapphire
				pMinAT += getSummonCompoEffect(a, i, t);
				pMaxAT += getSummonCompoEffect(a, i, id);
			}
			if (checkSummonCompos(a, i, Bd)) //Aquamarine
				pTypeParam += getSummonCompoEffect(a, i, t);
			
			if (checkSummonCompos(a, i, Cd)){ //Topaz
				pMinAT += getSummonCompoEffect(a, i, t);
				pMaxAT += getSummonCompoEffect(a, i, id);
			}
			if (checkSummonCompos(a, i, Dd)){ //Emerald
				pMinAT += getSummonCompoEffect(a, i, t);
				pMaxAT += getSummonCompoEffect(a, i, id);
			}
			if (checkSummonCompos(a, i, Ed)) //Peridot
				pTypeParam += getSummonCompoEffect(a, i, t);
			
			if (checkSummonCompos(a, i, Fd)) //Diamond
				pTypeParam += getSummonCompoEffect(a, i, t);
			
			if (checkSummonCompos(a, i, compoHematite)) //Hematite
				pTypeParam += z(pTypeParam * getSummonCompoEffect(a, i, t) / 100);
			
			if (checkSummonCompos(a, i, compoCarnelian)) //Carnelian
				pTypeParam += getSummonCompoEffect(a, i, t);
			
			pMinAT += z(pMinAT * Ac[a] / 100); //AT aura
			pMaxAT += z(pMaxAT * Ac[a] / 100);
			break;
		//Projectile summons
		case 3: //Dragon
		case 5: //Beholder
		case 7: //Fused Dragon
		case 8: //Spider (Projectile)
		case 9: //Armor
		case 10: //Primordial Spirit
			if (pType == 4){ //Main projectile for poison weapons is physical
				pType = 0;
				pTypeParam = 0;
			}
			//For jewels, if Primordial Spirit, make sure the type is correct
			if (checkSummonCompos(a, i, yd) && (attackerSpecies != 10 || bonusType == 1)){ //Ruby
				minBAT += getSummonCompoEffect(a, i, t);
				maxBAT += getSummonCompoEffect(a, i, id);
			}
			if (checkSummonCompos(a, i, zd) && (attackerSpecies != 10 || bonusType == 1)){ //Garnet
				pLifespan += getSummonCompoEffect(a, i, t);
				resLifespan += getSummonCompoEffect(a, i, t);
			}
			if (checkSummonCompos(a, i, Ad) && (attackerSpecies != 10 || bonusType == 2)){ //Sapphire
				minBAT += getSummonCompoEffect(a, i, t);
				maxBAT += getSummonCompoEffect(a, i, id);
			}
			if (checkSummonCompos(a, i, Bd) && (attackerSpecies != 10 || bonusType == 2)){ //Aquamarine
				pTypeParam += getSummonCompoEffect(a, i, t);
				bonusTypeParam += getSummonCompoEffect(a, i, t);
			}
			if (checkSummonCompos(a, i, Cd) && (attackerSpecies != 10 || bonusType == 3)){ //Topaz
				minBAT += getSummonCompoEffect(a, i, t);
				maxBAT += getSummonCompoEffect(a, i, id);
			}
			if (checkSummonCompos(a, i, Dd) && (attackerSpecies != 10 || bonusType == 4)){ //Emerald
				minBAT += getSummonCompoEffect(a, i, t);
				maxBAT += getSummonCompoEffect(a, i, id);
			}
			if (checkSummonCompos(a, i, Ed) && (attackerSpecies != 10 || bonusType == 4)){ //Peridot
				bonusTypeParam += getSummonCompoEffect(a, i, t);
			}
			if (checkSummonCompos(a, i, Fd) && (attackerSpecies != 10 || bonusType == 5)){ //Diamond
				pTypeParam += getSummonCompoEffect(a, i, t);
				bonusTypeParam += getSummonCompoEffect(a, i, t);
			}
			if (checkSummonCompos(a, i, compoHematite) && (attackerSpecies != 10 || bonusType == 6)){ //Hematite
				pTypeParam += z(pTypeParam * getSummonCompoEffect(a, i, t) / 100);
				bonusTypeParam += z(bonusTypeParam * getSummonCompoEffect(a, i, t) / 100);
			}
			if (checkSummonCompos(a, i, compoCarnelian) && (attackerSpecies != 10 || bonusType == 7)){ //Carnelian
				pTypeParam += getSummonCompoEffect(a, i, t);
				bonusTypeParam += getSummonCompoEffect(a, i, t);
			}
			minBAT += z(minBAT * Ac[a] / 100); //AT aura
			maxBAT += z(maxBAT * Ac[a] / 100);
			
			if (checkSummonCompos(a, i, Jd))
				pPierce = 1;
			if (checkSummonCompos(a, i, Jd) || checkSummonCompos(a, i, $d))
				pHome += getSummonCompoEffect(a, i, t);
			break;
	}
	if (checkSummonCompos(a, i, Ld))
		pBullet += getSummonCompoEffect(a, i, t) + z(pBullet * getSummonCompoEffect(a, i, id) / 100);
	
	if (checkSummonCompos(a, i, $d))
		pBounce = 2;
	for (j = 0; j < 9; j++) { //Transmutations
		if (checkSummonCompos(a, i, compoPhysTr + j)) {
			var trDmgRatio = typeConversion(pType, j);
			pType = bonusType = j;
			pTypeParam = bonusTypeParam = getSummonCompoEffect(a, i, id);
			pMinAT = ig(1, z(pMinAT * trDmgRatio / 100));
			pMaxAT = ig(1, z(pMaxAT * trDmgRatio / 100));
			minBAT = ig(1, z(minBAT * trDmgRatio / 100));
			maxBAT = ig(1, z(maxBAT * trDmgRatio / 100));
			switch (j) {
				case 0:
					pMinAT += z(pMinAT * getSummonCompoEffect(a, i, id) / 100);
					pMaxAT += z(pMaxAT * getSummonCompoEffect(a, i, id) / 100);
					minBAT += z(minBAT * getSummonCompoEffect(a, i, id) / 100);
					maxBAT += z(maxBAT * getSummonCompoEffect(a, i, id) / 100);
					pColor = resColor = 0xFF9C9485;
					break;
				case 1:
					pColor = resColor = 0xAAFF6000;
					break;
				case 2:
					pColor = resColor = 0xBB77BBFF;
					break;
				case 3:
					pMaxAT += pMinAT - 1;
					pMinAT = 1;
					maxBAT += minBAT - 1;
					minBAT = 1;
					pColor = resColor = 0xAAFFFF51;
					break;
				case 4:
					pColor = resColor = 0xAA00FF00;
					break;
				case 5:
					pColor = resColor = 0xBBDFFFFF;
					break;
				case 6:
					pColor = resColor = 0xEE7000DF;
					break;
				case 7:
					pColor = resColor = 0xBBB70000;
					break;
				case 8:
					pColor = resColor = 0x88000000 | $g(16) * 0x110000 | $g(16) * 0x1100 | $g(16) * 0x11;
					break;
			}
		}
	}
	
	attackWeapon = 0;
	var pSpeedHorizontal, pSpeedVertical, attackPosX, attackPosY, pSpread, b;
	
	if (attackMode == 6) (enemyPosX = G.a[target][0].x, enemyPosY = G.a[target][0].y);
	else (enemyPosX = G.a[target][G.n].x, enemyPosY = G.a[target][G.n].y);
	
	switch (attackMode){ // Summon attack mode
        case 0: break;                                      // 0  none/melee mode (e.g. Mach Punch)

        case 1:                                             // 1  no movement (but can drop with gravity on)
            attackPosX = attackFocPosX + 10 * pDir.x;
            attackPosY = attackFocPosY + 10 * pDir.y;
            oe.add(
                attackWeapon,
                attackPosX,
                attackPosY,
                0,
                0,
                pOrientation,
                pImage,
                pColor,
                pOpacity,
                pWidth,
                pHeight,
                pHitboxWidth,
                pHitboxHeight,
                pAppearanceDelay,
                pEffectiveDelay,
                pLifespan,
                pDisappearDelay,
                pGravity,
                pAccel,
                pPierce,
                pBounce,
                pHome,
                pKnockback,
                pSplash,
                pMinAT,
                pMaxAT,
                pType,
                pTypeParam,
                resMode,
                resOrientation,
                resImage,
                resColor,
                resOpacity,
                resWidth,
                resHeight,
                resHitboxWidth,
                resHitboxHeight,
                resAppearanceDelay,
                resEffectiveDelay,
                resLifespan,
                resDisappearDelay,
                resGravity,
                resAccel,
                resPierce,
                resBounce,
                resSplash,
                minBAT,
                maxBAT,
                resBullet,
                bonusType,
                bonusTypeParam
            );
            break;

        case 2:                                             // 2  horizontal
            pDir = (enemyPosX - attackFocPosX) / Kg(enemyPosX - attackFocPosX);
            attackPosX = attackFocPosX + 10 * pDir;
            attackPosY = attackFocPosY;
            pSpeedHorizontal = pDir * pSpeed * 0.1;
            for (var p=0; p<pBullet; p++){
                oe.add(
					attackWeapon,
					attackPosX,
					attackPosY,
					pSpeedHorizontal,
					0,
					pOrientation,
					pImage,
					pColor,
					pOpacity,
					pWidth,
					pHeight,
					pHitboxWidth,
					pHitboxHeight,
					pAppearanceDelay,
					pEffectiveDelay,
					pLifespan,
					pDisappearDelay,
					pGravity,
					pAccel,
					pPierce,
					pBounce,
					pHome,
					pKnockback,
					pSplash,
					pMinAT,
					pMaxAT,
					pType,
					pTypeParam,
					resMode,
					resOrientation,
					resImage,
					resColor,
					resOpacity,
					resWidth,
					resHeight,
					resHitboxWidth,
					resHitboxHeight,
					resAppearanceDelay,
					resEffectiveDelay,
					resLifespan,
					resDisappearDelay,
					resGravity,
					resAccel,
					resPierce,
					resBounce,
					resSplash,
					minBAT,
					maxBAT,
					resBullet,
					bonusType,
					bonusTypeParam
                );
            }
            break;

        case 3:                                             // 3  aimed straight line (X03 adjusts spread, X closer to 1 -> smaller spread. BUT 102403 = zero spread. X=16 if not specified)
            Rg(pDir, enemyPosX - attackFocPosX, enemyPosY - attackFocPosY);
            if (pAngle>0)
                 pSpread = pAngle;
            else pSpread = 16;
            pAngle = z(512 * Vg(pDir) / Wg) - ((pBullet - 1) * pSpread>>1);
            for (var p=0; p<pBullet; p++){
                pDir.x = Xe[pAngle & 511][0];
                pDir.y = -Xe[pAngle & 511][1];
                attackPosX = attackFocPosX + 10 * pDir.x;
                attackPosY = attackFocPosY + 10 * pDir.y;
                pSpeedHorizontal = pDir.x * pSpeed * 0.1;
                pSpeedVertical = pDir.y * pSpeed * 0.1;
                oe.add(
					attackWeapon,
					attackPosX,
					attackPosY,
					pSpeedHorizontal,
					pSpeedVertical,
					pOrientation,
					pImage,
					pColor,
					pOpacity,
					pWidth,
					pHeight,
					pHitboxWidth,
					pHitboxHeight,
					pAppearanceDelay,
					pEffectiveDelay,
					pLifespan,
					pDisappearDelay,
					pGravity,
					pAccel,
					pPierce,
					pBounce,
					pHome,
					pKnockback,
					pSplash,
					pMinAT,
					pMaxAT,
					pType,
					pTypeParam,
					resMode,
					resOrientation,
					resImage,
					resColor,
					resOpacity,
					resWidth,
					resHeight,
					resHitboxWidth,
					resHitboxHeight,
					resAppearanceDelay,
					resEffectiveDelay,
					resLifespan,
					resDisappearDelay,
					resGravity,
					resAccel,
					resPierce,
					resBounce,
					resSplash,
					minBAT,
					maxBAT,
					resBullet,
					bonusType,
					bonusTypeParam
                );
                pAngle += pSpread;
            }
            break;

        case 4:                                             // 4  arc (X04 adjusts spread, X=1 -> zero spread. X=(4+Bullet count) if not specified. Speed is "frames taken to reach target position"? and must !=0)
            for (var p=0; p<pBullet; p++){
                Rg(pDir, enemyPosX - attackFocPosX, enemyPosY - attackFocPosY);
                if (pAngle>0)
                     pSpread = pAngle
                else pSpread = pBullet + 4;
                if (pBullet>1){
                    pSpeedHorizontal = z(A(512));
                    b = A(4) * pSpread;
                    pDir.x += Xe[pSpeedHorizontal][0] * b;
                    pDir.y += Xe[pSpeedHorizontal][1] * b;
                }
                attackPosX = attackFocPosX;
                attackPosY = attackFocPosY;
                pSpeedHorizontal = pDir.x / pSpeed;
                pSpeedVertical = (pDir.y - 0.5 * pSpeed * pSpeed * pGravity * 0.01) / pSpeed;
                oe.add(
					attackWeapon,
					attackPosX,
					attackPosY,
					pSpeedHorizontal,
					pSpeedVertical,
					pOrientation,
					pImage,
					pColor,
					pOpacity,
					pWidth,
					pHeight,
					pHitboxWidth,
					pHitboxHeight,
					pAppearanceDelay,
					pEffectiveDelay,
					pLifespan,
					pDisappearDelay,
					pGravity,
					pAccel,
					pPierce,
					pBounce,
					pHome,
					pKnockback,
					pSplash,
					pMinAT,
					pMaxAT,
					pType,
					pTypeParam,
					resMode,
					resOrientation,
					resImage,
					resColor,
					resOpacity,
					resWidth,
					resHeight,
					resHitboxWidth,
					resHitboxHeight,
					resAppearanceDelay,
					resEffectiveDelay,
					resLifespan,
					resDisappearDelay,
					resGravity,
					resAccel,
					resPierce,
					resBounce,
					resSplash,
					minBAT,
					maxBAT,
					resBullet,
					bonusType,
					bonusTypeParam
                );
            }
            break;

        case 5:                                             // 5  aimed from distance (e.g. Ice Bolt)
            for (var p=0; p<pBullet; p++){
                if (pAngle == 0){
                    attackPosX = attackFocPosX + N(-40,40);
                    attackPosY = attackFocPosY + N(-60,0);
                } else {
                    attackPosX = attackFocPosX + N(-10 * (pAngle - 1), 10 * (pAngle - 1));
                }
                attackPosY = attackFocPosY + N(-60,-50);
                Rg(pDir, enemyPosX - attackPosX, enemyPosY - attackPosY);
                Xg(pDir);
                Tg(pDir, pSpeed);
                oe.add(
					attackWeapon,
					attackPosX,
					attackPosY,
					pDir.x,
					pDir.y,
					pOrientation,
					pImage,
					pColor,
					pOpacity,
					pWidth,
					pHeight,
					pHitboxWidth,
					pHitboxHeight,
					pAppearanceDelay,
					pEffectiveDelay,
					pLifespan,
					pDisappearDelay,
					pGravity,
					pAccel,
					pPierce,
					pBounce,
					pHome,
					pKnockback,
					pSplash,
					pMinAT,
					pMaxAT,
					pType,
					pTypeParam,
					resMode,
					resOrientation,
					resImage,
					resColor,
					resOpacity,
					resWidth,
					resHeight,
					resHitboxWidth,
					resHitboxHeight,
					resAppearanceDelay,
					resEffectiveDelay,
					resLifespan,
					resDisappearDelay,
					resGravity,
					resAccel,
					resPierce,
					resBounce,
					resSplash,
					minBAT,
					maxBAT,
					resBullet,
					bonusType,
					bonusTypeParam
                );
            }
            break;

        case 6:                                             // 6  around enemy (speed 0 = on enemy, higher speed => greater projectile spread, projectile orientation must =0)
            for (var p=0; p<pBullet; p++){
                attackPosX = enemyPosX + N(-pSpeed, pSpeed);
                attackPosY = enemyPosY + N(-pSpeed, pSpeed);
                oe.add(
					attackWeapon,
					attackPosX,
					attackPosY,
					0,
					0,
					pOrientation,
					pImage,
					pColor,
					pOpacity,
					pWidth,
					pHeight,
					pHitboxWidth,
					pHitboxHeight,
					pAppearanceDelay,
					pEffectiveDelay,
					pLifespan,
					pDisappearDelay,
					pGravity,
					pAccel,
					pPierce,
					pBounce,
					pHome,
					pKnockback,
					pSplash,
					pMinAT,
					pMaxAT,
					pType,
					pTypeParam,
					resMode,
					resOrientation,
					resImage,
					resColor,
					resOpacity,
					resWidth,
					resHeight,
					resHitboxWidth,
					resHitboxHeight,
					resAppearanceDelay,
					resEffectiveDelay,
					resLifespan,
					resDisappearDelay,
					resGravity,
					resAccel,
					resPierce,
					resBounce,
					resSplash,
					minBAT,
					maxBAT,
					resBullet,
					bonusType,
					bonusTypeParam
                );
            }
            break;

        case 7:                                           	// 7  lightsaber like (outward) (Sword only?)
        case 10:                                            // 10  thunder sabel like (inward?) (Sword only)
            pDir.x = attackFocPosX - this.joint[a][i][0].x;
            pDir.y = attackFocPosY - this.joint[a][i][0].y;
            if (attackMode == 10 && pDir.y>0)
                pDir.y = -pDir.y;
            attackPosX = this.joint[a][i][0].x + (pDir.x>>1);
            attackPosY = this.joint[a][i][0].y + (pDir.y>>1);
            Xg(pDir);
            Tg(pDir, 0.1 * pSpeed);
            for (var p=0; p<pBullet; p++){
                oe.add(
					attackWeapon,
					attackPosX,
					attackPosY,
					pDir.x,
					pDir.y,
					pOrientation,
					pImage,
					pColor,
					pOpacity,
					pWidth,
					pHeight,
					pHitboxWidth,
					pHitboxHeight,
					pAppearanceDelay,
					pEffectiveDelay,
					pLifespan,
					pDisappearDelay,
					pGravity,
					pAccel,
					pPierce,
					pBounce,
					pHome,
					pKnockback,
					pSplash,
					pMinAT,
					pMaxAT,
					pType,
					pTypeParam,
					resMode,
					resOrientation,
					resImage,
					resColor,
					resOpacity,
					resWidth,
					resHeight,
					resHitboxWidth,
					resHitboxHeight,
					resAppearanceDelay,
					resEffectiveDelay,
					resLifespan,
					resDisappearDelay,
					resGravity,
					resAccel,
					resPierce,
					resBounce,
					resSplash,
					minBAT,
					maxBAT,
					resBullet,
					bonusType,
					bonusTypeParam
                );
            }
            break;

        case 12:                                            // 12 unused, looks like 2?
            pDir = attackFocPosX - this.joint[a][i][0].x;
			pDir /= Kg(pDir);
            attackPosX = this.joint[a][i][0].x;
            attackPosY = this.joint[a][i][0].y;
            pSpeedHorizontal = pDir * pSpeed * 0.1;
            for (var p=0; p<pBullet; p++){
                oe.add(
					attackWeapon,
					attackPosX,
					attackPosY,
					pSpeedHorizontal,
					0,
					pOrientation,
					pImage,
					pColor,
					pOpacity,
					pWidth,
					pHeight,
					pHitboxWidth,
					pHitboxHeight,
					pAppearanceDelay,
					pEffectiveDelay,
					pLifespan,
					pDisappearDelay,
					pGravity,
					pAccel,
					pPierce,
					pBounce,
					pHome,
					pKnockback,
					pSplash,
					pMinAT,
					pMaxAT,
					pType,
					pTypeParam,
					resMode,
					resOrientation,
					resImage,
					resColor,
					resOpacity,
					resWidth,
					resHeight,
					resHitboxWidth,
					resHitboxHeight,
					resAppearanceDelay,
					resEffectiveDelay,
					resLifespan,
					resDisappearDelay,
					resGravity,
					resAccel,
					resPierce,
					resBounce,
					resSplash,
					minBAT,
					maxBAT,
					resBullet,
					bonusType,
					bonusTypeParam
                );
            }
            break;

        case 8:                                             // 8  spawn around range (X08: horizontal range = 20(X-1) centered at target x-position, 108 = Thunder Spear like. X=5 if not specified)
            for (var p=0; p<pBullet; p++){
                if (pAngle==0)
                     attackPosX = enemyPosX + N(-40,40);
                else attackPosX = enemyPosX + N(-10 * (pAngle - 1), 10 * (pAngle - 1));
                attackPosY = enemyPosY + N(-30,-60);
                oe.add(
					attackWeapon,
					attackPosX,
					attackPosY,
					0,
					0,
					pOrientation,
					pImage,
					pColor,
					pOpacity,
					pWidth,
					pHeight,
					pHitboxWidth,
					pHitboxHeight,
					pAppearanceDelay,
					pEffectiveDelay,
					pLifespan,
					pDisappearDelay,
					pGravity,
					pAccel,
					pPierce,
					pBounce,
					pHome,
					pKnockback,
					pSplash,
					pMinAT,
					pMaxAT,
					pType,
					pTypeParam,
					resMode,
					resOrientation,
					resImage,
					resColor,
					resOpacity,
					resWidth,
					resHeight,
					resHitboxWidth,
					resHitboxHeight,
					resAppearanceDelay,
					resEffectiveDelay,
					resLifespan,
					resDisappearDelay,
					resGravity,
					resAccel,
					resPierce,
					resBounce,
					resSplash,
					minBAT,
					maxBAT,
					resBullet,
					bonusType,
					bonusTypeParam
                );
            }
            break;

        case 9:                                             // 9  ring formation (9 = on enemy, 109 = on attacker, 1 projectile = random direction projectile)
            if (pAngle == 0){
                attackPosX = enemyPosX;
                attackPosY = enemyPosY;
            } else {
                attackPosX = attackFocPosX;
                attackPosY = attackFocPosY;
            }
            b = z(512 / pBullet);
            pSpeedHorizontal = z(A(b));
            for (var p=0; p<pBullet; p++){
                pDir.x = Xe[pSpeedHorizontal][0] * pSpeed;
                pDir.y = Xe[pSpeedHorizontal][1] * pSpeed;
                oe.add(
					attackWeapon,
					attackPosX,
					attackPosY,
					pDir.x,
					pDir.y,
					pOrientation,
					pImage,
					pColor,
					pOpacity,
					pWidth,
					pHeight,
					pHitboxWidth,
					pHitboxHeight,
					pAppearanceDelay,
					pEffectiveDelay,
					pLifespan,
					pDisappearDelay,
					pGravity,
					pAccel,
					pPierce,
					pBounce,
					pHome,
					pKnockback,
					pSplash,
					pMinAT,
					pMaxAT,
					pType,
					pTypeParam,
					resMode,
					resOrientation,
					resImage,
					resColor,
					resOpacity,
					resWidth,
					resHeight,
					resHitboxWidth,
					resHitboxHeight,
					resAppearanceDelay,
					resEffectiveDelay,
					resLifespan,
					resDisappearDelay,
					resGravity,
					resAccel,
					resPierce,
					resBounce,
					resSplash,
					minBAT,
					maxBAT,
					resBullet,
					bonusType,
					bonusTypeParam
                );
                pSpeedHorizontal += b;
            }
            break;

        case 11:                                            // 11 thunder ring like (X11 adjusts spread, X=0 if not specified)
            Rg(pDir, enemyPosX - attackFocPosX, enemyPosY - attackFocPosY);
            b = Xg(pDir);
            if (pAngle>0)
                 pSpread = pAngle;
            else pSpread = 0;
            for (var p=0; p<pBullet; p++){
                pSpeedHorizontal = N(-pSpread, pSpread);
                attackPosX = attackFocPosX + pDir.x * b / 2 + pDir.y * pSpeedHorizontal;
                attackPosY = attackFocPosY + pDir.y * b / 2 - pDir.x * pSpeedHorizontal;
                pSpeedHorizontal = pSpeed * (p + 1) / pBullet * pDir.x;
                pSpeedVertical = pSpeed * (p + 1) / pBullet * pDir.y;
                oe.add(
					attackWeapon,
					attackPosX,
					attackPosY,
					pSpeedHorizontal,
					pSpeedVertical,
					pOrientation,
					pImage,
					pColor,
					pOpacity,
					pWidth,
					pHeight,
					pHitboxWidth,
					pHitboxHeight,
					pAppearanceDelay,
					pEffectiveDelay,
					pLifespan,
					pDisappearDelay,
					pGravity,
					pAccel,
					pPierce,
					pBounce,
					pHome,
					pKnockback,
					pSplash,
					pMinAT,
					pMaxAT,
					pType,
					pTypeParam,
					resMode,
					resOrientation,
					resImage,
					resColor,
					resOpacity,
					resWidth,
					resHeight,
					resHitboxWidth,
					resHitboxHeight,
					resAppearanceDelay,
					resEffectiveDelay,
					resLifespan,
					resDisappearDelay,
					resGravity,
					resAccel,
					resPierce,
					resBounce,
					resSplash,
					minBAT,
					maxBAT,
					resBullet,
					bonusType,
					bonusTypeParam
                );
            }
            break;
    }
}

summon.prototype.applyAura = function(a){ //Updates the summons' AT values with the summoner's current AT aura
	for (i=0; i<swarm[a]; i++){
		if (this.species[a][i] == -1) continue; //Skip if not spawned
		this.minAT[a][i] = this.minATbase[a][i];
		this.maxAT[a][i] = this.maxATbase[a][i];
		this.minAT[a][i] += z(this.minAT[a][i] * Ac[a] / 100);
		this.maxAT[a][i] += z(this.maxAT[a][i] * Ac[a] / 100);
	}
}

summon.prototype.getSpeciesMember = function(rangerNumber, species, member){ //Returns the slot of the nth member (1,2,3,...) of this species (e.g. your first stickman (0) has Bird (0) summons in slots 0, 3, 5. getSpeciesMember(0, 0, 2) returns 3). Returns 0 also if there is no nth member.
	var b = -1,
		c = 0;
	while (c < member){
		b++;
		if (this.species[rangerNumber][b] == species) c++;
		if (b >= this.maxSummons) return 0; //If no nth member
	}
	return b;
}

//SUMMONER Some additional functions
var summonCompoSlot1 = false;
var summonCompoSlot2 = false;
function checkSummonCompos(rangerNumber, summonNumber, compoEff){ //Returns true if the summon has a compo with the effect compoEff
	summonCompoSlot1 = summonCompoSlot2 = false;
	
	if (w(summons.compoID1[rangerNumber][summonNumber], hd) == compoEff)
		summonCompoSlot1 = true;
	if (w(summons.compoID2[rangerNumber][summonNumber], hd) == compoEff)
		summonCompoSlot2 = true;
	
	if (summonCompoSlot1 || summonCompoSlot2)
		return true;
	return false;
}

function getSummonCompoEffect(rangerNumber, summonNumber, effectNumber){ //For use after checkSummonCompos. Returns the value of the compo's effectNumber effect (e.g. Crit chance or crit damage)
	var value = 0;
	
	if (summonCompoSlot1)
		value += w(summons.compoID1[rangerNumber][summonNumber], effectNumber);
	if (summonCompoSlot2)
		value += w(summons.compoID2[rangerNumber][summonNumber], effectNumber);
	
	return value;
}

function getDefenseCompoValues(rangerNumber, compoEff, effectNumber){ //Determines the power of defensive compos for summoner, depending on how many summons have the compo equipped (e.g. 1 out of 4 have White Stone 1 -> +12 LP)
	var value = 0, summonAmount = 0;
	for (i = 0; i < swarm[rangerNumber]; i++){
		if (summons.species[rangerNumber][i] != -1) {
			summonAmount++;
			if (checkSummonCompos(rangerNumber, i, compoEff)) value += getSummonCompoEffect(rangerNumber, i, effectNumber);
		}
	}
	if (summonAmount == 0) return 0;
	value = z(value / summonAmount);
	return value;
}

function checkSummonerCompoRestr(compoEff, species){ //Checks summoner weapon's species-specific compo restrictions.
	if (species == 0 || species == 1 || species == 2 || species == 4 || species == 6) //Melee summons
		if (compoEff == qd || compoEff == rd || compoEff == Md || compoEff == Od || compoEff == Zd) return true; //Red & Yellow Crystal, Explosion, Critical, Knockback
	if (species == 3 || species == 5 || species == 7 || species == 8 || species == 9 || species == 10) //Ranged summons
		if (compoEff == Jd || compoEff == Kd || compoEff == $d) return true; //Pierce, Guide, Reflection
	if (compoEff == Id) return true; //Catapult (All summons, aggro-range)
	return false;
}

function summonerHeals(a, i){ //Summoner's heal's card
	var b;
	if (checkSummonCompos(a, i, be)){ //Heal's Card
		b = getSummonCompoEffect(a, i, t);
		p[a] = K(p[a] + b, 0, kc[a]);
		ne.add(v.a[a][0].x, v.a[a][0].y, 0, b, 65280);
	}
}

function changeSpiritType(weapon){ //Changes weapon's type (for Primordial Spirit)
	//u[weapon][$c] = (w(weapon, $c)+1)%6; //Cyclic type change
	u[weapon][$c] = $g(6); //Or random type change
	switch (w(weapon, $c)){
		case 0: //Physical
			u[weapon][Tc] = 36; //min AT
			u[weapon][Uc] = 42; //max AT
			u[weapon][13] = 24; //proj speed
			u[weapon][17] = 1; //proj orientation
			u[weapon][18] = 17; //proj image
			u[weapon][Zc] = 0xFFBBBBBB; //proj col
			u[weapon][26] = 0; //delay before effective
			u[weapon][cd] = 3; //residue mode
			u[weapon][41] = 12; //residue count
			u[weapon][42] = 0; //residue orientation
			u[weapon][43] = 6; //residue image
			u[weapon][44] = 0x88988B83; //residue color
			u[weapon][51] = 100; //delay before residue effective
			u[weapon][dd] = 0; //min BAT
			u[weapon][ed] = 0; //max BAT
			break;
		case 1: //Fire
			u[weapon][Tc] = 20; //min AT
			u[weapon][Uc] = 24; //max AT
			u[weapon][13] = 64; //proj speed
			u[weapon][17] = 1; //proj orientation
			u[weapon][18] = 16; //proj image
			u[weapon][Zc] = 0xAAFF6000; //proj col
			u[weapon][26] = 0; //delay before effective
			u[weapon][ad] = 50; //type param
			u[weapon][cd] = 2; //residue mode
			u[weapon][41] = 10; //residue count
			u[weapon][42] = 1; //residue orientation
			u[weapon][43] = 24; //residue image
			u[weapon][44] = 0x88FF0000; //residue color
			u[weapon][51] = 0; //delay before residue effective
			u[weapon][dd] = 5; //min BAT
			u[weapon][ed] = 8; //max BAT
			break;
		case 2: //Ice
			u[weapon][Tc] = 30; //min AT
			u[weapon][Uc] = 36; //max AT
			u[weapon][13] = 64; //proj speed
			u[weapon][17] = 0; //proj orientation
			u[weapon][18] = 7; //proj image
			u[weapon][Zc] = 0xAA53D5FF; //proj col
			u[weapon][26] = 0; //delay before effective
			u[weapon][ad] = 35; //type param
			u[weapon][cd] = 7; //residue mode
			u[weapon][41] = 6; //residue count
			u[weapon][42] = 1; //residue orientation
			u[weapon][43] = 19; //residue image
			u[weapon][44] = 0x8853D5FF; //residue color
			u[weapon][51] = 5; //delay before residue effective
			u[weapon][dd] = 5; //min BAT
			u[weapon][ed] = 10; //max BAT
			break;
		case 3: //Thunder
			u[weapon][Tc] = 1; //min AT
			u[weapon][Uc] = 99; //max AT
			u[weapon][13] = 24; //proj speed
			u[weapon][17] = 1; //proj orientation
			u[weapon][18] = 10; //proj image
			u[weapon][Zc] = 0xAAFFFF00; //proj col
			u[weapon][26] = 0; //delay before effective
			u[weapon][cd] = 2; //residue mode
			u[weapon][41] = 25; //residue count
			u[weapon][42] = 1; //residue orientation
			u[weapon][43] = 20; //residue image
			u[weapon][44] = 0xAAFFFF00; //residue color
			u[weapon][51] = 0; //delay before residue effective
			u[weapon][dd] = 1; //min BAT
			u[weapon][ed] = 19; //max BAT
			break;
		case 4: //Poison
			u[weapon][Tc] = 0; //min AT
			u[weapon][Uc] = 0; //max AT
			u[weapon][13] = 64; //proj speed
			u[weapon][17] = 1; //proj orientation
			u[weapon][18] = 16; //proj image
			u[weapon][Zc] = 0xAA00FF00; //proj col
			u[weapon][26] = 1000; //delay before effective
			u[weapon][ad] = 100; //type param
			u[weapon][cd] = 2; //residue mode
			u[weapon][41] = 10; //residue count
			u[weapon][42] = 0; //residue orientation
			u[weapon][43] = 6; //residue image
			u[weapon][44] = 0x8800FF00; //residue color
			u[weapon][51] = 0; //delay before residue effective
			u[weapon][dd] = 5; //min BAT
			u[weapon][ed] = 6; //max BAT
			break;
		case 5: //Freeze
			u[weapon][Tc] = 30; //min AT
			u[weapon][Uc] = 36; //max AT
			u[weapon][13] = 64; //proj speed
			u[weapon][17] = 0; //proj orientation
			u[weapon][18] = 7; //proj image
			u[weapon][Zc] = 0xAAEEEEFF; //proj col
			u[weapon][26] = 0; //delay before effective
			u[weapon][ad] = 50; //type param
			u[weapon][cd] = 7; //residue mode
			u[weapon][41] = 6; //residue count
			u[weapon][42] = 1; //residue orientation
			u[weapon][43] = 4; //residue image
			u[weapon][44] = 0x88EEEEFF; //residue color
			u[weapon][51] = 5; //delay before residue effective
			u[weapon][dd] = 8; //min BAT
			u[weapon][ed] = 12; //max BAT
			break;
	}
}

function signum(value){ //Returns 1 for positive numbers, -1 for negative numbers, and 0 for 0.
	if (value > 0) return 1;
	else if (value < 0) return -1;
	else return 0;
}

var Pe = [0, 0, 5, 9, 14, 19, 23, 27, 31, 35, 39, 43, 47, 51, 56, 61, 66, 71, 71, 76, 80, 84, 84, 86],
	Qe = 0,
	bh = 1,
	ch = 3,
	lg = 6,
	//ELEMENT resistances
	pg = 35,
	qg = 36,
	rg = 37,
	sg = 38,
	tg = 39,
	ug = 40,
	gravityResistEn = 71,
	drainResistEn = 72,
	Re = 60,
	ng = 61,
	mg = 62,
	og = 63,
	B = [ //Enemy list
		//Plains 1
		[1,0,12,1,3455166,24158,30,2,1,19,2852192255,1,8,16,12,12,0,0,10,5,0,95,0,0,0,0,2,4,1,30,60,100,40,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,200,15,		14,30,18,30,16,30,130,60], //Cyan box walker
		[3,1,12,1,3521907,24095,40,3,1,9,4284546816,1,16,16,12,12,5,0,10,5,0,95,0,0,0,0,1,4,2,30,80,100,40,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,250,25,		21,20,23,20,20,20,128,40], //Green box snake
		[2,1,11,1,12530564,6160386,10,3,1,20,4294901766,1,12,12,8,8,0,0,10,5,0,95,0,0,0,0,1,2,1,30,30,100,40,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,100,5,		22,40,15,40,126,70], //Pink box snake
		[4,0,12,1,65344,33023,40,4,1,9,4278223103,1,16,16,8,8,30,10,180,10,5,100,0,0,0,0,2,3,3,100,90,100,80,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,250,25,		17,20,19,20,124,40,132,40], //Lime box walker
		[5,0,12,2,8445951,50200,500,3,1,9,4278223103,1,16,16,8,8,60,0,40,5,5,100,0,0,0,0,1,2,20,40,120,100,160,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,1000,100,	188,10,0,0,0,0], //Cyan boss box walker
		//Plains 2
		[5,1,23,1,16737792,11730944,50,3,1,3,4294927872,1,16,16,8,8,10,0,25,10,1,100,0,0,0,0,3,4,2,10,100,100,40,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,210,20,			24,30,105,30,134,60], //Orange plus snake
		[6,1,7,1,16776960,7067392,60,4,1,13,2868903680,1,16,16,8,8,30,10,60,10,10,100,0,0,0,0,2,3,4,60,120,200,60,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,250,25,		33,20,60,20,136,40], //Yellow roundhead snake
		[6,2,23,0.8,16711680,13369344,45,1,0,15,2865496064,1,24,24,20,20,0,0,90,10,10,100,0,1,0,0,5,6,1,1,60,80,80,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,230,30,		87,35,138,70,140,70], //Red plus bat
		[8,1,23,2,14290960,9054248,450,3,1,19,3724491008,1,16,24,20,20,30,0,60,10,5,99,0,2,0,0,4,10,3,10,120,60,60,0,0,3,10,-10,0,0,10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,750,100,	142,10,164,15,0,0], //Red boss plus snake
		//Plains 3
		[7,19,1,1,51712,32832,70,1,1,13,2859973631,2,16,16,8,8,0,5,60,10,5,100,0,1,0,0,6,8,1,1,30,50,80,0,0,0,10,-10,-10,25,-10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,250,30,					42,50,0,0,0,0], //Green smiley hopper
		[8,19,2,1,9591325,8388608,100,3,1,13,3716369187,2,16,16,8,8,10,5,60,10,5,100,0,1,0,0,3,6,3,10,60,90,90,0,0,-3,20,0,10,20,-10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,300,50,				34,20,0,0,0,0], //Brown smiley hopper
		[7,5,2,1,38144,8210967,80,4,1,19,2852164864,2,12,16,8,8,60,5,120,10,5,100,0,0,0,0,2,3,5,120,120,100,80,0,0,5,-20,-10,10,10,-10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,100,25,			78,20,0,0,0,0], //Green smiley tree
		[7,19,7,1,65280,32896,40,1,0,28,2852173751,2,16,16,12,12,0,0,10,10,0,100,0,0,0,0,3,3,1,1,10,50,60,0,0,-5,5,-10,-10,10,-10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,80,10,					51,50,0,0,0,0], //Lime roundhead hopper
		[9,19,2,2,8499991,4949026,800,4,0,2,3707811699,1,16,16,12,12,30,30,100,10,10,100,0,0,0,0,8,10,3,90,90,100,120,0,0,-5,10,-10,-10,10,20,4,0,13,2852173683,2,16,16,8,8,30,10,5,100,0,0,0,6,8,3,0,1200,200,	96,5,174,10,0,0], //Olive boss smiley hopper
		//Plains 4
		[8,1,23,1,6513799,3288199,120,3,0,14,4286488036,1,16,16,12,12,0,60,70,10,0,85,0,2,0,0,8,12,1,50,120,50,80,0,0,3,-10,0,10,0,0,0,0,0,0,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,150,40,				79,20,97,20,150,50], //Grey plus snake
		[9,1,23,1,14483456,6562852,150,3,1,5,2868859648,2,12,24,12,12,0,0,90,10,-2,100,1,0,0,0,3,4,3,15,90,100,80,1,100,0,10,-20,0,0,-20,0,0,0,0,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,180,50,			61,15,144,40,0,0], //Red plus snake
		[10,3,23,2,4623359,3435154,250,1,0,14,4278218728,1,32,32,24,24,0,10,15,10,0,100,1,0,0,0,8,10,1,1,10,100,50,0,0,5,-20,-10,0,0,-10,0,0,0,0,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,210,55,			25,10,152,25,0,0], //Blue plus dragon
		[9,0,3,1,6385067,2498411,160,4,0,2,4284703623,1,16,16,12,12,0,10,120,10,5,99,0,0,0,0,8,9,1,90,180,50,120,0,0,4,-10,-10,0,0,-10,5,0,2,4284703623,1,12,12,8,8,90,10,5,100,0,2,0,6,7,1,0,200,50,	69,25,0,0,0,0], //Blue X walker
		[11,3,23,2,14181906,11730944,800,1,0,6,2868854784,2,32,32,24,24,0,0,120,10,0,100,1,0,0,0,6,8,1,1,10,200,60,1,60,-5,20,-10,0,0,10,0,0,0,0,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,1300,300,		146,5,166,10,0,0], //Orange boss plus dragon
		//Plains 5
		[10,5,20,1,55552,7160869,140,3,1,9,4278245632,1,16,16,8,8,10,0,30,10,0,90,0,0,0,0,1,2,3,50,120,50,90,0,0,3,-20,-10,10,20,-10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,160,10,			53,50,154,100,0,0], //Green triangle tree
		[12,5,20,2,38270,5191462,500,6,1,19,3707803006,1,12,24,12,12,20,0,120,10,10,100,0,0,0,0,6,8,9,30,180,80,120,0,0,8,-25,-10,10,20,-10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,400,80,	36,10,88,10,148,25], //Teal big triangle tree
		[11,5,9,1,16732928,8803121,300,10,1,9,4294923008,1,16,16,12,12,10,0,20,10,0,95,0,0,0,0,1,3,2,20,30,200,60,0,0,3,-10,-20,0,10,-10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,250,40,		43,15,107,15,0,0], //Orange star tree
		[13,5,9,2,16711680,7689794,1200,10,1,19,3724476416,1,12,24,12,12,30,0,30,10,0,99,0,0,0,0,3,4,5,30,30,150,90,0,0,5,-10,10,0,0,20,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,1400,400,	156,5,172,10,0,0], //Red boss star tree
		//Plains 7
		[12,6,17,1,5066086,3289667,260,1,0,6,2865538182,1,24,24,16,16,0,10,20,10,0,100,0,0,0,0,4,5,1,1,10,80,60,0,0,-5,20,-10,20,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,300,50,			27,25,37,25,82,25,0,0,	90,0], //Grey roundhead wheel
		[13,6,13,1,16745693,12262655,300,10,1,31,2868872413,2,16,24,12,12,30,5,60,10,0,80,0,2,0,0,2,3,16,20,180,50,60,0,0,-8,0,10,-20,10,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,320,60,	45,15,72,15,90,15,160,40,	90,0], //Pink diamond wheel
		[12,2,13,1,9816831,27865,200,3,1,31,2861943551,2,20,16,12,12,0,0,60,10,0,99,0,0,0,0,4,5,1,20,90,80,90,2,25,-8,-20,25,0,0,12,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,300,50,			64,25,158,60,0,0], //Blue diamond bat
		[15,6,17,2,7038868,4144982,1800,6,0,6,4287530604,1,24,24,16,16,30,10,60,10,10,95,0,0,0,0,3,4,9,20,20,50,60,0,0,-5,25,-10,25,0,25,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,1600,500,	100,5,162,5,176,10,0,0,	90,0], //Grey boss roundhead wheel
		//Plains 8
		[14,19,4,1,15915481,9525837,200,3,1,1,4294105561,1,8,16,8,8,10,0,30,10,0,100,0,0,0,0,3,6,2,10,60,100,60,0,0,7,-12,0,25,12,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,330,55,		73,25,191,50,0,0], //White skull hopper
		[14,4,4,1,15915481,9525837,220,2,1,3,4294105561,1,16,24,20,8,0,0,30,10,0,100,0,0,0,0,7,10,1,20,90,200,60,0,0,7,-12,0,25,12,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,350,60,		29,15,109,15,193,30], //White skull stickman
		[15,10,4,2,15915481,9525837,500,3006,1,9,4294105561,1,16,16,8,8,0,0,1,10,0,100,0,0,0,0,1,2,5,30,3,1000,90,0,0,9,-17,0,25,14,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,600,90,	55,10,195,20,0,0], //White big skull spider
		[17,4,4,0.4,15915481,9525837,120,2,1,3,4294105561,1,8,12,10,4,0,0,10,10,0,100,0,0,0,0,3,4,1,20,90,50,60,0,0,10,-5,0,20,10,20,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,200,25,	208,50,178,100,0,0], //White boss skull stickman
		//Plains 9
		[16,0,23,1,4688773,2575950,200,110,1,18,2868903680,1,12,12,8,8,0,0,5,10,0,100,0,0,0,0,1,12,4,20,60,80,60,3,0,4,-20,0,15,50,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,350,50,					46,30,91,30,183,60], //Teal plus walker
		[16,3,20,1,10302773,6697728,180,110,1,5,2868864512,2,16,32,12,12,0,0,60,10,0,95,1,0,0,0,6,8,3,10,60,80,90,1,110,-5,20,-10,0,0,-20,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,350,50,			38,30,83,30,101,30,187,60], //Red triangle dragon
		[16,19,13,1,8707583,4290763,240,110,1,31,2860834303,2,16,16,16,16,0,0,10,10,0,90,1,0,0,0,4,6,4,10,90,100,60,2,15,-5,-20,20,0,0,10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,350,50,			65,30,185,60,0,0], //Blue diamond spider
		[18,2,9,2,16741829,12616447,1800,110,1,31,2868858804,2,16,32,12,12,0,0,120,60,10,100,0,0,0,0,12,16,5,20,60,100,60,0,0,-3,0,15,-20,12,30,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,1800,700,	189,5,165,10,0,0], //Pink boss star bat
		//Tower Entrance
		[17,4,27,1,14868972,7499662,250,3,1,35,4293059052,1,48,48,24,24,0,5,10,10,0,100,0,0,0,1,9,12,1,1,150,80,60,0,0,7,-10,0,-25,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,250,60,			110,40,159,90,0,0], //White helmet stickman
		[18,4,27,1.2,16776960,10878976,600,3,1,35,4289069056,1,48,48,24,24,0,5,10,10,0,100,0,0,0,1,6,8,1,1,5,50,60,0,0,10,-20,0,-50,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,0,0,0,0,0,0,0,0,500,70,			56,15,92,15,163,40], //Yellow helmet stickman
		[18,20,26,1,7667946,4342442,220,3,0,15,2860515583,1,16,16,8,8,60,5,60,10,-1,100,0,0,0,0,4,6,3,30,180,70,90,6,5,-16,10,10,10,10,10,0,0,0,4294967295,1,16,16,16,16,0,0,0,0,0,0,0,0,0,0,0,260,50,			30,30,74,30,161,60,0,0,	10,10], //Purple mask wizard
		[20,4,28,2,6579300,6684672,2000,3,1,35,4294934528,1,48,48,24,24,0,5,10,10,0,100,1,0,0,1,3,4,1,30,120,80,120,1,90,15,10,0,-10,0,30,2,0,24,2868848128,2,16,24,12,12,180,10,10,90,0,1,0,4,6,60,0,2000,800,	48,5,177,10,0,0], //Grey boss hornhelm stickman
		//Path 1
		[8,19,17,1,1100095,1474117,150,210,1,16,2854011268,1,24,12,12,12,0,0,10,10,0,90,0,0,0,0,1,2,6,20,90,50,60,4,5,-3,10,-20,-10,20,-20,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,400,25,	35,30,99,30,0,0], //Green roundhead hopper
		[9,19,19,1,11993088,8388672,300,210,1,9,2868838400,1,16,16,12,12,0,0,20,10,0,90,0,0,0,0,3,4,6,20,30,60,90,7,300,0,12,-24,-15,0,-24,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,800,50,	52,15,70,15,0,0], //Red demon hopper
		[9,5,18,1,37709,28988,80,1,0,2,2852192000,1,16,16,12,12,0,0,10,10,0,100,0,0,0,0,1,2,1,1,60,100,40,4,8,-3,10,-10,-10,10,-20,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,200,10,			62,25,0,0,0,0], //Green coconut tree
		[10,19,19,2,9764864,6553650,1200,1,0,27,2868838400,1,24,24,16,16,0,0,10,10,0,100,0,0,0,0,12,15,1,1,10,50,60,7,300,0,16,-20,-15,0,20,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,1600,250,	106,5,170,10,0,0], //Red boss demon hopper
		//Path 2
		[12,1,4,1,45056,15460768,200,3,1,9,4293190270,1,16,16,12,12,0,5,10,10,0,100,0,0,0,0,1,1,2,10,60,80,50,4,8,0,0,-10,0,20,-10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,410,30,					192,80,0,0,0,0], //Green skull snake
		[13,1,15,1,8421631,11136159,550,3003,1,4,4286644223,1,16,16,12,12,0,5,10,10,0,100,0,0,0,0,2,3,3,10,90,100,50,2,15,0,-10,20,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,820,55,				44,15,98,15,190,40], //Blue shield snake
		[12,7,6,1,9393951,5455140,110,306,0,13,4283645220,1,16,16,8,8,30,5,120,10,10,95,0,0,0,0,3,4,6,50,160,80,90,0,0,5,10,-20,10,-10,-20,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,210,15,			28,20,63,20,194,50], //Brown cap fish
		[13,7,6,2,13006891,8478520,1600,306,0,2,4286142773,1,16,16,12,12,60,5,120,10,10,100,0,0,0,0,8,9,18,50,120,100,120,0,0,8,12,-25,12,-20,20,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,1800,350,	81,5,89,5,207,5,167,10], //Brown boss cap fish
		//Plains 6
		[11,10,32,1,16776960,9533747,180,9006,1,10,2868903680,1,16,16,12,12,0,10,60,10,20,100,0,0,0,0,1,9,2,40,30,50,90,3,10,-2,0,0,20,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,280,30,	71,40,108,40,182,90], //Yellow spiky spider
		[12,0,3,1,16776960,9533747,200,4,0,13,2868903680,1,16,16,8,8,0,121,120,10,10,100,0,0,0,0,0,0,1,90,90,60,160,3,0,0,0,0,20,0,0,1,0,15,2868903680,1,32,32,16,16,10,30,0,100,0,0,0,1,16,1,0,300,35,		26,35,184,80,0,0], //Yellow X walker
		[12,3,32,1,16776960,9533747,160,1,1,10,2868903680,1,24,32,16,24,0,10,60,10,10,100,0,0,0,0,1,30,1,1,180,60,90,3,0,-3,0,-10,25,0,-10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,300,35,	54,20,80,20,186,50], //Yellow spiky dragon
		[13,10,32,2,5483007,27607,1800,9006,1,10,2857609727,1,32,32,16,16,0,0,120,10,15,100,0,2,0,0,1,12,3,40,3,60,120,3,10,-4,0,0,30,0,20,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,1500,500,	188,5,168,10,0,0], //Blue boss spiky spider
		//Bog 1
		[1,22,0,2,8601026,4925563,10,7,0,0,4294967295,1,16,16,16,16,0,0,0,0,0,100,0,0,0,0,1,0,9,0,0,1000,512,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], //Purple egg
		[18,10,13,1,8601026,4925563,80,2,1,9,4289669528,1,16,16,12,12,0,0,5,10,0,100,0,0,0,0,3,4,1,10,30,60,30,0,0,0,-20,0,0,20,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,50,10,					131,150,0,0,0,0], //Purple diamond spider
		[19,2,33,1,5534789,13364200,180,1,0,13,2862605567,2,16,16,8,8,0,0,90,10,5,100,0,1,0,0,5,6,1,1,90,100,60,0,0,-3,-25,-10,-10,50,-10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,280,50,		47,40,127,90,0,0], //Green fly bat
		[20,2,33,2,3563321,11132633,600,203,0,28,4288013055,2,12,12,8,8,20,10,70,10,0,98,0,2,0,0,2,5,9,30,120,100,90,30,50,3,-25,-10,-10,50,-10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,800,100,	93,10,125,25,133,25], //Green big fly bat
		[20,10,13,3,10632388,6498427,1800,204,1,9,4289669494,1,24,24,16,16,10,10,130,10,5,100,0,0,0,0,3,4,6,120,60,60,90,0,0,0,-15,0,0,20,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,2100,900,	39,5,143,5,169,10], //Purple boss diamond spider
		//Bog 2
		[1,22,0,2,15592640,14274442,50,7,0,0,4294967295,1,16,16,16,16,0,0,0,0,0,100,0,0,0,0,1,0,6,0,0,1000,512,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], //Tan egg
		[19,24,18,1,14248960,14276864,200,3,1,4,4294934528,1,16,16,12,12,0,0,10,10,0,90,0,0,0,0,2,3,1,10,60,50,30,0,0,5,-10,-10,0,20,-10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,300,50,			50,50,85,50,137,100], //Orange coconut centipede
		[19,0,3,1,39680,21248,320,606,0,28,2281748736,2,16,16,12,12,60,30,180,10,-5,95,0,0,0,0,2,3,9,1,120,80,120,4,20,0,-10,0,0,10,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,400,60,			75,15,129,40,0,0], //Green X walker
		[20,24,18,1.4,16711680,8388608,600,210,1,9,4294901760,1,16,16,8,8,0,0,10,10,0,95,0,0,0,0,3,4,6,10,60,30,60,0,0,7,-12,-12,0,25,-12,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,600,70,		57,25,67,25,135,50], //Red big coconut centipede
		[21,24,18,2,15728730,8388646,1800,7,0,0,4294967295,1,16,16,16,16,0,0,0,0,0,100,0,0,0,0,-1,0,1,0,600,1000,120,0,0,10,-15,-15,0,30,25,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,2200,1000,	112,5,171,10,0,0], //Red boss coconut centipede
		//Bog 3
		[20,2,13,0.3,14415861,14415861,50,1,0,0,4278190080,1,16,16,4,4,0,0,10,0,0,100,0,0,0,0,1,2,1,1,15,1000,1,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,5,1,						139,180,0,0,0,0], //White tiny bat
		[21,9,13,0.5,15649482,15649482,80,1,0,0,4278190080,1,16,16,4,4,0,0,10,0,0,100,0,0,0,0,1,2,1,1,15,1000,1,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,5,1,						141,180,0,0,0,0], //White tiny eel
		[22,12,6,1,16711680,15657949,360,6,0,6,2867462144,1,16,16,12,12,10,0,60,10,5,99,0,0,0,0,2,3,3,10,45,50,30,17,100,3,-10,0,0,20,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,400,60,			32,25,58,25,103,25], //Red cap zombie
		[22,8,6,2,16711680,15657949,500,7,0,0,4294967295,1,16,16,16,16,0,0,0,0,0,100,0,0,0,0,-3,0,1,0,10,1000,512,0,0,5,-20,0,0,50,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,700,80,				41,10,94,10,113,10], //Red big cap mushroom
		[23,12,6,2,16711680,15657949,1800,210,0,6,2867462144,1,16,16,12,12,30,10,45,10,5,99,0,0,0,0,1,3,16,10,60,100,30,17,120,5,-15,0,0,25,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,2300,1100,	76,5,86,5,179,10], //Red boss cap zombie
		//Foreverglade
		[30,24,32,2,10892083,8725356,1200,27003,1,9,4289082163,1,16,16,12,12,0,0,120,10,0,100,0,0,0,0,2,3,3,25,90,100,200,0,0,3,90,90,10,10,90,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,3,2000,1000,	0,0,0,0,0,0,0,0,100,20], //Foreverglade boss
		[0,0,0,1,16777215,16777215,10,4,0,12,4279616538,1,16,16,8,8,0,601,600,10,3,100,0,0,0,0,0,0,1,90,180,30,512,4,60,0,0,0,0,0,0,3,1,6,2853553178,1,16,32,8,8,30,10,0,99,0,2,0,1,1,3,0,0,0,181,1,196,1,200,1], //NOTE book drops for the egg show from here. Because of stupid code.
		[0,0,0,1,16777215,16777215,0,1,0,27,2866610176,1,32,32,16,16,0,0,5,10,0,100,0,0,0,0,2,3,1,1,5,1000,40,7,1000,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,1,16777215,16777215,0,7,0,0,4294967295,1,16,16,16,16,0,0,0,0,0,100,0,0,0,0,-8,0,3,0,15,50,512,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[1,22,0,3,16776960,65280,10,0,0,0,4294967295,1,16,16,16,16,0,0,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,0,0,181,1,196,1,200,1], //Reward egg
		//Plains 10
		[19,8,25,1,13562039,12374063,300,6,0,32,2864310937,1,16,16,8,8,0,5,120,10,10,100,0,2,0,0,4,6,3,30,60,1000,512,30,10,5,-10,0,10,10,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,280,60,			66,45,153,80,0,0,0,0,	100,0], //Green bell mushroom
		[20,1,25,2,13562039,12374063,550,4,0,32,4005161625,1,32,32,16,16,0,181,180,10,8,99,0,0,0,0,0,0,1,120,180,80,64,30,10,6,-15,0,12,16,0,7,0,32,2864310937,1,16,16,8,8,60,10,20,99,0,2,0,3,4,6,0,480,80,		40,15,149,40,0,0], //Green big bell snake
		[21,1,25,2,12609072,6462839,700,4,0,32,2868838400,1,32,32,12,24,0,0,240,10,8,99,0,2,0,0,3,4,1,90,180,80,64,1,160,6,-15,0,12,16,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,600,120,			102,10,145,25,0,0], //Brown big bell snake
		[20,1,25,1,14609645,9153474,300,4,0,32,2858736127,1,16,16,6,12,0,10,160,10,8,99,0,2,0,0,5,6,1,90,120,60,64,2,20,4,-20,14,10,12,10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,300,70,			84,25,111,25,155,60], //White bell snake
		[22,8,25,3,12609072,6462839,2000,210,0,32,2868838400,1,32,32,12,24,18,0,180,10,8,99,0,2,0,0,3,4,9,30,180,1000,512,1,160,10,-18,0,15,50,90,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,2100,900,	175,10,0,0,0,0], //Brown boss bell mushroom
		//Higher Plains
		[21,2,15,1,8712886,7753522,250,3,0,30,2860839606,2,24,24,12,16,0,0,180,10,-5,99,1,0,0,0,4,5,1,30,60,80,80,10,60,-3,10,10,-15,0,10,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,300,70,			31,30,68,30,151,60,0,0,	30,0], //Teal shield bat
		[22,5,16,1,12104555,7753522,320,4,0,38,4286933605,1,16,16,12,12,20,5,90,10,10,98,0,0,0,0,5,6,3,60,120,50,90,0,0,5,5,0,10,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,500,90,					104,15,147,40,0,0], //Tan castle tree
		[23,3,15,2,8712886,7753522,900,3,0,30,2860839606,2,32,32,24,24,0,0,180,30,-2,95,0,2,0,0,1,1,1,30,180,60,90,10,60,-2,10,15,-10,0,25,2,1,35,2860839606,1,16,16,12,12,30,10,0,105,1,0,0,3,6,10,0,800,130,		49,10,77,10,157,25,0,0,	50,0], //Teal big shield dragon
		[24,20,16,1,3011206,5520942,1800,5,0,12,2860839606,2,24,24,12,12,30,181,180,10,5,99,0,0,0,0,1,1,6,1,180,60,80,10,100,-3,0,15,-20,0,90,8,1,35,2860839606,1,16,16,12,12,20,10,0,105,1,0,0,3,6,6,0,2200,1000,	59,5,95,5,173,10,0,0,	50,20], //Green boss castle wizard
		//
		[0,21,29,1,4839558,10770913,127,3,0,34,4291493834,1,24,24,16,8,0,0,60,90,1,101,0,2,0,0,3,4,1,30,90,50,90,8,30,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,1,1,		114,10,118,10,122,10], //Green cube warper
		[0,21,30,1,15748429,3648452,127,210,0,34,4292976543,1,32,12,12,12,0,0,30,45,10,99,0,1,0,0,1,2,6,30,60,50,80,8,20,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,1,1,	115,10,119,10,123,10], //Red sphere warper
		[0,21,31,1,3957668,11919661,127,4,1,34,4294967168,1,32,32,16,24,0,0,120,67,0,98,0,2,16,0,3,4,1,16,90,50,90,8,25,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,1,1,		116,10,120,10,0,0], //Blue octahedron warper
		[0,21,0,1,0,16777215,127,1,0,34,4294967295,1,32,32,16,24,60,0,160,94,10,98,0,1,0,0,6,7,1,1,120,70,90,8,30,0,0,0,0,0,0,0,0,0,4294967295,1,16,16,16,16,0,0,0,100,0,0,0,0,0,0,0,1,1,			117,10,121,10,0,0], //Headless warper
		//Tower
		[25,20,26,2,7621411,6233001,5200,3,0,0,0,1,32,32,16,16,0,91,90,30,0,105,0,2,0,0,3,6,1,5,360,60,150,6,20,-3,20,20,0,20,85,2,0,15,2860515583,2,32,32,12,12,10,10,0,1,0,0,0,1,1,100,1,2000,1100,	180,3,209,5,0,0,0,0,	90,20], //Tower boss
		[0,0,0,1,16777215,16777215,0,3004,1,31,2868869497,2,16,16,8,8,10,0,180,30,10,95,0,0,0,0,8,9,2,60,120,160,90,0,0,0,0,0,0,0,0,7,1,31,2868869497,2,16,24,8,8,40,10,0,40,0,2,0,2,3,16,0,0,0,0,0,0,0,0,0],
		[]
	],
	//Enemy hitbox
	fh = [20, 20, 20, 20, 18, 8, 20, 20, 8, 20, 16, 16, 20, 20, 16, 16, 16, 14, 8, 18, 18, 16, 16, 18, 18],
	gh = [20, 20, 20, 20, 24, 40, 20, 20, 20, 20, 16, 24, 20, 20, 16, 16, 16, 14, 40, 18, 18, 16, 16, 18, 18],
	ah = [1, 0.2, 1, 0.2, 2, 0.5, 1, 0.1, 1, 0.1, 1, 1, 0.1, 0.1, 1, 1, 0.2, 1, 0.5],
	G = new hh;
for (i = 0; i < B.length; i++) { //Make sure there's no undefined parameters
	for (j = 69; j < 73; j++) {
		if (B[i][j] == undefined) (B[i][j] = 0);
	}
}

function hh() { //Enemy
	var a, b;
	this.a = Array(300);
	for (a = 0; 300 > a; a++) this.a[a] = Array(21);
	this.c = Array(300);
	for (a = 0; 300 > a; a++) this.c[a] = Array(21);
	this.id = new Int32Array(300);
	this.step = new Int32Array(300);
	this.d = new Int32Array(300);
	this.count = new Int32Array(300);
	this.state = new Int32Array(300);
	this.r = new Int32Array(300);
	this.l = new Int32Array(300);
	this.search = new Int32Array(300);
	this.S = new Int32Array(300);
	//ELEMENT statuses on enemy
	this.C = new Int32Array(300);
	this.X = new Int32Array(300);
	this.D = new Int32Array(300);
	this.H = new Int32Array(300);
	this.B = new Int32Array(300);
	this.gravityForceEn = new Int32Array(300);
	this.gravityTimeEn = new Int32Array(300);
	this.gravityDamageEn = new Int32Array(300);
	this.bb = this.index = 0;
	this.clock = 0;
	this.phaseCooldown = 0;
	this.isFriendly = false;
	this.n = 20;
	for (a = 0; 300 > a; a++)
		for (b = 0; 21 > b; b++) this.a[a][b] = new Qg;
	for (a = 0; 300 > a; a++)
		for (b = 0; 21 > b; b++) this.c[a][b] = new Qg
}
aa = hh.prototype;
aa.j = function() { //Reset
	this.bb = this.index = 0
};
aa.add = function(a, b, c) { //Spawn
	var d;
	d = z(100 * Kb / 100);
	if (this.index != d && this.bb != d) {
		a *= 8;
		b *= 8;
		for (d = 0; 21 > d; d++) Rg(this.a[this.index][d], a + A(1), b + A(1)), this.c[this.index][d].set(this.a[this.index][d]);
		this.id[this.index] = c;
		this.step[this.index] = B[c][bh];
		this.d[this.index] = 0;
		this.count[this.index] = 0;
		this.state[this.index] = 0;
		this.r[this.index] = B[c][lg];
		this.l[this.index] = 0;
		this.search[this.index] = 0;
		this.S[this.index] = 0;
		//ELEMENT statuses on enemy
		this.C[this.index] = 0;
		this.X[this.index] = 0;
		this.D[this.index] = 0;
		this.H[this.index] = 0;
		this.B[this.index] = 0;
		this.gravityForceEn[this.index] = 0;
		this.gravityTimeEn[this.index] = 0;
		this.gravityDamageEn[this.index] = 0;
		this.index++;
		this.bb++
	}
};
aa.sub = function(a) { //Despawn
	for (var b = 0; 21 > b; b++) this.a[a][b].set(this.a[this.index - 1][b]), this.c[a][b].set(this.c[this.index - 1][b]);
	this.id[a] = this.id[this.index - 1];
	this.step[a] = this.step[this.index - 1];
	this.d[a] = this.d[this.index - 1];
	this.count[a] = this.count[this.index - 1];
	this.state[a] = this.state[this.index - 1];
	this.r[a] = this.r[this.index - 1];
	this.l[a] = this.l[this.index - 1];
	this.search[a] = this.search[this.index - 1];
	this.S[a] = this.S[this.index - 1];
	//ELEMENT statuses on enemy
	this.C[a] = this.C[this.index - 1];
	this.X[a] = this.X[this.index - 1];
	this.D[a] =	this.D[this.index - 1];
	this.H[a] = this.H[this.index - 1];
	this.B[a] = this.B[this.index - 1];
	this.gravityForceEn[a] = this.gravityForceEn[this.index - 1];
	this.gravityTimeEn[a] = this.gravityTimeEn[this.index - 1];
	this.gravityDamageEn[a] = this.gravityDamageEn[this.index - 1];
	this.index--
};
aa.h = function(a, b, c) { //Grounded
	var d = new Qg;
	d.q(this.a[a][b], this.c[a][b]);
	this.a[a][b].set(this.c[a][b]);
	var e = (Sg(d) >> 2) + 1;
	Tg(d, 1 / e);
	for (var g, k, r, m = 0; m < e; m++) g = this.a[a][b].y + d.y, k = K(this.a[a][b].x, 0, 511) >> 3, r = K(g, 0, 255) >> 3, k = I.e[r][k], 0 > g || 256 <= g || (0 <= k && 8 >= k ? (0 < d.y && (this.state[a] |= 2), d.x *= c, d.y = -d.y) : this.a[a][b].y = g), g = this.a[a][b].x + d.x, k = K(g, 0, 511) >> 3, r = K(this.a[a][b].y, 0, 255) >> 3, k = I.e[r][k], 0 > g || 512 <= g || (0 <= k && 8 >= k ? (d.y *= c, d.x = -d.x, this.state[a] |= 1) : this.a[a][b].x = g)
};
aa.m = function(a, b, c, d) { //Find enemy
	if (this.isFriendly) return -1;
	for (var e = 0.5 * (a + c), g = 1E3, k = -1, r, m, n, F = 0; F < this.index; F++) r = B[this.id[F]][ch], m = B[this.id[F]][bh], n = (fh[m] >> 1) * ((r >> 1) + 1), r *= gh[m] >> 1, this.search[F] = 0, m = this.a[F][this.n], 0 == this.r[F] || m.x - n > c || m.x + n < a || m.y - r > d || m.y + r < b || (this.search[F] = 1, Kg(m.x - e) < g && (g = Kg(m.x - e), k = F));
	return k
};
aa.K = function(a, b, c, d, e, g, k, r, m) { //Take damage
	if (this.isFriendly) return -1;
	var n = -1,
		F, H, M, secondaryType;
	v.L = 0;
	r *= 0.5;
	m *= 0.5;
	if (b > 9) { //Dual-typed
		secondaryType = z(b / 10);
		b = b % 10;
	}
	//ELEMENT enemies' damage taken from different types and status effects
	for (var E = 0; E < this.index && 
		(F = B[this.id[E]][ch], 
		H = B[this.id[E]][bh], 
		M = z(fh[H] / 2) * z(F / 2 + 1), 
		F *= z(gh[H] / 2), 
		0 == this.r[E] || 
		this.a[E][this.n].x - M > g + r || 
		this.a[E][this.n].x + M < g - r || 
		this.a[E][this.n].y - F > k + m || 
		this.a[E][this.n].y + F < k - m || 
			(M = d + z(A(e - d + 1)), 
			4 == b ? //Poison
				(this.D[E] == 0 && (this.D[E] += c - z(c * B[this.id[E]][tg] / 100)), //POISONFIX duration stacks
				0 > B[this.id[E]][tg] ? //POISONFIX damage stacks NOTE: changed syntax here to ternary operator
					(this.H[E] += ig(1, M - z(M * B[this.id[E]][tg] / 100))) : //Damage if enemy weak to poison
					this.H[E] += M) : //Damage otherwise
			(0 == b ? M = ig(1, M - B[this.id[E]][pg]) : //Physical
			1 == b ? M = ig(1, M - z(M * B[this.id[E]][qg] / 100)) : //Fire
			//2 == b ? M = ig(1, M - z(M * B[this.id[E]][rg] / 100)) : //Ice
			3 == b ? M = ig(1, M - z(M * B[this.id[E]][sg] / 100)) : //Thunder
			//6 == b ? M = ig(1, M - z(M * B[this.id[E]][gravityResistEn] / 100)) : //Gravity(damage)
			7 == b && (M = ig(1, M - z(M * B[this.id[E]][drainResistEn] / 100))), //Drain(damage)
			this.r[E] = ig(this.r[E] - M, 0), //Deal damage
			0 == (wc & 1) && ne.add(this.a[E][this.n].x, this.a[E][this.n].y - F, 1, M, 12632256), this.S[E] = M), //Damage indicator + provocation (mushrooms/cacti)
			
			2 == b ? (this.C[E] = 500 - z(500 * B[this.id[E]][rg] / 100), this.X[E] = c) : //Slow
			5 == b ? (this.B[E] = c - z(c * B[this.id[E]][ug] / 100)) : //Freeze
			6 == b ? (this.gravityTimeEn[E] = 100 - z(100 * B[this.id[E]][gravityResistEn] / 100), this.gravityForceEn[E] = c) : //Gravity(effect)
			7 == b && playerDrain(M, c), //Drain(effect)
			secondaryType > 0 &&
				2 == secondaryType ? (this.C[E] = 500 - z(500 * B[this.id[E]][rg] / 100), this.X[E] = c) : //Slow
				4 == secondaryType ? //Poison
					(this.D[E] == 0 && (this.D[E] += c - z(c * B[this.id[E]][tg] / 100)),
					0 > B[this.id[E]][tg] ? 
						(this.H[E] += ig(1, M - z(M * B[this.id[E]][tg] / 100))) : 
						this.H[E] += M) : 
				5 == secondaryType ? (this.B[E] = c - z(c * B[this.id[E]][ug] / 100)) : //Freeze
				6 == secondaryType ? (this.gravityTimeEn[E] = 100 - z(100 * B[this.id[E]][gravityResistEn] / 100), this.gravityForceEn[E] = c) : //Gravity(effect)
				7 == secondaryType && playerDrain(M, c), //Drain(effect)
			n = E,
			v.L += M, 
			Fb = this.r[E], 
			Gb = B[this.id[E]][lg], 
			Hb = 100, 
			Ib = this.id[E], 
			0 != a));
		E++);
	return n
};

function playerDrain(damage, chance) { //Drain effect for players' attacks
	var target, heal;
	heal = ig(1, z(damage/10)); //Heal at least 1
	while (chance > 0){ //Drain can happen multiple times when chance > 100, e.g. 250% drain chance is 2 guaranteed drains and 50% chance for a 3rd
		target = $g(4); //Pick a random target for healing (temporary solution? since currently there's no "attacker" parameter for damage functions)
		if (chance > A(100) && p[target] != 0){
			p[target] = K(p[target] + heal, 0, kc[target]); //Don't heal over max LP
			if (wc < 2) ne.add(v.a[target][0].x, v.a[target][0].y, 1, heal, 0x00FF00);
		}
		chance -= 100;
	}
}
aa.p = function(a, b) { //Attack
	if (this.isFriendly) return;
	var c = new Qg,
		d = this.id[a] + b,
		e = B[d],
		g = e[7] % 100,
		k = z(e[7] / 100),
		r = e[8],
		m = e[9],
		n = e[10],
		F = e[11],
		H = e[12],
		M = e[13],
		E = e[14],
		ka = e[15],
		Ja = e[16],
		Ea = e[17],
		Ca = e[18],
		Z = e[19],
		X = e[20],
		$ = e[21],
		ob = e[22],
		pb = e[23],
		Xa = e[24],
		ta = e[25],
		ya = e[26],
		rb = e[27],
		ia = e[28],
		ja = e[29],
		za = e[30],
		bb = e[31],
		ab = e[32],
		pa = e[33],
		Ya = e[34],
		Bb = e[41],
		Cb = e[42],
		Sa = e[43],
		Oa = e[44],
		Ob = e[45],
		Pb = e[46],
		Qb = e[47],
		Rb = e[48],
		Sb = e[49],
		Tb = e[50],
		qb = e[51],
		Ub = e[52],
		Vb = e[53],
		Wb = e[54],
		Xb = e[55],
		Yb = e[56],
		Zb = e[57],
		ba = e[58],
		e = e[59];
	if (0 < this.l[a]) this.l[a]--;
	else if (!(A(1E3) > bb) && (bb = v.m(this.a[a][0].x - ab, this.a[a][0].y - ab, this.a[a][0].x + ab, this.a[a][0].y + ab, 0), -1 != bb && (this.l[a] = za, 0 != g)))
		if (1 == g) {
			var g = this.a[a][0].x + 10 * c.x,
				U = this.a[a][0].y + 10 * c.y;
			oe.add(1, g, U, 0, 0, r, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, 0, ta, ya, rb, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, 0, 0, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, e, pa, Ya)
		} else if (2 == g) 
			c = v.a[bb][2].x - this.a[a][0].x, c /= Kg(c), 
			g = this.a[a][0].x + 10 * c, 
			U = this.a[a][0].y, 
			oe.add(1, g, U, c * ja * 0.1, 0, r, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, 0, ta, ya, rb, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, 0, 0, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, e, pa, Ya);
	else if (3 == g || 6 == g)
		for (3 == g ? Rg(c, v.a[bb][2].x - this.a[a][0].x, v.a[bb][2].y - this.a[a][0].y) : 6 == g && Rg(c, 0, -1), d = 0 < k ? k : 16, k = z(512 * Vg(c) / Wg), k -= z((ia - 1) * d / 2), za = 0; za < ia; za++) {
			c.x = Xe[k & 511][0];
			c.y = -Xe[k & 511][1];
			var g = this.a[a][0].x + 10 * c.x,
				U = this.a[a][0].y + 10 * c.y,
				ab = c.x * ja * 0.1,
				sc = c.y * ja * 0.1;
			oe.add(1, g, U, ab, sc, r, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, 0, ta, ya, rb, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, 0, 0, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, e, pa, Ya);
			k += d
		} else if (4 == g)
			for (za = 0; za < ia; za++) 
				Rg(c, v.a[bb][2].x - this.a[a][0].x, v.a[bb][2].y - this.a[a][0].y), 
				d = 0 < k ? k : ia, 
				0 < ia && (U = z(A(512)), g = A(10) * d, c.x += Xe[U][0] * g, c.y += Xe[U][1] * g), 
				g = this.a[a][0].x, 
				U = this.a[a][0].y, 
				ab = c.x / ja, 
				sc = (c.y - 0.5 * ja * ja * X * 0.01) / ja, 
				oe.add(1, g, U, ab, sc, r, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, 0, ta, ya, rb, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, 0, 0, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, e, pa, Ya);
		else if (5 == g)
			for (za = 0; za < ia; za++) 
				g = this.a[a][0].x + N(-ab, ab), 
				U = this.a[a][0].y + N(-ab, 0), 
				oe.add(1, g, U, 0, 0, r, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, 0, ta, ya, rb, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, 0, 0, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, e, pa, Ya);
	else if (7 == g)
		for (za = 0; za < ia; za++) 
			g = z(this.a[a][0].x / 8), 
			U = z(this.a[a][0].y / 8), 
			this.add(g, U, d + ya);
	else if (8 == g)
		for (za = 0; za < ia; za++) 
			U = $g(4), 
			g = v.a[U][2].x, 
			U = v.a[U][2].y, 
			oe.add(1, g, U, 0, 0, r, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, 0, ta, ya, rb, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, 0, 0, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, e, pa, Ya);
	else if (9 == g)
		for (za = 0; za < ia; za++) 
			U = $g(4), 
			Rg(c, v.a[U][0].x - this.a[a][0].x, v.a[U][0].y - this.a[a][0].y), 
			Xg(c), 
			g = this.a[a][0].x + 10 * c.x, 
			U = this.a[a][0].y + 10 * c.y, 
			ab = c.x * ja * 0.1, 
			sc = c.y * ja * 0.1, 
			oe.add(1, g, U, ab, sc, r, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, 0, ta, ya, rb, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, 0, 0, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, e, pa, Ya);
	else if (g == 10) { //Attack mode X10. Even spread if X > 0, otherwise random direction. X = 1 for set orientation, X = 2 for random orientation.
		var helpVar = z(A(512));
		for (za = 0; za < ia; za++) {
			k == 0 && (U = z(A(512))),
			k == 1 && (helpVar = 384),
			k > 0 && (U = za * z(512 / ia) + helpVar),
			c.x = Xe[U & 511][0],
			c.y = Xe[U & 511][1],
			g = this.a[a][0].x + 4 * c.x, 
			U = this.a[a][0].y + 4 * c.y, 
			ab = c.x * ja * 0.1, 
			sc = c.y * ja * 0.1, 
			oe.add(1, g, U, ab, sc, r, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, 0, ta, ya, rb, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, 0, 0, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb, ba, e, pa, Ya);
		}
	}
};

function Jg(a, b, c) { //Death
	for (var d, e = 0, g = 0; g < ze; g++)
		if (0 != (Ae[g] & Ce)) {
			var k = Pe[g + 1] - Pe[g];
			for (d = 0; d < k; d++) e < B[Pe[g] + d][Qe] && (e = B[Pe[g] + d][Qe]), d += B[Pe[g] + d][Re]
		}
	d = 1 == c ? b : a.id[b];
	k = Kg(Mb[0] - B[d][Qe]);
	g = 0;
	g = 10 > k ? z(B[d][ng] * (10 - k) / 10) : e + 10 <= Mb[0] ? 0 : 1;
	e = 100;
	for (d = 0; 4 > d; d++) x(s + d, Td) && (e += y(s + d, t));
	g = z(g * e / 100);
	if (1 == c) return g;
	Ne();
	cc = K(cc + g, 0, 9999999);
	c = 4753E3;
	d = 9999999;
	if (98 > Mb[0]) {
		c = 0;
		for (d = 1; d < Mb[0]; d++) c += 1E3 * d;
		d = c + 1E3 * d
	}
	if (d <= cc && 99 > Mb[0]) {
		Mb[0]++;
		for (d = 0; 4 > d; d++) ac[d] += 2;
		c = 0;
		for (d = s; d < Gc; d++) w(q[d],
			hd) == ee && (c = 1), w(Dc[d], hd) == ee && (c = 1), w(Ec[d], hd) == ee && (c = 1);
		if (1 == c)
			for (Lb = 480, b = 0; 4 > b; b++) v.p(562, v.a[b][0].x, v.a[b][0].y, 0), p[b] != kc[b] && ne.add(v.a[b][0].x, v.a[b][0].y, 0, kc[b] - p[b], 65280), p[b] = kc[b]
	}
	te();
	c = B[a.id[b]][mg];
	k = g = e = 100;
	for (d = 0; 4 > d; d++) x(s + d, Qd) && (e += y(s + d, t)), x(s + d, Rd) && (g += y(s + d, t)), x(s + d, Sd) && (k += y(s + d, t));
	for (d = 0; 4 > d; d++)
		if (x(s + d, Xd) && A(100) < y(s + d, t)) {
			var r = G.m(a.a[b][0].x - 600, a.a[b][0].y - 300, a.a[b][0].x + 600, a.a[b][0].y + 300); - 1 != r && v.p(y(s + d, id), a.a[b][0].x, a.a[b][0].y, r)
		}
	r = 0;
	17 == a.step[b] && (r = a.d[b] - 1);
	for (d = og; d < og + 8; d += 2) { //Enemy item drops
		if (0 != B[a.id[b]][d]) {
			if (Math.random() * B[a.id[b]][d + 1] * 100 < e) pe.add(a.a[b][r].x, a.a[b][r].y, B[a.id[b]][d], 0, 0);
		}
	}
	1 > 3 * Math.random() && pe.add(a.a[b][r].x, a.a[b][r].y, 1, z(c * k / 100), 0);
	500 * Math.random() < g && pe.add(a.a[b][r].x, a.a[b][r].y, 2, 0, 0);
	return 0
}
da.fff = hh.prototype.move;
hh.prototype.move = function() { //Main
	var a;
	this.clock = (this.clock + 1) &511;
	for (a = 0; a < this.index; a++) {
		var b = this.step[a];
		//ELEMENT Status effects on enemies
		0 < this.D[a] && 0 < this.r[a] &&  //Poison
			(this.D[a]--, 
			this.r[a] = ig(this.r[a] - this.H[a], 0), 
			this.D[a] == 0 && (this.H[a] = 0), //POISONFIX when duration hits 0, reset damage
			Fb = this.r[a], 
			Gb = B[this.id[a]][lg], 
			Hb = 100, 
			Ib = this.id[a]);
		if (0 < this.B[a] && 0 < this.r[a]) this.B[a]--; //Freeze
		else {
			if (0 < this.C[a] && 0 < this.r[a] && (this.C[a]--, A(100) < this.X[a])) continue; //Slow
			if (this.gravityTimeEn[a] > 0 && this.r[a] > 0) { //Gravity
				var xTile = z(this.a[a][0].x/8),
					yTile = K(z(this.a[a][0].y/8), 1, 30) + z(signum(this.gravityForceEn[a]) * B[this.id[a]][ch]);
				this.gravityTimeEn[a]--;
				if (I.e[yTile][xTile] == -1) { //If in the air
					this.a[a][0].y += this.gravityForceEn[a] / 10; //Dragged down
					this.gravityDamageEn[a] += this.gravityForceEn[a] * this.gravityForceEn[a] / 100; //Add up damage while falling
				}
				else if (I.e[yTile][xTile] == 9) { //If in water
					this.a[a][0].y += this.gravityForceEn[a] / 100; //Dragged down slower
				}
				else { //Hit the floor
					if (this.gravityDamageEn[a] != 0) {
						//this.gravityDamageEn[a] *= 1 + B[this.id[a]][ch]/10; //Multiply damage based on enemy size
						this.r[a] -= this.gravityDamageEn[a]; //Deal damage
						if ((wc & 1) == 0) ne.add(this.a[a][this.n].x, this.a[a][this.n].y, 1, this.gravityDamageEn[a], 0xE100FF); //Damage indicator
						this.r[a] = ig(this.r[a], 0); //Max of current health and 0
						Fb = this.r[a]; //And then some health info updating or something, idk
						Gb = B[this.id[a]][lg];
						Hb = 100;
						Ib = this.id[a];
					}
					this.gravityDamageEn[a] = 0; //Reset gravity damage
				}
				if (this.gravityTimeEn[a] == 0) this.gravityDamageEn[a] = 0; //Reset gravity damage when effect ends
			}
			0 == b ? a = this.lb(a) : //Walker
			1 == b ? a = this.sa(a) : //Snake
			2 == b ? a = this.ta(a) : //Bat
			3 == b ? a = this.ua(a) : //Dragon
			4 == b ? a = this.ma(a, b) : //Stickman
			5 == b ? a = this.na(a, b) : //Tree
			6 == b ? a = this.va(a) : //Wheel
			7 == b ? a = this.wa(a) : //Fish
			8 == b ? a = this.xa(a) : //Mushroom
			9 == b ? a = this.eb(a, b) : //Eel (swim)
			10 == b ? a = this.mb(a) : //Spider
			11 == b ? a = this.nb(a) : //Cactus
			12 == b ? a = this.ma(a, b) : //Zombie
			13 == b ? a = this.eb(a, b) : //Eel (fly)
			14 == b ? a = this.ob(a) : //Copter
			15 == b ? a = this.pb(a) : //Bouncer
			16 == b ? a = this.qb(a) : //Germ
			17 == b ? a = this.rb(a) : //Digger
			18 == b ? a = this.na(a, b) : //Tree (hang)
			20 == b ? a = this.ma(a, b) : //Wizard
			21 == b ? a = this.warper(a) : //Warper
			22 == b ? a = this.egg(a) : //Egg
			23 == b ? a = this.cell(a) : //Clustering cell
			24 == b ? a = this.centipede(a) : //Chaining centipede
			19 == b && (a = this.hopper(a)); //Hopper
		}
	}
};

da.fff = hh.prototype.lb; //Walker
hh.prototype.lb = function(a) {
	var b;
	b = B[this.id[a]][ch];
	if (0 == this.d[a]) {
		this.a[a][0].x += 1;
		this.a[a][0].y += 0 - 4 * (b - 1);
		this.a[a][1].x += 0;
		this.a[a][1].y += 2 - 4 * (b - 1);
		this.a[a][2].x += 2;
		this.a[a][2].y += 2 - 4 * (b - 1);
		for (b = 0; 3 > b; b++) this.c[a][b].set(this.a[a][b]);
		this.d[a] = 1
	} else if (1 == this.d[a] || 2 == this.d[a]) {
		W(this.a[a][0], this.c[a][0], -0.05, 0.99);
		W(this.a[a][1], this.c[a][1], 0.05, 0.99);
		W(this.a[a][2], this.c[a][2], 0.05, 0.99);
		if (0 < (this.state[a] & 3)) {
			var c = -0.1;
			2 == this.d[a] && (c *= -1);
			this.a[a][1].x += A(c);
			this.a[a][2].x +=
				A(c);
			1 > A(100) && (this.d[a] = Zf(this.d[a] + 1, 1, 2))
		}
		Y(this.a[a][0], this.a[a][1], 9 * b, 0.2, 0.2);
		Y(this.a[a][0], this.a[a][2], 9 * b, 0.2, 0.2);
		Y(this.a[a][1], this.a[a][2], 11 * b, 0.2, 0.2);
		this.p(a, 0);
		for (b = this.state[a] = 0; 3 > b; b++) this.h(a, b, 0.5);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a] = 3;
			for (b = 0; 3 > b; b++) this.a[a][b].x += N(-0.5, 0.5), this.a[a][b].y -= N(2, 3);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 3 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		for (b = this.state[a] = 0; 3 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ &&
			this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.sa; //Snake
hh.prototype.sa = function(a) {
	var b;
	if (0 == this.d[a]) {
		this.a[a][0].x += 0;
		this.a[a][1].x += 1;
		this.a[a][2].x += 2;
		for (b = 0; 3 > b; b++) this.c[a][b].set(this.a[a][b]);
		this.d[a] = 1
	} else if (1 == this.d[a] || 2 == this.d[a]) {
		W(this.a[a][0], this.c[a][0], 0.05, 0.99);
		W(this.a[a][1], this.c[a][1], 0.05, 0.9);
		W(this.a[a][2], this.c[a][2], 0.05, 0.9);
		b = v.m(this.a[a][0].x - 200, this.a[a][0].y - 50, this.a[a][0].x + 200, this.a[a][0].y + 50, 0); - 1 != b && (this.a[a][0].x += v.a[b][2].x < this.a[a][0].x ? -0.001 : 0.001);
		if (0 < (this.state[a] & 2)) {
			var c = 0,
				c = -1 !=
				b ? v.a[b][2].x < this.a[a][0].x ? -1 : 1 : Kf(-1, 1);
			10 > A(100) && (this.a[a][0].x += N(0.4, 0.6) * c, this.a[a][0].y += N(-1.5, -2))
		}
		Y(this.a[a][0], this.a[a][1], 0, 0, 0.01);
		Y(this.a[a][1], this.a[a][2], 0, 0, 0.01);
		this.p(a, 0);
		this.state[a] = 0;
		this.h(a, 0, 0.5);
		b = this.state[a];
		this.h(a, 1, 0.5);
		this.h(a, 2, 0.5);
		this.state[a] = b;
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a] = 3;
			for (b = 0; 3 > b; b++) this.a[a][b].x += N(-0.5, 0.5), this.a[a][b].y -= N(2, 3);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 3 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		for (b = this.state[a] = 0; 3 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.ta; //Bat
hh.prototype.ta = function(a) {
	var b, c = new Qg;
	b = B[this.id[a]][ch];
	if (0 == this.d[a]) {
		this.a[a][0].x += 1;
		this.a[a][0].y += 1;
		this.a[a][1].x += 1;
		this.a[a][1].y += 1;
		this.a[a][2].x += 0;
		this.a[a][2].y += 0;
		this.a[a][3].x += 0;
		this.a[a][3].y += 2;
		this.a[a][4].x += 1;
		this.a[a][4].y += 1;
		this.a[a][5].x += 2;
		this.a[a][5].y += 0;
		this.a[a][6].x += 2;
		this.a[a][6].y += 2;
		for (b = 0; 7 > b; b++) this.c[a][b].set(this.a[a][b]);
		this.d[a] = 1
	} else if (1 == this.d[a] || 2 == this.d[a]) {
		W(this.a[a][0], this.c[a][0], 0, 0.99);
		W(this.a[a][1], this.c[a][1], 0, 0.99);
		W(this.a[a][2], this.c[a][2], 0, 0.99);
		W(this.a[a][3], this.c[a][3], 0, 0.99);
		W(this.a[a][4], this.c[a][4], 0, 0.99);
		W(this.a[a][5], this.c[a][5], 0, 0.99);
		W(this.a[a][6], this.c[a][6], 0, 0.99);
		Rg(c, 0, 0);
		var d = v.m(this.a[a][0].x - 150, this.a[a][0].y - 150, this.a[a][0].x + 150, this.a[a][0].y + 150, 0); - 1 != d && (c.q(v.a[d][2], this.a[a][0]), d = Xg(c), d -= B[this.id[a]][32] - 10, 0 > d ? Tg(c, -0.05) : Tg(c, 0.05));
		this.a[a][0].add(c);
		10 > A(100) && (this.a[a][0].x += N(-1, 1), this.a[a][0].y += N(-1, 1));
		this.a[a][2].x += N(0, -0.1);
		this.a[a][3].x += N(0, -0.1);
		this.a[a][5].x += N(0, 0.1);
		this.a[a][6].x += N(0, 0.1);
		c = 0.5;
		d = 6 * b;
		Y(this.a[a][0], this.a[a][1], 3 * b, c, c);
		Y(this.a[a][0], this.a[a][4], 3 * b, c, c);
		Y(this.a[a][1], this.a[a][2], d, c, c);
		Y(this.a[a][1], this.a[a][3], d, c, c);
		Y(this.a[a][2], this.a[a][3], d, c, c);
		Y(this.a[a][4], this.a[a][5], d, c, c);
		Y(this.a[a][4], this.a[a][6], d, c, c);
		Y(this.a[a][5], this.a[a][6], d, c, c);
		this.p(a, 0);
		for (b = this.state[a] = 0; 7 > b; b++) this.h(a, b, 1);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a] = 3;
			for (b = 0; 7 > b; b++) this.a[a][b].x += N(-1, 1), this.a[a][b].y -= N(1, 2);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 8 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		c = 0.5;
		d = 6 * (150 - this.count[a]) / 150;
		Y(this.a[a][1], this.a[a][2], d, c, c);
		Y(this.a[a][1], this.a[a][3], d, c, c);
		Y(this.a[a][2], this.a[a][3], d, c, c);
		Y(this.a[a][4], this.a[a][5], d, c, c);
		Y(this.a[a][4], this.a[a][6], d, c, c);
		Y(this.a[a][5], this.a[a][6], d, c, c);
		for (b = this.state[a] = 0; 7 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.ua; //Dragon
hh.prototype.ua = function(a) {
	var b, c = new Qg,
		d = B[this.id[a]][ch];
	if (0 == this.d[a]) this.d[a] = 1;
	else if (1 == this.d[a] || 2 == this.d[a]) {
		W(this.a[a][0], this.c[a][0], 0, 0.99);
		for (b = 1; 6 > b; b++) W(this.a[a][b], this.c[a][b], 0, 0.9);
		Rg(c, 0, 0);
		b = v.m(this.a[a][0].x - 200, this.a[a][0].y - 200, this.a[a][0].x + 200, this.a[a][0].y + 200, 0); - 1 != b && (c.q(v.a[b][2], this.a[a][0]), b = Xg(c), b -= B[this.id[a]][32] / 2 - 10, 0 > b ? Tg(c, -0.01) : Tg(c, 0.01));
		b = I.e[z(K(this.a[a][0].y + 24, 0, 255) / 8)][z(K(this.a[a][0].x, 0, 511) / 8)];
		0 <= b && 8 >= b && (c.y -= 0.02);
		2 >
			A(100) && (c.x += N(-0.5, 0.5), c.y += N(-0.5, 0.5));
		this.a[a][0].add(c);
		c = 0.02;
		d *= 5;
		for (b = 0; 5 > b; b++) Y(this.a[a][b], this.a[a][b + 1], d, 0, c);
		this.p(a, 0);
		for (b = this.state[a] = 0; 6 > b; b++) this.h(a, b, 0.5);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a] = 3;
			for (b = this.count[a] = 0; 6 > b; b++) this.a[a][b].x += N(-1, 1), this.a[a][b].y -= N(1, 2);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 6 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		c = 0.5;
		d = 10 * (150 - this.count[a]) / 150;
		Y(this.a[a][1], this.a[a][2], d, c, c);
		Y(this.a[a][2], this.a[a][3],
			d, c, c);
		Y(this.a[a][3], this.a[a][4], d, c, c);
		for (b = this.state[a] = 0; 6 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.ma; //Stickman Zombie Wizard
hh.prototype.ma = function(a, b) {
	var c;
	c = B[this.id[a]][ch];
	if (0 == this.d[a]) this.d[a] = 1;
	else if (1 == this.d[a] || 2 == this.d[a]) {
		4 == b ? 
			(W(this.a[a][0], this.c[a][0], -0.2, 0.99), 
			W(this.a[a][1], this.c[a][1], 0, 0.99), 
			W(this.a[a][2], this.c[a][2], -0.1, 0.99), 
			W(this.a[a][3], this.c[a][3], 0, 0.99), 
			W(this.a[a][4], this.c[a][4], 0, 0.99), 
			W(this.a[a][5], this.c[a][5], 0, 0.99), 
			W(this.a[a][6], this.c[a][6], 0, 0.99), 
			W(this.a[a][7], this.c[a][7], 0, 0.99), 
			W(this.a[a][8], this.c[a][8], 0, 0.99), 
			W(this.a[a][9], this.c[a][9], 0.3, 0.99), 
			W(this.a[a][10], this.c[a][10], 0.3, 0.99)) : 
		12 == b ? 
			(W(this.a[a][0], this.c[a][0], -0.02, 0.99), 
			W(this.a[a][1], this.c[a][1], 0, 0.99), 
			W(this.a[a][2], this.c[a][2], -0.01, 0.99), 
			W(this.a[a][3], this.c[a][3], 0, 0.99), 
			W(this.a[a][4], this.c[a][4], 0, 0.99), 
			W(this.a[a][5], this.c[a][5], 0, 0.99), 
			W(this.a[a][6], this.c[a][6], 0, 0.99), 
			W(this.a[a][7], this.c[a][7], 0, 0.99), 
			W(this.a[a][8], this.c[a][8], 0, 0.99), 
			W(this.a[a][9], this.c[a][9], 0.1, 0.99), 
			W(this.a[a][10], this.c[a][10], 0.1, 0.99)) : 
		20 == b && 
			(W(this.a[a][0], this.c[a][0], -0.1, 0.99), 
			W(this.a[a][1], this.c[a][1], 0, 0.99), 
			W(this.a[a][2], this.c[a][2], -0.1, 0.99), 
			W(this.a[a][3], this.c[a][3], 0, 0.99), 
			W(this.a[a][4], this.c[a][4], 0, 0.99), 
			W(this.a[a][5], this.c[a][5], 0, 0.99), 
			W(this.a[a][6], this.c[a][6], 0, 0.99), 
			W(this.a[a][7], this.c[a][7], 0, 0.99), 
			W(this.a[a][8], this.c[a][8], 0, 0.99), 
			W(this.a[a][9], this.c[a][9], 0.35, 0.99), 
			W(this.a[a][10], this.c[a][10], 0.35, 0.99));
		if (50 > A(100) && 0 < (this.state[a] & 3) && b != 20) { //Stickman and zombie
			var d = v.m(this.a[a][0].x - 200, this.a[a][0].y - 50, this.a[a][0].x + 200, this.a[a][0].y + 50, 0); 
			-1 != d ? 
				this.d[a] = v.a[d][2].x < this.a[a][0].x ? 1 : 2 : 
					10 > A(100) && (this.d[a] = Kf(1, 2));
			var e = d = 1,
				g = 0;
			12 == b && (d = 0.25, e = 0.3, g = 0.25);
			1 == this.d[a] ? 
				(this.a[a][9].x < this.a[a][10].x ? 
					(this.a[a][10].x += A(-d), this.a[a][10].y += -e) : 
					(this.a[a][9].x += A(-d), this.a[a][9].y += -e), 
				this.a[a][5].x += A(-g), 
				this.a[a][6].x += A(-g)) : 
				(this.a[a][9].x < this.a[a][10].x ? 
					(this.a[a][9].x += A(d), this.a[a][9].y += -e) : 
					(this.a[a][10].x += A(d), this.a[a][10].y += -e), 
				this.a[a][5].x += A(g), 
				this.a[a][6].x += A(g))
		} else if (b == 20) { //Wizard
			var targetDistance = 0, speed = 0.25, d = v.m(this.a[a][0].x - 80, this.a[a][0].y - 80, this.a[a][0].x + 80, this.a[a][0].y + 80, 0); //Find target
			-1 != d ? 
				(targetDistance = v.a[d][2].x - this.a[a][0].x, //Distance from target
				this.d[a] = v.a[d][2].x < this.a[a][0].x ? 1 : 2) : //Target on the left or right?
				10 > A(100) && (this.d[a] = Kf(1, 2)); //If no target
			if (Kg(targetDistance) < 40) speed *= -1;
			1 == this.d[a] ? 
				(this.a[a][1].x += A(-speed), //Target to the left
				this.a[a][2].x += A(-speed)) : 
				(this.a[a][1].x += A(speed), //Target to the right
				this.a[a][2].x += A(speed));
			speed = 0.25;
			-1 != d ? 
				this.d[a] = v.a[d][0].y - 40 < this.a[a][0].y ? 1 : 2 : //Target above or below?
				10 > A(100) && (this.d[a] = Kf(1, 2)); //If no target
			1 == this.d[a] ? 
				(this.a[a][1].y -= speed) : //Target above
				(this.a[a][1].y += speed); //Target below
			this.a[a][5].x -= 1;
			this.a[a][5].y -= 0.25;
			this.a[a][6].x += 1;
			this.a[a][6].y -= 0.25;
		}
		d = 0.5;
		e = 1.2 * c;
		12 == b && (d = 0.02, e = 1 * c);
		Y(this.a[a][0], this.a[a][1], 3 * e, d, d);
		Y(this.a[a][1], this.a[a][2], 3 * e, d, d);
		Y(this.a[a][1], this.a[a][3], 4 * e, d, d);
		Y(this.a[a][1], this.a[a][4], 4 * e, d, d);
		Y(this.a[a][3], this.a[a][5], 4 * e, d, d);
		Y(this.a[a][4], this.a[a][6], 4 * e, d, d);
		Y(this.a[a][2], this.a[a][7], 4 * e, d, d);
		Y(this.a[a][2], this.a[a][8], 4 * e, d, d);
		Y(this.a[a][7], this.a[a][9], 4 * e, d, d);
		Y(this.a[a][8], this.a[a][10], 4 * e, d, d);
		Y(this.a[a][7], this.a[a][8], 5 * e, d, d);
		this.p(a, 0); //Attack
		if (B[this.id[a]][Re] != 0) this.p(a, 1);
		for (c = this.state[a] = 0; 11 > c; c++) this.h(a, c, 0.5);
		this.a[a][this.n].set(this.a[a][1]);
		if (0 >= this.r[a]) {
			this.d[a] = 3;
			for (c = this.count[a] = 0; 11 > c; c++) this.a[a][c].x += N(-1, 1), this.a[a][c].y -= N(1, 2);
			Jg(this, a, 0)
		}
	} else {
		for (c = 0; 11 > c; c++) W(this.a[a][c], this.c[a][c], 0.05, 0.99);
		d = 0.5;
		e = 1.2 * (150 - this.count[a]) / 150;
		Y(this.a[a][1], this.a[a][2], 3 * e, d, d);
		Y(this.a[a][3], this.a[a][5], 4 * e, d, d);
		Y(this.a[a][4], this.a[a][6], 4 * e, d, d);
		Y(this.a[a][7], this.a[a][9], 4 * e, d, d);
		Y(this.a[a][8], this.a[a][10], 4 * e, d, d);
		for (c = this.state[a] = 0; 11 > c; c++) this.h(a, c, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.na; //Tree
hh.prototype.na = function(a, b) {
	var c, d = B[this.id[a]][ch];
	if (0 == this.d[a]) this.d[a] = z(N(4, 8));
	else if (10 > this.d[a]) {
		if (5 == b) {
			for (c = 0; c < this.d[a] - 1; c++) W(this.a[a][c], this.c[a][c], -0.04, 0.99);
			W(this.a[a][c], this.c[a][c], 1, 0.99)
		} else {
			for (c = 0; c < this.d[a] - 1; c++) W(this.a[a][c], this.c[a][c], 0.04, 0.99);
			W(this.a[a][c], this.c[a][c], -1, 0.99)
		}
		10 > A(100) && (c = z(A(4)), this.a[a][c].x += N(-0.5, 0.5));
		Y(this.a[a][0], this.a[a][1], 8 * d, 0.2, 0.2);
		for (c = 1; c < this.d[a] - 2; c++) Y(this.a[a][c], this.a[a][c + 1], 6 * d, 0.2, 0.2);
		Y(this.a[a][c], this.a[a][c + 1], 6 * d, 0.2, 0);
		this.p(a, 0);
		for (c = this.state[a] = 0; c < this.d[a]; c++) this.h(a, c, 0.5);
		this.a[a][this.n].x = 0.5 * (this.a[a][0].x + this.a[a][this.d[a] - 1].x);
		this.a[a][this.n].y = 0.5 * (this.a[a][0].y + this.a[a][this.d[a] - 1].y);
		if (0 >= this.r[a]) {
			for (c = 0; c < this.d[a]; c++) this.a[a][c].x += N(-0.5, 0.5), this.a[a][c].y -= N(2, 3);
			this.d[a] += 10;
			Jg(this, a, 0)
		}
	} else {
		for (c = 0; c < this.d[a] - 10; c++) W(this.a[a][c], this.c[a][c], 0.05, 0.99);
		for (c = this.state[a] = 0; c < this.d[a] - 10; c++) this.h(a, c, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.va; //Wheel
hh.prototype.va = function(a) {
	var b, c = B[this.id[a]][ch];
	if (0 == this.d[a]) {
		this.a[a][0].x += 1;
		this.a[a][0].y += 1;
		this.a[a][1].x += 1;
		this.a[a][1].y += 0;
		this.a[a][2].x += 1.85;
		this.a[a][2].y += 0.5;
		this.a[a][3].x += 1.85;
		this.a[a][3].y += 1.5;
		this.a[a][4].x += 1;
		this.a[a][4].y += 2;
		this.a[a][5].x += 1 - 0.85;
		this.a[a][5].y += 1.5;
		this.a[a][6].x += 1 - 0.85;
		this.a[a][6].y += 0.5;
		for (b = 0; 7 > b; b++) this.c[a][b].set(this.a[a][b]);
		this.d[a] = 1
	} else if (1 == this.d[a] || 2 == this.d[a]) {
		W(this.a[a][0], this.c[a][0], 0.5, 0.99);
		for (b = 1; 7 > b; b++) W(this.a[a][b], this.c[a][b], 0, 0.99);
		b = v.m(this.a[a][0].x - 200, this.a[a][0].y - 50, this.a[a][0].x + 200, this.a[a][0].y + 50, 0); - 1 != b && 40 > A(100) && 0 < (this.state[a] & 2) && (this.a[a][0].x += v.a[b][2].x < this.a[a][0].x ? -2 : 2);
		var d = 0.1,
			c = 1.2 * c;
		for (b = 1; 4 > b; b++) Y(this.a[a][b], this.a[a][b + 3], 20 * c, d, d);
		for (b = 1; 5 > b; b++) Y(this.a[a][b], this.a[a][b + 2], 17 * c, d, d);
		Y(this.a[a][b + 0], this.a[a][1], 17 * c, d, d);
		Y(this.a[a][b + 1], this.a[a][2], 17 * c, d, d);
		for (b = 1; 6 > b; b++) Y(this.a[a][b], this.a[a][b + 1], 10 * c, d, d);
		Y(this.a[a][b], this.a[a][1], 10 * c, d, d);
		for (b = 1; 7 > b; b++) Y(this.a[a][0], this.a[a][b], 10 * c, 0.2, 0.2);
		this.p(a, 0);
		for (b = this.state[a] = 0; 7 > b; b++) this.h(a, b, 0.5);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a] = 3;
			for (b = this.count[a] = 0; 7 > b; b++) this.a[a][b].x += N(-0.5, 0.5), this.a[a][b].y -= N(2, 3);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 7 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		d = 0.5;
		c = 1.2 * c * (150 - this.count[a]) / 150;
		for (b = 1; 6 > b; b++) Y(this.a[a][b], this.a[a][b + 1], 10 * c, d, d);
		for (b = this.state[a] = 0; 7 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.wa; //Fish
hh.prototype.wa = function(a) {
	var b, c = new Qg,
		d = B[this.id[a]][ch];
	if (0 == this.d[a]) this.d[a] = 1;
	else if (1 == this.d[a] || 2 == this.d[a]) {
		W(this.a[a][0], this.c[a][0], 0, 0.99);
		for (b = 1; 5 > b; b++) W(this.a[a][b], this.c[a][b], 0, 0.9);
		Rg(c, 0, 0);
		b = v.m(this.a[a][0].x - 150, this.a[a][0].y - 50, this.a[a][0].x + 150, this.a[a][0].y + 50, 0); - 1 != b && (c.q(v.a[b][2], this.a[a][0]), b = Xg(c), b -= B[this.id[a]][32] / 2 - 10, 0 > b ? Tg(c, -0.01) : Tg(c, 0.01));
		0 > I.e[z(K(this.a[a][0].y - 7, 0, 255) / 8)][z(K(this.a[a][0].x, 0, 511) / 8)] && (c.y += 0.03);
		2 > A(100) && (c.x += N(-0.5, 0.5), c.y += N(-0.5, 0.5));
		this.a[a][0].add(c);
		c = 0.1;
		b = 6 * d;
		Y(this.a[a][0], this.a[a][1], 9 * d, 0, c);
		Y(this.a[a][1], this.a[a][2], 5 * d, 0, c);
		Y(this.a[a][2], this.a[a][3], 6 * d, 0, c);
		Y(this.a[a][2], this.a[a][4], 6 * d, 0, c);
		Y(this.a[a][3], this.a[a][4], 8 * d, c, c);
		this.p(a, 0);
		for (b = this.state[a] = 0; 5 > b; b++) this.h(a, b, 0.5);
		this.a[a][this.n].set(this.a[a][1]);
		if (0 >= this.r[a]) {
			this.d[a] = 3;
			for (b = this.count[a] = 0; 5 > b; b++) this.a[a][b].x += N(-2, 2), this.a[a][b].y -= N(2, 4);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 5 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		c = 0.5;
		b = 7 * d * (150 - this.count[a]) / 150;
		Y(this.a[a][2], this.a[a][3], b, c, c);
		Y(this.a[a][2], this.a[a][4], b, c, c);
		Y(this.a[a][3], this.a[a][4], b, c, c);
		for (b = this.state[a] = 0; 5 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.xa; //Mushroom
hh.prototype.xa = function(a) {
	var b, c = B[this.id[a]][ch];
	if (0 == this.d[a]) this.a[a][0].x += 0, this.a[a][0].y += 0, this.a[a][1].x += 0, this.a[a][1].y += 1, this.a[a][2].x += 0, this.a[a][2].y += 3, this.d[a]++;
	else if (1 == this.d[a]) {
		for (b = 0; 2 > b; b++) W(this.a[a][b], this.c[a][b], -0.04, 0.99);
		W(this.a[a][b], this.c[a][b], 1, 0.99);
		Y(this.a[a][0], this.a[a][1], 7 * c, 0.2, 0.2);
		Y(this.a[a][1], this.a[a][2], 5 * c, 0.2, 0);
		this.a[a][0].x = this.a[a][1].x = this.a[a][2].x;
		0 < this.l[a] ? this.l[a]-- : 0 < this.S[a] && (this.a[a][0].y += N(0, 1), this.p(a, 0));
		this.S[a] = 0;
		for (b = this.state[a] = 0; 3 > b; b++) this.h(a, b, 0.5);
		this.a[a][this.n].x = this.a[a][0].x;
		this.a[a][this.n].y = 0.5 * (this.a[a][0].y + this.a[a][1].y);
		if (0 >= this.r[a]) {
			this.d[a]++;
			for (b = 0; 3 > b; b++) this.a[a][b].x += N(-0.5, 0.5), this.a[a][b].y -= N(2, 3);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 3 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		for (b = this.state[a] = 0; 3 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.eb; //Eel
hh.prototype.eb = function(a, b) {
	var c, d = new Qg,
		e = B[this.id[a]][ch];
	if (0 == this.d[a]) 50 > A(100) ? this.d[a] = 1 : this.d[a] = 2;
	else if (1 == this.d[a] || 2 == this.d[a]) {
		W(this.a[a][0], this.c[a][0], 0, 0.98);
		for (c = 1; 6 > c; c++) W(this.a[a][c], this.c[a][c], 0, 0.9);
		if (9 == b) {
			Rg(d, 0, 0);
			c = v.m(this.a[a][0].x - 150, this.a[a][0].y - 50, this.a[a][0].x + 150, this.a[a][0].y + 50, 0); - 1 != c && (d.q(v.a[c][2], this.a[a][0]), c = Xg(d), c -= B[this.id[a]][32] / 2 - 10, 0 > c ? (Tg(d, -0.05), 384 < this.a[a][0].x && dh(d), 128 > this.a[a][0].x && (dh(d), Tg(d, -1))) : Tg(d, 0.01));
			c = z(K(this.a[a][0].x, 0, 511) / 8);
			var g = z(K(this.a[a][0].y - 7, 0, 255) / 8);
			c = I.e[g][c];
			0 > c && (d.y += 0.05);
			c = z(K(this.a[a][0].x + d.x, 0, 511) / 8);
			g = z(K(this.a[a][0].y + d.y, 0, 255) / 8);
			c = I.e[g][c];
			0 <= c && 8 >= c && dh(d)
		} else Rg(d, 0, 0), c = v.m(this.a[a][0].x - 500, this.a[a][0].y - 500, this.a[a][0].x + 500, this.a[a][0].y + 500, 0), -1 != c && (d.q(v.a[c][2], this.a[a][0]), c = Xg(d), c -= B[this.id[a]][32] / 2 - 10, 0 > c ? (1 == this.d[a] ? Tg(d, -0.05) : Tg(d, 0.05), dh(d)) : Tg(d, 0.02)), c = z(K(this.a[a][0].x + d.x, 0, 511) / 8), g = z(K(this.a[a][0].y + d.y, 0, 255) / 8), c = I.e[g][c], 0 <= c && 8 >= c && (dh(d), 2 == this.d[a] && Tg(d, -1)), c = z(K(this.a[a][0].x + d.x, 0, 511) / 8), g = z(K(this.a[a][0].y + d.y, 0, 255) / 8), c = I.e[g][c], 0 <= c && 8 >= c && (dh(d), 2 == this.d[a] && Tg(d, -1));
		2 > A(100) && (d.x += N(-0.5, 0.5), d.y += N(-0.5, 0.5));
		this.a[a][0].add(d);
		for (c = 0; 6 > c; c++) Y(this.a[a][c], this.a[a][c + 1], 6 * e, 0, 0.5);
		0 == B[this.id[a]][Re] ? this.p(a, 0) : this.p(a, 50 > A(100) ? 0 : 1);
		for (c = this.state[a] = 0; 6 > c; c++) this.h(a, c, 0.5);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a] = 3;
			for (c = this.count[a] = 0; 6 > c; c++) this.a[a][c].x += N(-2, 2), this.a[a][c].y -= N(2, 4);
			Jg(this, a, 0)
		}
	} else {
		for (c = 0; 6 > c; c++) W(this.a[a][c], this.c[a][c], 0.05, 0.99);
		d = 6 * (150 - this.count[a]) / 150;
		for (c = 1; 5 > c; c++) Y(this.a[a][c], this.a[a][c + 1], d * e, 0, 0.5);
		for (c = this.state[a] = 0; 6 > c; c++) this.h(a, c, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.mb; //Spider
hh.prototype.mb = function(a) {
	var b;
	b = B[this.id[a]][ch];
	if (0 == this.d[a]) {
		this.a[a][0].x += 4;
		this.a[a][0].y += 0;
		this.a[a][1].x += 0;
		this.a[a][1].y += 0;
		this.a[a][2].x += 0;
		this.a[a][2].y += 7.99;
		this.a[a][3].x += 7.99;
		this.a[a][3].y += 0;
		this.a[a][4].x += 7.99;
		this.a[a][4].y += 7.99;
		this.a[a][5].x += 0;
		this.a[a][5].y += 0;
		this.a[a][6].x += 0;
		this.a[a][6].y += 7.99;
		this.a[a][7].x += 7.99;
		this.a[a][7].y += 0;
		this.a[a][8].x += 7.99;
		this.a[a][8].y += 7.99;
		for (b = 0; 9 > b; b++) this.c[a][b].set(this.a[a][b]);
		this.d[a] = 1
	} else if (1 == this.d[a] || 2 == this.d[a]) {
		W(this.a[a][0], this.c[a][0], -0.05, 0.99);
		W(this.a[a][1], this.c[a][1], -0.1, 0.99);
		W(this.a[a][2], this.c[a][2], 0.8, 0.99);
		W(this.a[a][3], this.c[a][3], -0.1, 0.99);
		W(this.a[a][4], this.c[a][4], 0.8, 0.99);
		W(this.a[a][5], this.c[a][5], -0.1, 0.99);
		W(this.a[a][6], this.c[a][6], 0.8, 0.99);
		W(this.a[a][7], this.c[a][7], -0.1, 0.99);
		W(this.a[a][8], this.c[a][8], 0.8, 0.99);
		if (50 > A(100) && 0 < (this.state[a] & 3)) {
			var c = v.m(this.a[a][0].x - 500, this.a[a][0].y - 25, this.a[a][0].x + 500, this.a[a][0].y + 25, 0); - 1 != c ? this.d[a] = v.a[c][2].x <
				this.a[a][0].x ? 1 : 2 : 10 > A(100) && (this.d[a] = Kf(1, 2));
			1 == this.d[a] ? (this.a[a][2].x < this.a[a][6].x ? (this.a[a][6].x += A(-1), this.a[a][6].y += N(-1, -1)) : (this.a[a][2].x += A(-1), this.a[a][2].y += N(-1, -1)), this.a[a][4].x < this.a[a][8].x ? (this.a[a][8].x += A(-1), this.a[a][8].y += N(-1, -1)) : (this.a[a][4].x += A(-1), this.a[a][4].y += N(-1, -1)), 1 > A(100) && (this.a[a][0].x -= 1, this.a[a][0].y -= 3)) : (this.a[a][2].x < this.a[a][6].x ? (this.a[a][2].x += A(1), this.a[a][2].y += N(-1, -1)) : (this.a[a][6].x += A(1), this.a[a][6].y += N(-1, -1)), this.a[a][4].x <
				this.a[a][8].x ? (this.a[a][4].x += A(1), this.a[a][4].y += N(-1, -1)) : (this.a[a][8].x += A(1), this.a[a][8].y += N(-1, -1)), 1 > A(100) && (this.a[a][0].x += 1, this.a[a][0].y -= 3))
		}
		c = 0.3;
		b *= 2.2;
		Y(this.a[a][0], this.a[a][5], 3 * b, 0.1 * c, c);
		Y(this.a[a][0], this.a[a][7], 3 * b, 0.1 * c, c);
		Y(this.a[a][0], this.a[a][6], 3 * b, 0.1 * c, c);
		Y(this.a[a][5], this.a[a][6], 2 * b, 0.2 * c, 0.2 * c);
		Y(this.a[a][0], this.a[a][8], 3 * b, 0.1 * c, c);
		Y(this.a[a][7], this.a[a][8], 2 * b, 0.2 * c, 0.2 * c);
		Y(this.a[a][0], this.a[a][1], 4 * b, 0.1 * c, c);
		Y(this.a[a][0], this.a[a][3], 4 * b, 0.1 * c, c);
		Y(this.a[a][0], this.a[a][2], 4 * b, 0.1 * c, c);
		Y(this.a[a][1], this.a[a][2], 3 * b, 0.2 * c, 0.2 * c);
		Y(this.a[a][0], this.a[a][4], 4 * b, 0.1 * c, c);
		Y(this.a[a][3], this.a[a][4], 3 * b, 0.2 * c, 0.2 * c);
		Y(this.a[a][2], this.a[a][4], 8 * b, 0.1 * c, 0.1 * c);
		Y(this.a[a][5], this.a[a][7], 7 * b, 0.1 * c, 0.1 * c);
		this.p(a, 0);
		0 != B[this.id[a]][Re] && this.p(a, 1);
		for (b = this.state[a] = 0; 9 > b; b++) this.h(a, b, 0.5);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a] = 3;
			this.count[a] = 0;
			for (b = 1; 9 > b; b++) this.a[a][b].x += N(-1, 1), this.a[a][b].y -= N(1, 2);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 9 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		c = 0.5;
		b = 1.2 * (150 - this.count[a]) / 150;
		Y(this.a[a][1], this.a[a][2], 4 * b, c, c);
		Y(this.a[a][3], this.a[a][4], 4 * b, c, c);
		Y(this.a[a][5], this.a[a][6], 3 * b, c, c);
		Y(this.a[a][7], this.a[a][8], 3 * b, c, c);
		for (b = this.state[a] = 0; 9 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.nb; //Cactus
hh.prototype.nb = function(a) {
	var b, c = B[this.id[a]][ch];
	if (0 == this.d[a]) this.a[a][0].x += 1, this.a[a][0].y += 0, this.a[a][1].x += 0, this.a[a][1].y += 1, this.a[a][2].x += 2, this.a[a][2].y += 1, this.a[a][3].x += 1, this.a[a][3].y += 2, this.d[a]++;
	else if (1 == this.d[a]) {
		for (b = 0; 3 > b; b++) W(this.a[a][b], this.c[a][b], -0.04, 0.99);
		W(this.a[a][b], this.c[a][b], 1, 0.99);
		Y(this.a[a][0], this.a[a][3], 20 * c, 0.2, 0);
		Y(this.a[a][1], this.a[a][3], 15 * c, 0.2, 0);
		Y(this.a[a][2], this.a[a][3], 20 * c, 0.2, 0);
		this.a[a][0].x = this.a[a][3].x;
		this.a[a][1].x =
			this.a[a][3].x - 8 * c;
		this.a[a][2].x = this.a[a][3].x + 8 * c;
		0 < this.l[a] ? this.l[a]-- : 0 < this.S[a] && (this.a[a][0].y += N(0, 1), this.a[a][1].y += N(0, 1), this.a[a][2].y += N(0, 1), this.p(a, 0));
		this.S[a] = 0;
		for (b = this.state[a] = 0; 4 > b; b++) this.h(a, b, 0.5);
		this.a[a][this.n].x = this.a[a][0].x;
		this.a[a][this.n].y = 0.5 * (this.a[a][0].y + this.a[a][1].y);
		if (0 >= this.r[a]) {
			this.d[a]++;
			for (b = 0; 4 > b; b++) this.a[a][b].x += N(-0.5, 0.5), this.a[a][b].y -= N(2, 3);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 4 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		for (b = this.state[a] =
			0; 4 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.ob; //Copter
hh.prototype.ob = function(a) {
	var b, c = new Qg;
	b = B[this.id[a]][ch];
	if (0 == this.d[a]) {
		this.a[a][0].x += 2;
		this.a[a][0].y += 4;
		this.a[a][1].x += 2;
		this.a[a][1].y += 2;
		this.a[a][2].x += 0;
		this.a[a][2].y += 0;
		this.a[a][3].x += 4;
		this.a[a][3].y += 0;
		for (b = 0; 4 > b; b++) this.c[a][b].set(this.a[a][b]);
		this.d[a] = 1
	} else if (1 == this.d[a] || 2 == this.d[a]) {
		W(this.a[a][0], this.c[a][0], 0.1, 0.99);
		W(this.a[a][1], this.c[a][1], 0.1, 0.99);
		W(this.a[a][2], this.c[a][2], -0.1, 0.99);
		W(this.a[a][3], this.c[a][3], -0.1, 0.99);
		Rg(c, 0, 0);
		var d = v.m(this.a[a][0].x -
			150, this.a[a][0].y - 250, this.a[a][0].x + 150, this.a[a][0].y + 250, 0); - 1 != d && (c.x = v.a[d][2].x - this.a[a][0].x, c.y = v.a[d][2].y - 10 - this.a[a][0].y, c.x = -10 > c.x ? -0.02 : 10 < c.x ? 0.02 : N(-0.02, 0.02), d = B[this.id[a]][32] / 2, c.y = c.y < -d ? -0.02 : c.y > d ? 0.02 : N(-0.1, 0.1));
		this.a[a][0].add(c);
		this.a[a][2].x -= A(0.8);
		this.a[a][3].x += A(0.8);
		c = 0.3;
		Y(this.a[a][1], this.a[a][2], 8 * b, c, c);
		Y(this.a[a][1], this.a[a][3], 8 * b, c, c);
		Y(this.a[a][2], this.a[a][3], 16 * b, c, c);
		Y(this.a[a][0], this.a[a][2], 12 * b, c, c);
		Y(this.a[a][0], this.a[a][3], 12 * b, c,
			c);
		this.p(a, 0);
		for (b = this.state[a] = 0; 4 > b; b++) this.h(a, b, 1);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a] = 3;
			for (b = 0; 4 > b; b++) this.a[a][b].x += N(-1, 1), this.a[a][b].y -= N(1, 2);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 4 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		c = 0.3;
		b = (150 - this.count[a]) / 150;
		Y(this.a[a][1], this.a[a][2], 8 * b, c, c);
		Y(this.a[a][1], this.a[a][3], 8 * b, c, c);
		Y(this.a[a][2], this.a[a][3], 16 * b, c, c);
		for (b = this.state[a] = 0; 4 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.pb; //Bouncer
hh.prototype.pb = function(a) {
	var b;
	b = B[this.id[a]][ch];
	if (0 == this.d[a]) {
		this.a[a][0].x += 1;
		this.a[a][0].y += 0;
		this.a[a][1].x += 0;
		this.a[a][1].y += 1;
		this.a[a][2].x += 2;
		this.a[a][2].y += 1;
		for (b = 0; 3 > b; b++) this.c[a][b].set(this.a[a][b]);
		this.d[a]++
	} else if (1 == this.d[a]) {
		W(this.a[a][0], this.c[a][0], -0.15, 0.99);
		W(this.a[a][1], this.c[a][1], 0.1, 0.99);
		W(this.a[a][2], this.c[a][2], 0.1, 0.99);
		var c = v.m(this.a[a][0].x - 200, this.a[a][0].y - 50, this.a[a][0].x + 200, this.a[a][0].y + 50, 0);
		if (0 < (this.state[a] & 2) && 5 > A(100)) {
			var d =
				0,
				d = -1 != c ? v.a[c][2].x < this.a[a][0].x ? -1 : 1 : Kf(-1, 1);
			this.a[a][0].x += N(0.4, 0.6) * d;
			this.a[a][0].y += N(-1.5, -2)
		}
		c = 0.01;
		Y(this.a[a][0], this.a[a][1], 5 * b, c, c);
		Y(this.a[a][0], this.a[a][2], 5 * b, c, c);
		Y(this.a[a][1], this.a[a][2], 6 * b, c, c);
		1 < b && 0 < this.S[a] && 10 > A(100) && this.add(z(this.a[a][0].x / 8), z(this.a[a][0].y / 8), this.id[a] - 1);
		this.S[a] = 0;
		this.p(a, 0);
		for (b = this.state[a] = 0; 3 > b; b++) this.h(a, b, 0.9);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a]++;
			this.a[a][3].set(this.a[a][0]);
			this.c[a][3].set(this.a[a][0]);
			for (b = 0; 4 > b; b++) this.a[a][b].x += N(-0.5, 0.5), this.a[a][b].y -= N(2, 3);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 4 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		c = 0.01;
		b = (150 - this.count[a]) / 150;
		Y(this.a[a][0], this.a[a][1], 5 * b, c, c);
		Y(this.a[a][0], this.a[a][2], 5 * b, c, c);
		Y(this.a[a][1], this.a[a][2], 6 * b, c, c);
		for (b = this.state[a] = 0; 4 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.qb; //Germ
hh.prototype.qb = function(a) {
	var b, c = new Qg,
		d = B[this.id[a]][ch];
	if (0 == this.d[a]) this.d[a]++;
	else if (1 == this.d[a]) {
		for (b = 0; 10 > b; b++) W(this.a[a][b], this.c[a][b], 0, 0.98);
		0 >= this.count[a] && 5 > A(100) && (b = z(A(3)), 0 == b ? (c.x = (this.a[a][8].x + this.a[a][9].x) / 2 - this.a[a][7].x, c.y = (this.a[a][8].y + this.a[a][9].y) / 2 - this.a[a][7].y, Xg(c), Tg(c, d), this.a[a][7].add(c)) : 1 == b ? (c.x = (this.a[a][9].x + this.a[a][7].x) / 2 - this.a[a][8].x, c.y = (this.a[a][9].y + this.a[a][7].y) / 2 - this.a[a][8].y, Xg(c), Tg(c, d), this.a[a][8].add(c)) : 2 ==
			b && (c.x = (this.a[a][7].x + this.a[a][8].x) / 2 - this.a[a][9].x, c.y = (this.a[a][7].y + this.a[a][8].y) / 2 - this.a[a][9].y, Xg(c), Tg(c, d), this.a[a][9].add(c)), this.count[a] = 25 * d);
		Rg(c, 0, 0);
		b = v.m(this.a[a][0].x - 200, this.a[a][0].y - 200, this.a[a][0].x + 200, this.a[a][0].y + 200, 0);
		if (-1 != b)
			for (c.q(v.a[b][2], this.a[a][0]), Xg(c), b = 4; 7 > b; b++) this.a[a][b].x += 0.02 * c.x, this.a[a][b].y += 0.02 * c.y;
		c = 0.05;
		for (b = 1; 4 > b; b++) Y(this.a[a][0], this.a[a][b], 3 * d, c, c);
		for (b = 1; 4 > b; b++) Y(this.a[a][b], this.a[a][b + 3], 3 * d, c, c);
		for (b = 4; 7 > b; b++) Y(this.a[a][b],
			this.a[a][b + 3], 3 * d, c, 0.01);
		5 > this.count[a]-- && (c = 0.01 / d, Y(this.a[a][7], this.a[a][8], 20 * d, c, c), Y(this.a[a][8], this.a[a][9], 20 * d, c, c), Y(this.a[a][9], this.a[a][7], 20 * d, c, c));
		this.p(a, 0);
		for (b = this.state[a] = 0; 10 > b; b++) this.h(a, b, 0.9);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a]++;
			for (b = this.count[a] = 0; 4 > b; b++) this.a[a][b].x += N(-0.5, 0.5), this.a[a][b].y -= N(2, 3);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 10 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.98);
		var c = 0.05,
			e = (150 - this.count[a]) / 150;
		for (b = 1; 4 > b; b++) Y(this.a[a][b], this.a[a][b + 3], 3 * d * e, c, c);
		for (b = 4; 7 > b; b++) Y(this.a[a][b], this.a[a][b + 3], 3 * d * e, c, c);
		for (b = this.state[a] = 0; 10 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.rb; //Digger
hh.prototype.rb = function(a) {
	var b, c = B[this.id[a]][ch];
	if (0 == this.d[a]) this.d[a] = z(N(4, 7)), this.count[a] = z(A(400));
	else if (10 > this.d[a]) {
		500 > this.count[a] ? W(this.a[a][0], this.c[a][0], 0.1, 0.99) : W(this.a[a][0], this.c[a][0], -0.1, 0.99);
		for (b = 1; b < this.d[a] - 1; b++) W(this.a[a][b], this.c[a][b], 0, 0.99);
		W(this.a[a][b], this.c[a][b], 1, 0.99);
		10 > A(100) && (b = z(A(4)), this.a[a][b].x += N(-0.5, 0.5));
		this.count[a]++;
		600 < this.count[a] && (this.count[a] = z(A(400)));
		Y(this.a[a][0], this.a[a][1], 8 * c, 0.2, 0.2);
		for (b = 1; b < this.d[a] -
			2; b++) Y(this.a[a][b], this.a[a][b + 1], 6 * c, 0.2, 0.2);
		Y(this.a[a][b], this.a[a][b + 1], 6 * c, 0.2, 0);
		this.p(a, 0);
		this.state[a] = 0;
		for (b = this.d[a] - 1; b < this.d[a]; b++) this.h(a, b, 0.5);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			for (b = 0; b < this.d[a]; b++) this.a[a][b].x += N(-0.5, 0.5), this.a[a][b].y -= N(2, 3);
			this.count[a] = 0;
			Jg(this, a, 0);
			this.d[a] += 10
		}
	} else {
		for (b = 0; b < this.d[a] - 10; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		this.state[a] = 0;
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.hopper; //Hopper
hh.prototype.hopper = function(a) {
	var b, size;
	size = B[this.id[a]][ch];
	if (0 == this.d[a]) {
		this.a[a][0].x += 0; //Head
		this.a[a][1].x += 1; //Right leg
		this.a[a][2].x += 2;
		this.a[a][3].x -= 1; //Left leg
		this.a[a][4].x -= 2;
		this.a[a][5].x += 1; //Front right leg
		this.a[a][6].x -= 1; //Front left leg
		for (b = 0; 5 > b; b++) this.c[a][b].set(this.a[a][b]);
		this.d[a] = 1
	} else if (1 == this.d[a] || 2 == this.d[a]) {
		W(this.a[a][0], this.c[a][0], 0.05, 0.99); //Gravity
		W(this.a[a][1], this.c[a][1], 0.05, 0.8);
		W(this.a[a][2], this.c[a][2], 0.05, 0.5);
		W(this.a[a][3], this.c[a][3], 0.05, 0.8);
		W(this.a[a][4], this.c[a][4], 0.05, 0.5);
		W(this.a[a][5], this.c[a][5], 0.05, 0.8);
		W(this.a[a][6], this.c[a][6], 0.05, 0.8);
		//Find target
		b = v.m(this.a[a][0].x - 200, this.a[a][0].y - 50, this.a[a][0].x + 200, this.a[a][0].y + 50, 0);
		-1 != b && (this.a[a][0].x += v.a[b][2].x < this.a[a][0].x ? -0.001 : 0.001);
		if (0 < (this.state[a] & 2)) { //If grounded
			var c = 0, //c = direction
			c = -1 != b ? v.a[b][2].x < this.a[a][0].x ? -1 : 1 : Kf(-1, 1);
			//Random chance to jump
			if (5 > A(100)) {
				this.a[a][0].x += N(1, 2) * c; 
				this.a[a][0].y += N(-2, -3);
				this.a[a][1].x -= 2 * c;
				this.a[a][1].y += 4;
				this.a[a][2].x -= 2 * c;
				this.a[a][2].y += 3;
				this.a[a][3].x -= 2 * c;
				this.a[a][3].y += 4;
				this.a[a][4].x -= 2 * c;
				this.a[a][4].y += 3;
			}
		}
		//Joint positioning
		this.a[a][1].x += 0.5*size;
		this.a[a][1].y -= 1*size;
		this.a[a][2].x += 0.5*size;
		this.a[a][2].y += 1*size;
		this.a[a][3].x -= 0.5*size;
		this.a[a][3].y -= 1*size;
		this.a[a][4].x -= 0.5*size;
		this.a[a][4].y += 1*size;
		this.a[a][5].x += 0.3*size;
		this.a[a][5].y += 0.5*size;
		this.a[a][6].x -= 0.3*size;
		this.a[a][6].y += 0.5*size;
		//Joint connections
		Y(this.a[a][0], this.a[a][1], 1*size, 0, 0.1);
		Y(this.a[a][1], this.a[a][2], 2*size, 0, 0.1);
		Y(this.a[a][0], this.a[a][3], 1*size, 0, 0.1);
		Y(this.a[a][3], this.a[a][4], 2*size, 0, 0.1);
		Y(this.a[a][0], this.a[a][5], 0.3*size, 0, 0.1);
		Y(this.a[a][0], this.a[a][6], 0.3*size, 0, 0.1);
		
		this.p(a, 0); //Attack
		this.state[a] = 0; //Reset grounded status
		this.h(a, 0, 0.5);
		b = this.state[a];
		this.h(a, 2, 0.5);
		this.h(a, 4, 0.5);
		this.h(a, 5, 0.5);
		this.h(a, 6, 0.5);
		this.state[a] = b;
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a] = 3;
			for (b = 0; 7 > b; b++) this.a[a][b].x += N(-0.5, 0.5), this.a[a][b].y -= N(2, 3);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 7 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		//Joint connections while dying
		Y(this.a[a][0], this.a[a][1], 1*size, 0, 0.9);
		Y(this.a[a][1], this.a[a][2], 2*size, 0, 0.1);
		Y(this.a[a][0], this.a[a][3], 1*size, 0, 0.9);
		Y(this.a[a][3], this.a[a][4], 2*size, 0, 0.1);
		Y(this.a[a][0], this.a[a][5], 0.5*size, 0, 0.9);
		Y(this.a[a][0], this.a[a][6], 0.5*size, 0, 0.9);
		for (b = this.state[a] = 0; 7 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
};
da.fff = hh.prototype.warper; //Warper
hh.prototype.warper = function(a) {
	var b, c, size;
	size = B[this.id[a]][ch];
	if (0 == this.d[a]) {
		for (b = 0; 7 > b; b++) this.c[a][b].set(this.a[a][b]);
		this.d[a] = 1
	} else if (1 == this.d[a] || 2 == this.d[a] || 3 == this.d[a]) {
		W(this.a[a][0], this.c[a][0], 0, 0.5);
		W(this.a[a][1], this.c[a][1], 0, 0.8);
		W(this.a[a][2], this.c[a][2], 0, 0.8);
		W(this.a[a][3], this.c[a][3], 0, 0.8);
		W(this.a[a][4], this.c[a][4], 0, 0.8);
		W(this.a[a][5], this.c[a][5], 0, 0.8);
		W(this.a[a][6], this.c[a][6], 0, 0.8);
		//Find target
		b = v.m(this.a[a][0].x - 200, this.a[a][0].y - 200, this.a[a][0].x + 200, this.a[a][0].y + 200, 0);
		if (-1 != b) (c = v.a[b][2].x - this.a[a][0].x, b = v.a[b][2].y - this.a[a][0].y);
		else (b = 0, c = 0);
		if (this.d[a] == 2) {
			this.count[a] += 10;
			if (this.count[a] >= 150) { //Teleport
				this.a[a][0].x += N(-16, 16) + c; 
				this.a[a][0].y += N(-16, 16) + b;
				this.d[a] = 3;
			}
		}
		else if (this.count[a] > 0) {
			this.count[a] -= 10;
		}
		if (1 > A(100)) this.d[a] = 2;
		//Joint positioning and connections
		for (b = 1; b < 7; b++) {
			this.a[a][b].x = this.a[a][0].x + 12 * size * Xe[8 * this.clock + b * 85 &511][0];
			this.a[a][b].y = this.a[a][0].y + 12 * size * Xe[8 * this.clock + b * 85 &511][1];
			Y(this.a[a][0], this.a[a][b], size, 0, 0.1);
		}
		this.p(a, 0); //Attack
		this.state[a] = 0;
		this.h(a, 0, 0.1);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a] = 4;
			for (b = 0; 7 > b; b++) this.a[a][b].x += N(-0.5, 0.5), this.a[a][b].y -= N(-0.5, 0.5);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 7 > b; b++) W(this.a[a][b], this.c[a][b], N(-4, 0), 0.1);
		for (b = this.state[a] = 0; 7 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
}
da.fff = hh.prototype.egg; //Egg
hh.prototype.egg = function(a) {
	var b, size;
	size = B[this.id[a]][ch];
	if (0 == this.d[a]) {
		this.c[a][0].set(this.a[a][0]);
		this.d[a] = 1
	} else if (1 == this.d[a]) {
		W(this.a[a][0], this.c[a][0], 0.5, 0.8);
		this.state[a] = 0;
		this.h(a, 0, 0.1);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) { //Die
			this.p(a, 0); //Attack
			this.d[a] = 2;
			Jg(this, a, 0)
		}
	} else {
		W(this.a[a][0], this.c[a][0], 0.8, 0.1);
		this.state[a] = 0;
		this.h(a, 0, 0.5);
		this.count[a]++;
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
}
da.fff = hh.prototype.cell; //Cell
hh.prototype.cell = function(a) {
	var b, c = B[this.id[a]][ch], dir = new Qg;
	if (0 == this.d[a]) {
		for (b = 1; b < 7; b++) (this.a[a][b].x += Xe[b*85&511][0], this.a[a][b].y += Xe[b*85&511][1]);
		for (b = 0; b < 7; b++) this.c[a][b].set(this.a[a][b]);
		this.d[a] = 1
	} else if (1 == this.d[a] || 2 == this.d[a]) {
		var d = 32 * c;
		W(this.a[a][0], this.c[a][0], 0, 0.99);
		for (b = 1; 7 > b; b++) W(this.a[a][b], this.c[a][b], 0, 0.99);
		b = this.getSpeciesIndex(23, 0, a); //Find the first cell
		if (b >= this.index) b = -1;
		if (b != -1) {
			dir.q(this.a[b][0], this.a[a][0]);
			dir.x += N(-d, d);
			dir.y += N(-d, d);
			Xg(dir);
			Tg(dir, 2);
		} else {
			b = v.m(this.a[a][0].x - 180, this.a[a][0].y - 180, this.a[a][0].x + 180, this.a[a][0].y + 180, 0);
			if (b != -1) {
				dir.q(v.a[b][2], this.a[a][0]);
				dir.x += N(-d, d);
				dir.y += N(-d, d);
				dir.y -= 16;
				Xg(dir);
				Tg(dir, 0.5);
				if (Kg(v.a[b][2].x - this.a[a][0].x) < 40) dir.x *= -1;
			} else {
				dir.x = N(-0.5, 0.5);
				dir.y = N(-0.5, 0.5);
			}
		}
		this.a[a][0].x += dir.x;
		this.a[a][0].y += dir.y;
		d = 0.1; //The rest is basically copied from wheel. No need to reinvent it. Yes, thank you, I know I'm a comedic genius.
		c = 1.2 * c;
		for (b = 1; 4 > b; b++) Y(this.a[a][b], this.a[a][b + 3], 20 * c, d, d);
		for (b = 1; 5 > b; b++) Y(this.a[a][b], this.a[a][b + 2], 17 * c, d, d);
		Y(this.a[a][b + 0], this.a[a][1], 17 * c, d, d);
		Y(this.a[a][b + 1], this.a[a][2], 17 * c, d, d);
		for (b = 1; 6 > b; b++) Y(this.a[a][b], this.a[a][b + 1], 10 * c, d, d);
		Y(this.a[a][b], this.a[a][1], 10 * c, d, d);
		for (b = 1; 7 > b; b++) Y(this.a[a][0], this.a[a][b], 10 * c, 0.2, 0.2);
		
		this.p(a, 0);
		for (b = this.state[a] = 0; 7 > b; b++) this.h(a, b, 0.5);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a] = 3;
			for (b = this.count[a] = 0; 7 > b; b++) this.a[a][b].x += N(-0.5, 0.5), this.a[a][b].y += N(-0.5, 0.5);
			Jg(this, a, 0)
		}
	} else {
		for (b = 0; 7 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.99);
		d = 0.5;
		c = 1.2 * c * (150 - this.count[a]) / 150;
		for (b = 1; 6 > b; b++) Y(this.a[a][b], this.a[a][b + 1], 10 * c, d, d);
		for (b = this.state[a] = 0; 7 > b; b++) this.h(a, b, 0.5);
		150 < this.count[a]++ && this.sub(a--)
	}
	return a
}
da.fff = hh.prototype.centipede; //Centipede
hh.prototype.centipede = function(a) {
	var b, size = B[this.id[a]][ch];
	if (0 == this.d[a]) {
		for (b = 0; 6 > b; b++) this.c[a][b].set(this.a[a][b]);
		if (this.id[a] == 66) this.phaseCooldown = 300;
		this.d[a] = 1
	} else if (this.d[a] > 0 && this.d[a] < 8) {
		var dir = new Qg;
		W(this.a[a][0], this.c[a][0], 0, 0.8); //Head
		W(this.a[a][1], this.c[a][1], 0, 0.6); //Back
		W(this.a[a][2], this.c[a][2], 0, 0.6); //Arms
		W(this.a[a][3], this.c[a][3], 0, 0.6);
		W(this.a[a][4], this.c[a][4], 0, 0.6);
		W(this.a[a][5], this.c[a][5], 0, 0.6);
		b = this.getSpeciesIndex(24, a + 1, 300);
		if (b >= this.index) b = -1;
		if (b != -1) { //This segment isn't the head
			dir.q(this.a[b][1], this.a[a][0]);
			Xg(dir);
			Tg(dir, 0.3);
			this.a[a][0].x += dir.x;
			this.a[a][0].y += dir.y;
			//Y(this.a[a][0], this.a[b][1], 4, 0.5, 0); //Connect this centipede segment smoothly to the next
			if (this.id[a] == 66) { //Foreverglade boss
				if (this.d[b] != 8) this.d[a] = this.d[b]; //Same attack phase as head
				switch (this.d[a]) {
					case 1:
						this.p(a, 0);
						break;
					case 2:
						this.p(a, 1);
						break;
					case 3:
					case 4:
						this.p(a, 2);
						break;
				}
			}
		} else { //This segment is the head
			b = v.m(this.a[a][0].x - 200, this.a[a][0].y - 200, this.a[a][0].x + 200, this.a[a][0].y + 200, 0);
			if (this.id[a] != 66) {
				if (b != -1) { //Follow target
					dir.q(v.a[b][2], this.a[a][0]);
					Xg(dir);
					Tg(dir, 0.25);
					this.a[a][0].x += dir.x + N(-0.1, 0.1);
					this.a[a][0].y += dir.y + N(-0.1, 0.1);
				} else { //Move in random direction
					dir.x = Xe[this.d[a] * 73 &511][0];
					dir.y = Xe[this.d[a] * 73 &511][1];
					Xg(dir);
					Tg(dir, 0.1);
					this.a[a][0].x += dir.x;
					this.a[a][0].y += dir.y;
					if (1 > A(100)) {
						this.d[a] = 1 + $g(7);
					}
				}
			}
			else { //Foreverglade boss
				if (this.phaseCooldown > 0) this.phaseCooldown--;
				switch (this.d[a]) {
					case 1: //Circling in the sky
						dir.x = 256 + 96 * Xe[2*this.clock&511][0] - this.a[a][0].x;
						dir.y = 96 + 32 * Xe[2*this.clock&511][1] - this.a[a][0].y;
						if (this.phaseCooldown == 0 && A(100) < 1) this.d[a] = 2;
						this.p(a, 0);
						break;
					case 2: //Going to a bottom corner
						if (this.a[a][0].x <= 256) { //Left corner
							dir.x = 16 - this.a[a][0].x;
							if (this.a[a][0].x < 24 && this.a[a][0].y > 212) this.d[a] = 3;
						} else { //Right corner
							dir.x = 496 - this.a[a][0].x;
							if (this.a[a][0].x > 488 && this.a[a][0].y > 212) this.d[a] = 4;
						}
						dir.y = 220 - this.a[a][0].y;
						this.p(a, 1);
						break;
					case 3: //Running along the ground to the right
						dir.x = 1;
						dir.y = Xe[8*this.clock&511][1];
						if (this.a[a][0].x > 488) this.d[a] = 1, this.phaseCooldown = 300;
						this.p(a, 2);
						break;
					case 4: //To the left
						dir.x = -1;
						dir.y = Xe[8*this.clock&511][1];
						if (this.a[a][0].x < 24) this.d[a] = 1, this.phaseCooldown = 300;
						this.p(a, 2);
						break;
				}
				if (this.getSpeciesIndex(24, 0, a) == -1) this.p(a, 3); //Last remaining segment
				Xg(dir);
				Tg(dir, 0.3);
				this.a[a][0].x += dir.x;
				this.a[a][0].y += dir.y;
			}
		}
		//Joint positioning
		b = N(0, 2);
		this.a[a][2].x += 2 * dir.x * b;
		this.a[a][2].y += 2 * dir.y * b;
		b = N(0, 2);
		this.a[a][4].x += 2 * dir.x * b;
		this.a[a][4].y += 2 * dir.y * b;
		
		this.a[a][3].x += 3 * dir.x;
		this.a[a][3].y += 3 * dir.y;
		this.a[a][5].x += 3 * dir.x;
		this.a[a][5].y += 3 * dir.y;
		dh(dir);
		this.a[a][2].x += 1 * dir.x;
		this.a[a][2].y += 1 * dir.y;
		dh(dir);
		this.a[a][1].x += 0.5 * dir.x;
		this.a[a][1].y += 0.5 * dir.y;
		dh(dir);
		this.a[a][4].x += 1 * dir.x;
		this.a[a][4].y += 1 * dir.y;
		
		Y(this.a[a][1], this.a[a][0], 8 * size, 0.9, 0);
		Y(this.a[a][2], this.a[a][0], 6 * size, 0.9, 0);
		Y(this.a[a][3], this.a[a][2], 4 * size, 0.9, 0);
		Y(this.a[a][4], this.a[a][0], 6 * size, 0.9, 0);
		Y(this.a[a][5], this.a[a][4], 4 * size, 0.9, 0);
		
		if (this.id[a] != 66) this.p(a, 0); //Attack
		this.state[a] = 0;
		this.h(a, 0, 1);
		this.a[a][this.n].set(this.a[a][0]);
		if (0 >= this.r[a]) {
			this.d[a] = 8;
			for (b = 0; 6 > b; b++) this.a[a][b].x += N(-0.5, 0.5), this.a[a][b].y -= N(-0.5, 0.5);
			Jg(this, a, 0);
		}
	} else {
		for (b = 0; 6 > b; b++) W(this.a[a][b], this.c[a][b], 0.05, 0.98);
		for (b = this.state[a] = 0; 6 > b; b++) this.h(a, b, 0.5);
		b = 1.2 * (150 - this.count[a]) / 150;
		Y(this.a[a][1], this.a[a][0], 8 * b, 0.9, 0);
		Y(this.a[a][2], this.a[a][0], 6 * b, 0.9, 0);
		Y(this.a[a][3], this.a[a][2], 4 * b, 0.9, 0);
		Y(this.a[a][4], this.a[a][0], 6 * b, 0.9, 0);
		Y(this.a[a][5], this.a[a][4], 4 * b, 0.9, 0);
		150 < this.count[a]++ && this.sub(a--);
	}
	return a
}

hh.prototype.getSpeciesIndex = function(species, from, to) {
	var a, index = -1;
	if (from < to) {
		for (a = from; a < to; a++) {
			if (this.step[a] == species && this.r[a] > 0) {
				index = a;
				break;
			}
		}
	} else {
		for (a = from - 1; a >= to; a--) {
			if (this.step[a] == species && this.r[a] > 0) {
				index = a;
				break;
			}
		}
	}
	return index;
}

da.fff = hh.prototype.b;
hh.prototype.b = function() { //Draw
	var a, b;
	for (a = 0; a < this.index; a++) {
		var c = B[this.id[a]][2],
			d = B[this.id[a]][4],
			e = B[this.id[a]][5],
			g = B[this.id[a]][ch];
		//ELEMENT statuses' effect on enemy color
		/*Gravity*/0 < this.gravityTimeEn[a] ? (d = 0x5F007F, e = 0x340049) : /*Freeze*/0 < this.B[a] ? (d = 5934817, e = 1989840) : /*Slow*/0 < this.C[a] ? (d = 1989840, e = 9840) : /*Poison*/0 < this.D[a] && (d = 3407616, e = 3381504);
		var k = (150 - this.count[a]) / 150 * g;
		switch (this.step[a]) {
			case 0:
				If(z(this.a[a][1].x - 0.5), z(this.a[a][1].y) - 2 * g, z(4 * k) + 1, z(4 * k) + 1, e);
				If(z(this.a[a][2].x - 0.5), z(this.a[a][2].y) - 2 * g, z(4 * k) + 1, z(4 * k) + 1, e);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 1:
				J(Va, z(this.a[a][2].x), z(this.a[a][2].y - 2 * k), z(8 * k), z(8 * k), 16 * c, 0, 16, 16, e);
				J(Va, z(this.a[a][1].x), z(this.a[a][1].y - 3 * k), z(12 * k), z(12 * k), 16 * c, 0, 16, 16, e);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y - 4 * k), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 2:
				L(this.a[a][1].x, this.a[a][1].y, this.a[a][2].x, this.a[a][2].y, e);
				L(this.a[a][2].x, this.a[a][2].y, this.a[a][3].x, this.a[a][3].y, e);
				L(this.a[a][3].x, this.a[a][3].y, this.a[a][1].x, this.a[a][1].y, e);
				L(this.a[a][4].x, this.a[a][4].y, this.a[a][5].x, this.a[a][5].y, e);
				L(this.a[a][5].x, this.a[a][5].y, this.a[a][6].x, this.a[a][6].y, e);
				L(this.a[a][6].x, this.a[a][6].y, this.a[a][4].x, this.a[a][4].y, e);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 3:
				3 > this.d[a] && (L(this.a[a][0].x, this.a[a][0].y, this.a[a][1].x, this.a[a][1].y, e), L(this.a[a][4].x, this.a[a][4].y, this.a[a][5].x, this.a[a][5].y, e));
				L(this.a[a][1].x, this.a[a][1].y, this.a[a][2].x, this.a[a][2].y, e);
				L(this.a[a][2].x, this.a[a][2].y, this.a[a][3].x, this.a[a][3].y, e);
				L(this.a[a][3].x, this.a[a][3].y, this.a[a][4].x, this.a[a][4].y, e);
				Hf(z(this.a[a][5].x), z(this.a[a][5].y), z(2 * k), z(2 * k), d);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 4:
			case 12:
			case 20: //Wizard
				L(this.a[a][1].x, this.a[a][1].y, this.a[a][2].x, this.a[a][2].y, e);
				3 > this.d[a] && (L(this.a[a][1].x, this.a[a][1].y, this.a[a][3].x, this.a[a][3].y, e), L(this.a[a][1].x, this.a[a][1].y, this.a[a][4].x, this.a[a][4].y, e));
				L(this.a[a][3].x, this.a[a][3].y, this.a[a][5].x, this.a[a][5].y, e);
				L(this.a[a][4].x, this.a[a][4].y, this.a[a][6].x, this.a[a][6].y, e);
				3 > this.d[a] && (L(this.a[a][2].x, this.a[a][2].y, this.a[a][7].x, this.a[a][7].y, e), L(this.a[a][2].x, this.a[a][2].y, this.a[a][8].x, this.a[a][8].y, e));
				L(this.a[a][7].x, this.a[a][7].y, this.a[a][9].x, this.a[a][9].y, e);
				L(this.a[a][8].x, this.a[a][8].y, this.a[a][10].x, this.a[a][10].y, e);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				332 == this.id[a] && J(Va, z(this.a[a][0].x), z(this.a[a][0].y - 3 * k), z(16 * k), z(16 * k), 352, 0, 16, 16, 16777215);
				break;
			case 5:
			case 18:
				var r = 5 == this.step[a] ? -2 : 2;
				for (b = 10 > this.d[a] ? this.d[a] - 1 : this.d[a] - 11; 0 < b; b--) If(z(this.a[a][b].x), z(this.a[a][b].y + r * k), z(4 * k) + 1, z(4 * k) + 1, e);
				5 == this.step[a] ? J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d) : J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 15, 16, -16, d);
				break;
			case 6:
				for (b = 1; 6 > b; b++) L(this.a[a][b].x, this.a[a][b].y, this.a[a][b + 1].x, this.a[a][b + 1].y, e);
				3 > this.d[a] && L(this.a[a][b].x, this.a[a][b].y, this.a[a][1].x, this.a[a][1].y, e);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 7:
				L(this.a[a][2].x, this.a[a][2].y, this.a[a][3].x, this.a[a][3].y, e);
				L(this.a[a][2].x, this.a[a][2].y, this.a[a][4].x, this.a[a][4].y, e);
				L(this.a[a][3].x, this.a[a][3].y, this.a[a][4].x, this.a[a][4].y, e);
				If(z(this.a[a][1].x), z(this.a[a][1].y), z(6 * k) + 1, z(6 * k) + 1, e);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 8:
				If(z(this.a[a][2].x) + z(1 * k), z(this.a[a][2].y - 2 * k), z(8 * k) + 1, z(4 * k) + 1, e);
				If(z(this.a[a][1].x), z(this.a[a][1].y - 2 * k), z(4 * k) + 1, z(4 * k) + 1, e);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 9:
			case 13:
				Hf(z(this.a[a][5].x), z(this.a[a][5].y), z(2 * k), z(2 * k), d);
				J(Va, z(this.a[a][4].x), z(this.a[a][4].y), z(8 * k), z(8 * k), 16 * c, 0, 16, 16, e);
				J(Va, z(this.a[a][3].x), z(this.a[a][3].y), z(10 * k), z(10 * k), 16 * c, 0, 16, 16, e);
				J(Va, z(this.a[a][2].x), z(this.a[a][2].y), z(12 * k), z(12 * k), 16 * c, 0, 16, 16, e);
				J(Va, z(this.a[a][1].x), z(this.a[a][1].y), z(14 * k), z(14 * k), 16 * c, 0, 16, 16, e);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 10:
				L(this.a[a][1].x, this.a[a][1].y, this.a[a][2].x, this.a[a][2].y, e);
				3 > this.d[a] && (L(this.a[a][0].x, this.a[a][0].y, this.a[a][1].x, this.a[a][1].y, e), L(this.a[a][0].x, this.a[a][0].y, this.a[a][3].x, this.a[a][3].y, e));
				L(this.a[a][1].x, this.a[a][1].y, this.a[a][2].x, this.a[a][2].y, e);
				L(this.a[a][3].x, this.a[a][3].y, this.a[a][4].x, this.a[a][4].y, e);
				3 > this.d[a] && (L(this.a[a][0].x, this.a[a][0].y, this.a[a][5].x, this.a[a][5].y, e), L(this.a[a][0].x, this.a[a][0].y, this.a[a][7].x, this.a[a][7].y, e));
				L(this.a[a][5].x, this.a[a][5].y, this.a[a][6].x, this.a[a][6].y, e);
				L(this.a[a][7].x, this.a[a][7].y, this.a[a][8].x, this.a[a][8].y, e);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 11:
				If(z(this.a[a][3].x), z(this.a[a][3].y - 7 * k), z(4 * k) + 1, z(14 * k) + 1, e);
				If(z(this.a[a][2].x) + 0, z(this.a[a][2].y), z(4 * k) + 1, z(9 * k) + 1, e);
				If(z(this.a[a][1].x) + 1, z(this.a[a][1].y), z(4 * k) + 1, z(8 * k) + 1, e);
				J(Va, z(this.a[a][0].x) + 1, z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 14:
				L(this.a[a][1].x, this.a[a][1].y, this.a[a][2].x, this.a[a][2].y, e);
				L(this.a[a][2].x, this.a[a][2].y, this.a[a][3].x, this.a[a][3].y, e);
				L(this.a[a][3].x, this.a[a][3].y, this.a[a][1].x, this.a[a][1].y, e);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 15:
				L(this.a[a][0].x, this.a[a][0].y, this.a[a][1].x, this.a[a][1].y, e);
				L(this.a[a][0].x, this.a[a][0].y, this.a[a][2].x, this.a[a][2].y, e);
				L(this.a[a][1].x, this.a[a][1].y, this.a[a][2].x, this.a[a][2].y, e);
				2 > this.d[a] ? J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d) : J(Va, z(this.a[a][3].x), z(this.a[a][3].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 16:
				if (2 > this.d[a])
					for (b = 1; 4 > b; b++) L(this.a[a][0].x, this.a[a][0].y, this.a[a][b].x, this.a[a][b].y, e);
				for (b = 4; 10 > b; b++) L(this.a[a][b - 3].x, this.a[a][b - 3].y, this.a[a][b].x, this.a[a][b].y, e);
				if (2 > this.d[a])
					for (b = 7; 10 > b; b++) Hf(z(this.a[a][b].x), z(this.a[a][b].y), z(2 * g), z(2 * g), d);
				else
					for (b = 7; 10 > b; b++) Hf(z(this.a[a][b].x) + 1, z(this.a[a][b].y) + 1, z(2 * k), z(2 * k), d);
				2 > this.d[a] ? J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * g), z(16 * g), 16 * c, 0, 16, 16, d) : J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 17:
				if (10 > this.d[a]) {
					for (b = this.d[a] - 1; 0 < b; b--) Hf(z(this.a[a][b].x), z(this.a[a][b].y - 2 * g), z(4 * g), z(4 * g), e);
					J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * g), z(16 * g), 16 * c, 0, 16, 16, d)
				} else {
					for (b = this.d[a] - 11; 0 < b; b--) If(z(this.a[a][b].x), z(this.a[a][b].y - 2 * k), z(4 * k) + 1, z(4 * k) + 1, e);
					J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d)
				}
				break;
			case 19: //Hopper
				L(this.a[a][0].x, this.a[a][0].y, this.a[a][1].x, this.a[a][1].y, e);
				L(this.a[a][1].x, this.a[a][1].y, this.a[a][2].x, this.a[a][2].y, e);
				L(this.a[a][0].x, this.a[a][0].y, this.a[a][3].x, this.a[a][3].y, e);
				L(this.a[a][3].x, this.a[a][3].y, this.a[a][4].x, this.a[a][4].y, e);
				L(this.a[a][0].x + 2, this.a[a][0].y, this.a[a][5].x, this.a[a][5].y, e);
				L(this.a[a][0].x - 2, this.a[a][0].y, this.a[a][6].x, this.a[a][6].y, e);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y) - 4 * k, z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 21: //Warper
				for (b = 1; b < 7; b++) V(this.a[a][b].x - k, this.a[a][b].y - k, z(2 * k), z(2 * k), e);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y), z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 22: //Egg
				V(this.a[a][0].x - 2 * k, this.a[a][0].y - 9 * k + 1, z(4 * k), z(9 * k), e);
				V(this.a[a][0].x - 3 * k, this.a[a][0].y - 8 * k + 1, z(6 * k), z(8 * k), e);
				V(this.a[a][0].x - 4 * k, this.a[a][0].y - 6 * k + 1, z(8 * k), z(5 * k), e);
				V(this.a[a][0].x - 1 * k, this.a[a][0].y - 8 * k + 1, z(2 * k), z(7 * k), d);
				V(this.a[a][0].x - 2 * k, this.a[a][0].y - 7 * k + 1, z(4 * k), z(6 * k), d);
				V(this.a[a][0].x - 3 * k, this.a[a][0].y - 5 * k + 1, z(6 * k), z(3 * k), d);
				break;
			case 23: //Cell
				for (b = 1; 6 > b; b++) L(this.a[a][b].x, this.a[a][b].y, this.a[a][b + 1].x, this.a[a][b + 1].y, e);
				3 > this.d[a] && L(this.a[a][b].x, this.a[a][b].y, this.a[a][1].x, this.a[a][1].y, e);
				J(Va, z(this.a[a][0].x) + 1 * k, z(this.a[a][0].y) + 1 * k, z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
			case 24: //Centipede
				L(this.a[a][0].x, this.a[a][0].y, this.a[a][2].x, this.a[a][2].y, e);
				L(this.a[a][0].x, this.a[a][0].y, this.a[a][4].x, this.a[a][4].y, e);
				L(this.a[a][2].x, this.a[a][2].y, this.a[a][3].x, this.a[a][3].y, e);
				L(this.a[a][4].x, this.a[a][4].y, this.a[a][5].x, this.a[a][5].y, e);
				J(Va, z(this.a[a][0].x), z(this.a[a][0].y) - 4 * k, z(16 * k), z(16 * k), 16 * c, 0, 16, 16, d);
				break;
		}
		0 < (xc & 2) && 0 < this.r[a] && (V(z(this.a[a][0].x) - 6 * g, z(this.a[a][0].y) - 10 * g, 12 * g, 1, 10027008), V(z(this.a[a][0].x) - 6 * g, z(this.a[a][0].y) - 10 * g, z(12 * g * this.r[a] / B[this.id[a]][lg]), 1, 52224))
	}
};
hh.prototype.M = function(a, b, c, d) { //Draw book icon
	var e = B[a][2],
		g = B[a][4],
		k = B[a][5],
		r = K(B[a][ch], 1, 4);
	1 == d && (r = 1);
	d = r;
	var m = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	switch (B[a][bh]) {
		case 0:
			m[0] = b + 0 * d;
			n[0] = c - 7 * d;
			m[1] = b - 5.5 * d;
			n[1] = c - 0 * d;
			m[2] = b + 6 * d;
			n[2] = c - 0 * d;
			break;
		case 1:
			m[0] = b - 3 * d;
			n[0] = c - 8 * d;
			m[1] = b + 1 * d;
			n[1] = c - 7 * d;
			m[2] = b + 4 * d;
			n[2] = c - 1 * d;
			break;
		case 2:
			m[0] = b + 0 * d;
			n[0] = c - 8 * d;
			m[1] = b - 4 * d;
			n[1] = c - 8 * d;
			m[2] = b - 9 * d;
			n[2] = c - 9 * d;
			m[3] = b - 7 * d;
			n[3] = c - 4 * d;
			m[4] = b + 3 * d;
			n[4] = c - 8 * d;
			m[5] = b + 9 * d;
			n[5] = c - 10 * d;
			m[6] = b + 7 * d;
			n[6] = c - 4 * d;
			break;
		case 3:
			m[0] = b - 3 * d;
			n[0] = c - 10 * d;
			m[1] = b + 1 * d;
			n[1] = c - 10 * d;
			m[2] = b + 4 * d;
			n[2] = c - 8 * d;
			m[3] = b + 5 * d;
			n[3] = c - 6 * d;
			m[4] = b + 5 * d;
			n[4] = c - 4 * d;
			m[5] = b + 3 * d;
			n[5] = c - 1 * d;
			break;
		case 4:
			m[0] = b + 0 * d;
			n[0] = c - 15 * d;
			m[1] = b + 0 * d;
			n[1] = c - 10 * d;
			m[2] = b + 0 * d;
			n[2] = c - 7 * d;
			m[3] = b - 2 * d;
			n[3] = c - 8 * d;
			m[4] = b + 3 * d;
			n[4] = c - 11 * d;
			m[5] = b - 5 * d;
			n[5] = c - 7 * d;
			m[6] = b + 5 * d;
			n[6] = c - 8 * d;
			m[7] = b - 3 * d;
			n[7] = c - 3 * d;
			m[8] = b + 3 * d;
			n[8] = c - 5 * d;
			m[9] = b - 1 * d;
			n[9] = c - 1 * d;
			m[10] = b + 2 * d;
			n[10] = c - 0 * d;
			break;
		case 5:
			m[0] = b + 0 * d;
			n[0] = c - 20 * d;
			m[1] = b + 0 * d;
			n[1] = c - 12 * d;
			m[2] = b - 1 * d;
			n[2] = c - 6 * d;
			m[3] = b + 0 * d;
			n[3] = c - 0 * d;
			break;
		case 18:
			d = K(d, 1, 2);
			m[0] = b + 0 * d;
			n[0] = c + 20 * d - 40;
			m[1] = b + 0 * d;
			n[1] = c + 12 * d - 40;
			m[2] = b - 1 * d;
			n[2] = c + 6 * d - 40;
			m[3] = b + 0 * d;
			n[3] = c + 0 * d - 40;
			break;
		case 6:
			m[0] = b + 0 * d;
			n[0] = c - 10 * d;
			m[1] = b - 7 * d;
			n[1] = c - 19 * d;
			m[2] = b + 5 * d;
			n[2] = c - 21 * d;
			m[3] = b + 12 * d;
			n[3] = c - 12 * d;
			m[4] = b + 7 * d;
			n[4] = c - 2 * d;
			m[5] = b - 5 * d;
			n[5] = c - 0 * d;
			m[6] = b - 12 * d;
			n[6] = c - 10 * d;
			break;
		case 7:
			m[0] = b - 5 * d;
			n[0] = c - 13 * d;
			m[1] = b + 0 * d;
			n[1] = c - 9 * d;
			m[2] = b + 5 * d;
			n[2] = c - 6 * d;
			m[3] = b + 8 * d;
			n[3] = c - 11 * d;
			m[4] = b + 10 * d;
			n[4] = c - 3 * d;
			break;
		case 8:
			m[0] = b + 0 * d;
			n[0] = c - 12 * d;
			m[1] = b + 0 * d;
			n[1] = c - 5 * d;
			m[2] = b + 0 * d;
			n[2] = c - 0 * d;
			break;
		case 9:
		case 13:
			m[0] = b - 4 * d;
			n[0] = c - 20 * d;
			m[1] = b + 2 * d;
			n[1] = c - 16 * d;
			m[2] = b + 4 * d;
			n[2] = c - 11 * d;
			m[3] = b + 2 * d;
			n[3] = c - 6 * d;
			m[4] = b - 1 * d;
			n[4] = c - 3 * d;
			m[5] = b - 5 * d;
			n[5] = c - 2 * d;
			break;
		case 10:
			m[0] = b + 0 * d;
			n[0] = c - 6 * d;
			m[1] = b - 9 * d;
			n[1] = c - 9 * d;
			m[2] = b - 7 * d;
			n[2] = c - 0 * d;
			m[3] = b + 9 * d;
			n[3] = c - 9 * d;
			m[4] = b + 7 * d;
			n[4] = c - 0 * d;
			m[5] = b - 7 * d;
			n[5] = c - 5 * d;
			m[6] = b - 5 * d;
			n[6] = c - 0 * d;
			m[7] = b + 7 * d;
			n[7] = c - 5 * d;
			m[8] = b + 5 * d;
			n[8] = c - 0 * d;
			break;
		case 11:
			m[0] = b + 0 * d;
			n[0] = c - 19 * d;
			m[1] = b - 8 * d;
			n[1] = c - 13 * d;
			m[2] = b + 8 * d;
			n[2] = c - 18 * d;
			m[3] = b + 0 * d;
			n[3] = c - 0 * d;
			break;
		case 12:
			m[0] = b + 0 * d;
			n[0] = c - 16 * d;
			m[1] = b + 0 * d;
			n[1] = c - 10 * d;
			m[2] = b + 2 * d;
			n[2] = c - 7 * d;
			m[3] = b - 2 * d;
			n[3] = c - 8 * d;
			m[4] = b - 3 * d;
			n[4] = c - 11 * d;
			m[5] = b - 5 * d;
			n[5] = c - 7 * d;
			m[6] = b - 8 * d;
			n[6] = c - 10 * d;
			m[7] = b - 1 * d;
			n[7] = c - 4 * d;
			m[8] = b + 2 * d;
			n[8] = c - 5 * d;
			m[9] = b - 0 * d;
			n[9] = c - 1 * d;
			m[10] = b + 4 * d;
			n[10] = c - 0 * d;
			break;
		case 14:
			m[0] = b + 0 * d;
			n[0] = c - 8 * d;
			m[1] = b - 0 * d;
			n[1] = c - 14 * d;
			m[2] = b - 8 * d;
			n[2] = c - 16 * d;
			m[3] = b + 8 * d;
			n[3] = c - 16 * d;
			break;
		case 15:
			m[0] = b - 1 * d;
			n[0] = c - 12 * d;
			m[1] = b - 3 * d;
			n[1] = c - 0 * d;
			m[2] = b + 3 * d;
			n[2] = c - 0 * d;
			break;
		case 16:
			m[0] = b - 0 * d;
			n[0] = c - 10 * d;
			m[1] = b - 3 * d;
			n[1] = c - 11 * d;
			m[4] = b - 6 * d;
			n[4] = c - 12 * d;
			m[7] = b - 9 * d;
			n[7] = c - 13 * d;
			m[2] = b + 3 * d;
			n[2] = c - 11 * d;
			m[5] = b + 6 * d;
			n[5] = c - 12 * d;
			m[8] = b + 8 * d;
			n[8] = c - 14 * d;
			m[3] = b + 1 * d;
			n[3] = c - 7 * d;
			m[6] = b + 2 * d;
			n[6] = c - 4 * d;
			m[9] = b + 1 * d;
			n[9] = c - 1 * d;
			break;
		case 17:
			m[0] = b + 2 * d;
			n[0] = c - 16 * d;
			m[1] = b + 2 * d;
			n[1] = c - 6 * d;
			m[2] = b - 3 * d;
			n[2] = c - 5 * d;
			m[3] = b - 2 * d;
			n[3] = c - 0 * d;
			break;
		case 19: //Hopper
			m[0] = b + 0 * d;
			n[0] = c - 4 * d;
			m[1] = b + 8 * d;
			n[1] = c - 12 * d;
			m[2] = b + 12 * d;
			n[2] = c + 0 * d;
			m[3] = b - 8 * d;
			n[3] = c - 12 * d;
			m[4] = b - 12 * d;
			n[4] = c + 0 * d;
			m[5] = b + 6 * d;
			n[5] = c + 0 * d;
			m[6] = b - 6 * d;
			n[6] = c + 0 * d;
			break;
		case 20: //Wizard
			m[0] = b + 0 * d;
			n[0] = c - 18 * d;
			m[1] = b + 0 * d;
			n[1] = c - 15 * d;
			m[2] = b + 0 * d;
			n[2] = c - 10 * d;
			m[3] = b - 4 * d;
			n[3] = c - 12 * d;
			m[4] = b + 4 * d;
			n[4] = c - 12 * d;
			m[5] = b - 8 * d;
			n[5] = c - 12 * d;
			m[6] = b + 8 * d;
			n[6] = c - 12 * d;
			m[7] = b - 3 * d;
			n[7] = c - 6 * d;
			m[8] = b + 4 * d;
			n[8] = c - 8 * d;
			m[9] = b - 2 * d;
			n[9] = c - 2 * d;
			m[10] = b + 2 * d;
			n[10] = c - 4 * d;
			break;
		case 21: //Warper
			m[0] = b + 0 * d;
			n[0] = c - 8 * d;
			for (var i = 1; i < 7; i++) {
				m[i] = b + d * 8 * Xe[i*85&511][0];
				n[i] = c - d * 8 * (1 + Xe[i*85&511][1]);
			}
			break;
		case 22: //Egg
			m[0] = b + 0 * d;
			n[0] = c + 0 * d + 1;
			break;
		case 23: //Cell
			m[0] = b + 0 * d;
			n[0] = c - 18 * d;
			m[1] = b - 7 * d;
			n[1] = c - 27 * d;
			m[2] = b + 5 * d;
			n[2] = c - 29 * d;
			m[3] = b + 12 * d;
			n[3] = c - 20 * d;
			m[4] = b + 7 * d;
			n[4] = c - 10 * d;
			m[5] = b - 5 * d;
			n[5] = c - 8 * d;
			m[6] = b - 12 * d;
			n[6] = c - 18 * d;
			break;
		case 24: //Centipede
			m[0] = b + 0 * d;
			n[0] = c - 8 * d;
			m[1] = b + 8 * d;
			n[1] = c - 6 * d;
			m[2] = b + 6 * d;
			n[2] = c - 4 * d;
			m[3] = b - 8 * d;
			n[3] = c - 6 * d;
			m[4] = b - 6 * d;
			n[4] = c - 4 * d;
			break;
	}
	switch (B[a][bh]) {
		case 0:
			If(z(m[1] - 0.5), z(n[1]) - 2 * r, z(4 * d) + 1, z(4 * d) + 1, k);
			If(z(m[2] - 0.5), z(n[2]) - 2 * r, z(4 * d) + 1, z(4 * d) + 1, k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 1:
			J(Va, z(m[2]), z(n[2] - 2 * d), z(8 * d), z(8 * d), 16 * e, 0, 16, 16, k);
			J(Va, z(m[1]), z(n[1] - 3 * d), z(12 * d), z(12 * d), 16 * e, 0, 16, 16, k);
			J(Va, z(m[0]), z(n[0] - 4 * d), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 2:
			L(m[1], n[1], m[2], n[2], k);
			L(m[2], n[2], m[3], n[3], k);
			L(m[3], n[3], m[1], n[1], k);
			L(m[4], n[4], m[5], n[5], k);
			L(m[5], n[5], m[6], n[6], k);
			L(m[6], n[6], m[4], n[4], k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 3:
			L(m[0], n[0], m[1], n[1], k);
			L(m[4], n[4], m[5], n[5], k);
			L(m[1], n[1], m[2], n[2], k);
			L(m[2], n[2], m[3], n[3], k);
			L(m[3], n[3], m[4], n[4], k);
			Hf(z(m[5]), z(n[5]), z(2 * d), z(2 * d), g);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 4:
		case 12:
		case 20: //Wizard
			L(m[1], n[1], m[2], n[2], k);
			L(m[1], n[1], m[3], n[3], k);
			L(m[1], n[1], m[4], n[4], k);
			L(m[3], n[3], m[5], n[5], k);
			L(m[4], n[4], m[6], n[6], k);
			L(m[2], n[2], m[7], n[7], k);
			L(m[2], n[2], m[8], n[8], k);
			L(m[7], n[7], m[9], n[9], k);
			L(m[8], n[8], m[10], n[10], k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			332 == a && J(Va, z(m[0]), z(n[0] - 3 * d), z(16 * d), z(16 * d), 352, 0, 16, 16, 16766720);
			break;
		case 5:
			for (a = 3; 0 < a; a--) If(z(m[a]), z(n[a] - 2 * d), z(4 * d) + 1, z(4 * d) + 1, k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 18:
			d = K(d, 1, 2);
			for (a = 3; 0 < a; a--) If(z(m[a]), z(n[a] + 2 * d), z(4 * d) + 1, z(4 * d) + 1, k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 15, 16, -16, g);
			break;
		case 6:
			for (a = 1; 6 > a; a++) L(m[a], n[a], m[a + 1], n[a + 1], k);
			L(m[a], n[a], m[1], n[1], k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 7:
			L(m[2], n[2], m[3], n[3], k);
			L(m[2], n[2], m[4], n[4], k);
			L(m[3], n[3], m[4], n[4], k);
			If(z(m[1]), z(n[1]), z(6 * d) + 1, z(6 * d) + 1, k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 8:
			If(z(m[2]) + z(1 * d), z(n[2] - 2 * d), z(8 * d) + 1, z(4 * d) + 1, k);
			If(z(m[1]), z(n[1] - 2 * d), z(4 * d) + 1, z(4 * d) + 1, k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 9:
		case 13:
			Hf(z(m[5]), z(n[5]), z(2 * d), z(2 * d), g);
			J(Va, z(m[4]), z(n[4]), z(8 * d), z(8 * d), 16 * e, 0, 16, 16, k);
			J(Va, z(m[3]), z(n[3]), z(10 * d), z(10 * d), 16 * e, 0, 16, 16, k);
			J(Va, z(m[2]), z(n[2]), z(12 * d), z(12 * d), 16 * e, 0, 16, 16, k);
			J(Va, z(m[1]), z(n[1]), z(14 * d), z(14 * d), 16 * e, 0, 16, 16, k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 10:
			L(z(m[0]), z(n[0]), z(m[1]), z(n[1]), k);
			L(z(m[0]), z(n[0]), z(m[3]), z(n[3]), k);
			L(z(m[1]), z(n[1]), z(m[2]), z(n[2]), k);
			L(z(m[3]), z(n[3]), z(m[4]), z(n[4]), k);
			L(z(m[0]), z(n[0]), z(m[5]), z(n[5]), k);
			L(z(m[0]), z(n[0]), z(m[7]), z(n[7]), k);
			L(z(m[5]), z(n[5]), z(m[6]), z(n[6]), k);
			L(z(m[7]), z(n[7]), z(m[8]), z(n[8]), k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 11:
			If(z(m[3]), z(n[3] - 7 * d), z(4 * d) + 1, z(14 * d) + 1, k);
			If(z(m[2]) + 0, z(n[2]), z(4 * d) + 1, z(9 * d) + 1, k);
			If(z(m[1]) + 1, z(n[1]), z(4 * d) + 1, z(8 * d) + 1, k);
			J(Va, z(m[0]) + 1, z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 14:
			L(z(m[1]), z(n[1]), z(m[2]), z(n[2]), k);
			L(z(m[1]), z(n[1]), z(m[3]), z(n[3]), k);
			L(z(m[2]), z(n[2]), z(m[3]), z(n[3]), k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 15:
			L(z(m[0]), z(n[0]), z(m[1]), z(n[1]), k);
			L(z(m[0]), z(n[0]), z(m[2]), z(n[2]), k);
			L(z(m[1]), z(n[1]), z(m[2]), z(n[2]), k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 16:
			for (a = 1; 4 > a; a++) L(z(m[0]), z(n[0]), z(m[a]), z(n[a]), k);
			for (a = 4; 10 > a; a++) L(z(m[a - 3]), z(n[a - 3]), z(m[a]), z(n[a]), k);
			for (a = 7; 10 > a; a++) Hf(z(m[a]), z(n[a]), z(2 * d), z(2 * d), g);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 17:
			for (a = 3; 0 < a; a--) Hf(z(m[a]), z(n[a] - 2 * d), z(4 * d), z(4 * d), k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 19: //Hopper
			L(m[0], n[0], m[1], n[1], k);
			L(m[1], n[1], m[2], n[2], k);
			L(m[0], n[0], m[3], n[3], k);
			L(m[3], n[3], m[4], n[4], k);
			L(m[0], n[0], m[5], n[5], k);
			L(m[0], n[0], m[6], n[6], k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 21: //Warper
			for (a = 1; a < 7; a++) V(m[a]-d, n[a]-d, 2*d, 2*d, k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 22: //Egg
			V(m[0] - 2 * d, n[0] - 9 * d, z(4 * d), z(9 * d), k);
			V(m[0] - 3 * d, n[0] - 8 * d, z(6 * d), z(8 * d), k);
			V(m[0] - 4 * d, n[0] - 6 * d, z(8 * d), z(5 * d), k);
			V(m[0] - 1 * d, n[0] - 8 * d, z(2 * d), z(7 * d), g);
			V(m[0] - 2 * d, n[0] - 7 * d, z(4 * d), z(6 * d), g);
			V(m[0] - 3 * d, n[0] - 5 * d, z(6 * d), z(3 * d), g);
			break;
		case 23: //Cell
			for (a = 1; 6 > a; a++) L(m[a], n[a], m[a + 1], n[a + 1], k);
			L(m[a], n[a], m[1], n[1], k);
			J(Va, z(m[0]), z(n[0]), z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			break;
		case 24: //Centipede
			for (a = -1; a < 2; a++) {
				L(m[0], n[0] + a * 8 * d, m[1], n[1] + a * 8 * d, k);
				L(m[0], n[0] + a * 8 * d, m[3], n[3] + a * 8 * d, k);
				L(m[1], n[1] + a * 8 * d, m[2], n[2] + a * 8 * d, k);
				L(m[3], n[3] + a * 8 * d, m[4], n[4] + a * 8 * d, k);
				J(Va, z(m[0]), z(n[0]) + a * 8 * d, z(16 * d), z(16 * d), 16 * e, 0, 16, 16, g);
			}
			break;
	}
};

var ze,
	Ae = [3, 1, 0, 0, 0, 0, 0, 0, 0, 0],
	Ce = 1,
	Be = 2,
	kg = 4,
	jg = [/*Page1*/1, 2, 3, 4, 5, 12, 6, 7, 8, 18,/*Page2*/19, 20, 10, 11, 13, 14, 15, 16, 9, 22], //Book stage list
	gg = [1,   2,				3,				 4,				  5,			   6,				7,				 8,				  8,			   9,			  6,			  7,			  7,			   10,		  10,		 11,		1,			 1,			   9,				 11,		  1,1,					11], //Shop stage beaten requirement list
	Uf = "Town;Mundane Plains 1;Mundane Plains 2;Mundane Plains 3;Mundane Plains 4;Mundane Plains 5;Mundane Plains 7;Mundane Plains 8;Mundane Plains 9;Tower Entrance;Perilous Path 1;Perilous Path 2;Mundane Plains 6;Damp Bog 1;Damp Bog 2;Damp Bog 3;Foreverglade;Void Monolith;Mundane Plains 10;Higher Plains;;Hillside Settlement;The Tower;Ancient Storeroom;The Bridge 1;The Bridge 2;Stormy Wetlands 1".split(";"),
	De = [ //Stage locations [xpos, ypos, drawDotOrNot, nextStage1, nextStage2]
		[6, 28, 0, 1, 0],//Town
		[10, 28, 0, 2, 10],//Plains 1
		[15, 28, 0, 3, 0],//2
		[18, 25, 0, 4, 0],//3
		[22, 24, 0, 5, 0],//4
		[23, 21, 0, 6, 12],//5
		[28, 20, 0, 7, 0],//7
		[32, 17, 0, 8, 18],//8
		[37, 18, 0, 9, 0],//9
		[41, 17, 0, 22, 0],//Tower Entrance
		[11, 23, 0, 11, 0],//Perilous Path 1
		[11, 19, 0, 13, 0],//Perilous Path 2
		[18, 19, 0, 13, 0],//Mundane Plains 6
		[15, 16, 0, 14, 0],//Damp Bog 1
		[13, 13, 0, 15, 0],//Damp Bog 2
		[10, 10, 0, 16, 17],//Damp Bog 3
		[6, 10, 0, 0, 0],//Foreverglade
		[10, 6, 1, 0, 0],//Void Monolith
		[29, 14, 0, 19, 0],//Mundane Plains 10
		[29, 10, 0, 20, 21],//Higher Plains
		[0.1, 0.1, 1, 0, 0],//
		[36, 9, 0, 0, 0],//Hillside Farm
		[44, 16, 1, -1, 0]//Tower
		],
	ze = De.length,
	O = 1, //Ground
	P = 2, //Ground left
	Q = 3, //Ground middle
	R = 4, //Ground right
	S = 5, //Air water
	T = 6, //Water
	Mf = 7, //Ground left clumped
	Nf = 8, //Ground middle clumped
	Of = 9, //Ground right clumped
	Lf = 10, //Air
	Pf = 11, //Ceiling
	Qf = 12, //Ceiling left
	Rf = 13, //Ceiling middle
	Sf = 14, //Ceiling right
	Me = [
		[//Town
			[0, 0, O, 0, 0, O, 0, 0, O, 0, 0, O, 0, 0],
			[0, 100, O, 0]
		],
		[//Plains 1
			[0, 1, O, 0, 5],
			[0, 1, O, 0, 3, R, 1, 2],
			[0, 1, O, 0, 6, O, 1, 3],
			[0, 1, Nf, 2, 9, R, 3, 2],
			[0, 1, Nf, 2, 7, O, 0, 2, R, 3, 1],
			[0, 1, Nf, 2, 5, O, 0, 3, R, 1, 2, Q, 3, 1],
			[0, 100, Q, 0, 2, Q, 3, 3, R, 4, 1]
		],
		[//Plains 2
			[0, 1, O, 5, 7],
			[0, 1, O, 5, 5, O, 6, 3],
			[0, 1, O, 5, 3, Lf, 7, 5, R, 6, 1],
			[0, 1, R, 6, 4, Lf, 7, 3],
			[0, 1, Lf, 7, 10],
			[0, 1, Q, 5, 3, Q, 6, 3, Lf, 7, 3],
			[0, 100, Q, 8, 2, O, 5, 3]
		],
		[//Plains 3
			[0, 1, O, 9, 7, R, 10, 1],
			[0, 1, O, 9, 5, O, 10, 2],
			[0, 1, O, 9, 5, R, 10, 1, Q, 11, 6],
			[0, 1, Nf, 12, 16],
			[0, 1, R, 9, 2, Q, 11, 3, Of, 12, 9],
			[0, 1, R, 10, 5],
			[0, 1, O, 10, 1, R, 11, 2, Nf, 12, 9],
			[0, 100, O, 9, 3, O, 10, 1, Of, 12, 5, R, 13, 1]
		],
		[//Plains 4
			[0, 1, O, 14, 4, O, 15, 1],
			[0, 1, O, 14, 3, Lf, 16, 1],
			[0, 1, O, 14, 3, R, 17, 5],
			[0, 1, O, 15, 2, Lf, 16, 1, Q, 17, 2],
			[0, 1, R, 15, 5, Q, 17, 1],
			[0, 1, Lf, 16, 3, O, 17, 4],
			[0, 100, Lf, 16, 1, O, 17, 3, R, 18, 1]
		],
		[//Plains 5
			[0, 1, Q, 19, 16, Q, 21, 3],
			[0, 1, Q, 19, 10, Q, 20, 1],
			[0, 1, O, 19, 8, O, 20, 2, O, 21, 4],
			[0, 100, Q, 19, 6, Q, 21, 3, Q, 22, 1]
		],
		[//Plains 7
			[0, 1, O, 23, 7],
			[0, 1, O, 23, 5, Q, 24, 2],
			[0, 1, Q, 23, 3, R, 24, 3, Lf, 25, 5],
			[0, 100, Q, 24, 5],
			[0, 1, O, 23, 3, Lf, 25, 9],
			[0, 100, R, 23, 3, Lf, 25, 2, R, 26, 1]
		],
		[//Plains 8
			[0, 1, O, 27, 4],
			[0, 1, R, 27, 2, Q, 28, 3],
			[0, 1, Q, 27, 5, O, 28, 2],
			[0, 1, R, 29, 1],
			[0, 1, O, 28, 3, Q, 29, 1],
			[0, 1, O, 27, 3, R, 28, 2, Q, 29, 1],
			[0, 1, O, 29, 3],
			[0, 100, R, 30, 50]
		],
		[//Plains 9
			[0, 1, O, 31, 9],
			[0, 1, Lf, 32, 9],
			[0, 1, O, 33, 9],
			[0, 1, O, 31, 3, Lf, 32, 3],
			[0, 1, O, 31, 3, O, 33, 3],
			[0, 1, Lf, 32, 3, O, 33, 3],
			[0, 100, Q, 31, 1, Lf, 32, 1, R, 33, 1, Lf, 34, 1]
		],
		[//Tower Entrance
			[1, 2, O, 35, 5, O, 36, 1],
			[1, 2, O, 35, 6, P, 37, 3],
			[1, 2, Q, 35, 4, Q, 36, 1, Lf, 37, 2],
			[1, 2, R, 36, 3, Lf, 37, 4],
			[1, 2, Lf, 37, 6],
			[1, 103, Q, 37, 3, Q, 38, 1]
		],
		[//Perilous Path 1
			[0, 3, O, 39, 6, O, 40, 1],
			[0, 3, Q, 39, 3, T, 41, 6],
			[0, 3, R, 40, 2, T, 41, 5],
			[0, 3, R, 39, 4, R, 40, 1, T, 41, 6],
			[0, 3, O, 40, 3],
			[0, 101, Q, 40, 2, Q, 42, 1]
		],
		[//Perilous Path 2
			[0, 3, O, 43, 6, O, 44, 1],
			[0, 3, Q, 43, 3, T, 45, 4],
			[0, 3, R, 44, 2, T, 45, 2],
			[0, 3, R, 43, 4, R, 44, 1, T, 45, 3],
			[0, 3, O, 44, 3],
			[0, 101, Q, 45, 4, Q, 46, 1]
		],
		[//Plains 6
			[0, 1, O, 47, 7, Lf, 49, 1],
			[0, 1, O, 47, 5, Q, 48, 3],
			[0, 1, Q, 47, 4, R, 48, 2, P, 48, 1, Lf, 49, 2],
			[0, 1, Q, 48, 5, Lf, 49, 2],
			[0, 1, O, 48, 8],
			[0, 1, Lf, 49, 4],
			[0, 100, Q, 50, 1]
		],
		[//Damp Bog 1
			[2, 3, O, 51, 6],
			[2, 3, Q, 51, 3, Lf, 53, 6],
			[2, 3, Q, 51, 2, R, 51, 2, Lf, 53, 4],
			[2, 3, Lf, 53, 5, Lf, 54, 1],
			[2, 3, O, 51, 5, Lf, 54, 2],
			[2, 3, Lf, 53, 12],
			[2, 3, O, 51, 9],
			[2, 100, O, 51, 12, Q, 55, 1]
		],
		[//Damp Bog 2
			[2, 3, Q, 56, 1],
			[2, 3, O, 56, 2, O, 58, 4],
			[2, 3, P, 56, 1, R, 57, 9, O, 58, 2],
			[2, 3, R, 57, 8, R, 59, 1],
			[2, 3, O, 58, 2, Q, 59, 6],
			[2, 100, R, 60, 1, R, 59, 5]
		],
		[//Damp Bog 3
			[2, 3, Q, 61, 15, T, 62, 10],
			[2, 3, Q, 61, 10, T, 62, 8, O, 63, 3],
			[2, 3, O, 63, 5, Q, 64, 1],
			[2, 3, Lf, 61, 20, O, 64, 2],
			[2, 100, Q, 63, 3, O, 64, 2, Q, 65, 1]
		],
		[//Foreverglade
			[2, 100, O, 0, 0],
			[2, 100, Of, 66, 9],
			[2, 100, Q, 70, 1]
		],
		[//Void Monolith
			[2, 100, O, 0, 0],
			[2, 100, O, 0, 0]
		],
		[//Mundane Plains 10
			[0, 1, O, 71, 5, Q, 72, 2],
			[0, 1, O, 71, 9, Q, 72, 1],
			[0, 1, O, 72, 3, Q, 73, 1],
			[0, 1, O, 71, 6, Q, 72, 1, Q, 73, 1],
			[0, 1, O, 71, 4, O, 74, 6],
			[0, 1, Q, 72, 2, Q, 73, 1, O, 74, 5],
			[0, 100, O, 71, 6, Q, 74, 6, Q, 75, 1]
		],
		[//Higher Plains
			[0, 1, Lf, 76, 4, Q, 77, 3],
			[0, 1, Lf, 76, 8],
			[0, 1, Q, 77, 6, Lf, 78, 1],
			[0, 1, Lf, 76, 5, Q, 78, 1],
			[0, 1, Lf, 78, 3],
			[0, 100, Q, 77, 3, Q, 78, 1, Q, 79, 1]
		],
		[//
			[3, 4, O, 80, 10],
			[3, 4, O, 81, 10],
			[3, 4, O, 82, 10],
			[3, 4, O, 83, 10],
			[3, 100, O, 80, 2, O, 81, 2, O, 82, 2, O, 83, 2]
		],
		[//Hillside settlement
			[0, 100, O, 0, 0],
			[0, 100, O, 0, 0]
		],
		[//Tower
			[1, 102, O, 0, 0],
			[1, 103, Q, 84, 1]
		],
		[]
	],
	oe = new ih;

function ih() { //Projectiles
	var a;
	this.F = new Int32Array(1E3);
	this.a = Array(1E3);
	this.k = Array(1E3);
	this.d = new Int32Array(1E3); //Disappear effect switch (I think)
	this.Ya = new Int32Array(1E3);
	this.N = new Int32Array(1E3);
	this.G = new Int32Array(1E3);
	this.Wa = new Int32Array(1E3);
	this.Ua = new Int32Array(1E3);
	this.Va = new Int32Array(1E3);
	this.ja = new Int32Array(1E3);
	this.ka = new Int32Array(1E3);
	this.ha = new Int32Array(1E3);
	this.oa = new Int32Array(1E3);
	this.count = new Int32Array(1E3);
	this.startingLifespan = new Int32Array(1E3); //PROJECTILE the projectile's starting lifespan for reference (e.g. for arcing thunder)
	this.ia = new Int32Array(1E3);
	this.e = new Int32Array(1E3);
	this.i = new Int32Array(1E3);
	this.ya = new Int32Array(1E3);
	this.Y = new Int32Array(1E3);
	this.ra = new Int32Array(1E3);
	this.la = new Int32Array(1E3);
	this.ga = new Int32Array(1E3);
	this.ea = new Int32Array(1E3);
	this.fa = new Int32Array(1E3);
	this.U = new Int32Array(1E3);
	this.V = new Int32Array(1E3);
	this.sub = new Int32Array(1E3);
	this.Ha = new Int32Array(1E3);
	this.Sa = new Int32Array(1E3);
	this.Ea = new Int32Array(1E3);
	this.za = new Int32Array(1E3);
	this.Pa = new Int32Array(1E3);
	this.Qa = new Int32Array(1E3);
	this.La = new Int32Array(1E3);
	this.Ma = new Int32Array(1E3);
	this.Ga = new Int32Array(1E3);
	this.Na = new Int32Array(1E3);
	this.Fa = new Int32Array(1E3);
	this.Ia = new Int32Array(1E3);
	this.Ja = new Int32Array(1E3);
	this.Ta = new Int32Array(1E3);
	this.Oa = new Int32Array(1E3);
	this.Ka = new Int32Array(1E3);
	this.Ra = new Int32Array(1E3);
	this.Aa = new Int32Array(1E3);
	this.Ba = new Int32Array(1E3);
	this.A = new Int32Array(1E3);
	this.Ca = new Int32Array(1E3);
	this.Da = new Int32Array(1E3);
	for (a = this.index = 0; 1E3 > a; a++) this.a[a] = new Qg;
	for (a = 0; 1E3 > a; a++) this.k[a] = new Qg
}
aa = ih.prototype;
aa.j = function() { //Reset
	this.index = 0
};
//Spawn
aa.add = function(a, b, c, d, e, g, k, r, m, n, F, H, M, E, ka, Ja, Ea, Ca, Z, X, $, ob, pb, Xa, ta, ya, rb, ia, ja, za, bb, ab, pa, Ya, Bb, Cb, Sa, Oa, Ob, Pb, Qb, Rb, Sb, Tb, qb, Ub, Vb, Wb, Xb, Yb, Zb) {
	1E3 != this.index && 
	(this.F[this.index] = a, 
	Rg(this.a[this.index], b, c), 
	Rg(this.k[this.index], d, e), 
	this.d[this.index] = 0, 
	this.Ya[this.index] = g, 
	this.N[this.index] = k, 
	this.G[this.index] = r, 
	this.Wa[this.index] = m, 
	this.Ua[this.index] = n, 
	this.Va[this.index] = F, 
	this.ja[this.index] = H, 
	this.ka[this.index] = M, 
	this.ha[this.index] = z(A(E)), 
	this.oa[this.index] = ka, 
	this.count[this.index] = Ja, 
	this.startingLifespan[this.index] = this.count[this.index], //PROJECTILE starting lifespan for thunder arcing etc.
	this.ia[this.index] = Ea, 
	this.e[this.index] = Ca, 
	this.i[this.index] = Z, 
	this.ya[this.index] = X, 
	this.Y[this.index] = $, 
	this.ra[this.index] = ob, 
	this.la[this.index] = pb, 
	this.ga[this.index] = Xa, 
	this.ea[this.index] = ta, 
	this.fa[this.index] = ya, 
	this.U[this.index] = rb, 
	this.V[this.index] = ia, 
	rb == 8 && this.error(), //ELEMENT glitch
	this.sub[this.index] = ja, 
	this.Ha[this.index] = za, 
	this.Sa[this.index] = bb, 
	this.Ea[this.index] = ab, 
	this.za[this.index] = pa, 
	this.Pa[this.index] = Ya, 
	this.Qa[this.index] = Bb, 
	this.La[this.index] = Cb, 
	this.Ma[this.index] = Sa, 
	this.Ga[this.index] = Oa, 
	this.Na[this.index] = Ob, 
	this.Fa[this.index] = Pb, 
	this.Ia[this.index] = Qb, 
	this.Ja[this.index] = Rb, 
	this.Ta[this.index] = Sb, 
	this.Oa[this.index] = Tb, 
	this.Ka[this.index] = qb, 
	this.Ra[this.index] = Ub, 
	this.Aa[this.index] = Vb, 
	this.Ba[this.index] = Wb, 
	this.A[this.index] = Xb, 
	this.Ca[this.index] = Yb, 
	this.Da[this.index] = Zb, 
	this.index++)
};
aa.error = function() {
	this.U[this.index] = $g(8); //Primary type
	if (this.U[this.index] == 4) this.U[this.index] -= 4; //No poison (probably too OP)
	this.U[this.index] += $g(8)*10; //Secondary type (e.g primary:fire secondary:thunder is 31)
	if (z(this.U[this.index]/10) == 4) this.U[this.index] -= 40; //No poison
}
aa.q = function(a) { //Despawn, move the last projectile on the array to [a]
	this.F[a] = this.F[this.index - 1];
	this.a[a].set(this.a[this.index - 1]);
	this.k[a].set(this.k[this.index - 1]);
	this.d[a] = this.d[this.index - 1];
	this.Ya[a] = this.Ya[this.index - 1];
	this.N[a] = this.N[this.index - 1];
	this.G[a] = this.G[this.index - 1];
	this.Wa[a] = this.Wa[this.index - 1];
	this.Ua[a] = this.Ua[this.index - 1];
	this.Va[a] = this.Va[this.index - 1];
	this.ja[a] = this.ja[this.index - 1];
	this.ka[a] = this.ka[this.index - 1];
	this.ha[a] = this.ha[this.index - 1];
	this.oa[a] = this.oa[this.index - 1];
	this.count[a] = this.count[this.index - 1];
	this.startingLifespan[a] = this.startingLifespan[this.index - 1]; //PROJECTILE
	this.ia[a] = this.ia[this.index - 1];
	this.e[a] = this.e[this.index - 1];
	this.i[a] = this.i[this.index - 1];
	this.ya[a] = this.ya[this.index - 1];
	this.Y[a] = this.Y[this.index - 1];
	this.ra[a] = this.ra[this.index - 1];
	this.la[a] = this.la[this.index - 1];
	this.ga[a] = this.ga[this.index - 1];
	this.ea[a] = this.ea[this.index - 1];
	this.fa[a] = this.fa[this.index - 1];
	this.U[a] = this.U[this.index - 1];
	this.V[a] = this.V[this.index - 1];
	this.sub[a] = this.sub[this.index - 1];
	this.Ha[a] = this.Ha[this.index - 1];
	this.Sa[a] = this.Sa[this.index - 1];
	this.Ea[a] = this.Ea[this.index - 1];
	this.za[a] = this.za[this.index - 1];
	this.Pa[a] = this.Pa[this.index - 1];
	this.Qa[a] = this.Qa[this.index - 1];
	this.La[a] = this.La[this.index - 1];
	this.Ma[a] = this.Ma[this.index - 1];
	this.Ga[a] = this.Ga[this.index - 1];
	this.Na[a] = this.Na[this.index - 1];
	this.Fa[a] = this.Fa[this.index - 1];
	this.Ia[a] = this.Ia[this.index - 1];
	this.Ja[a] = this.Ja[this.index - 1];
	this.Ta[a] = this.Ta[this.index - 1];
	this.Oa[a] = this.Oa[this.index - 1];
	this.Ka[a] = this.Ka[this.index - 1];
	this.Ra[a] = this.Ra[this.index - 1];
	this.Aa[a] = this.Aa[this.index - 1];
	this.Ba[a] = this.Ba[this.index - 1];
	this.A[a] = this.A[this.index - 1];
	this.Ca[a] = this.Ca[this.index - 1];
	this.Da[a] = this.Da[this.index - 1];
	this.index--
};
aa.h = function(a, b) { //Terrain interaction
	var c = 0;
	b.set(this.k[a]);
	var d = z(Sg(b) / 4) + 1;
	Tg(b, 1 / d);
	for (var e, g, k, r = 0; r < d; r++)
		if (
		e = this.a[a].y + b.y, //y-direction
		g = z(K(this.a[a].x, 0, 511) / 8), //x tile
		k = z(K(e, 0, 255) / 8), //y tile
		g = I.e[k][g], //Tile data
		0 <= g && 8 >= g && 0 == this.ya[a] ? //Going into solid tile and not piercing
			0 == this.Y[a] ? //Not bouncing or sliding
				c = 1 : //Despawn
			2 == this.Y[a] && //Bouncing
				(b.y *= -1, this.k[a].y *= -1) : //Reverse y velocity
			this.a[a].y = e, //Otherwise (sliding, piercing or not going into a tile) orientation unchanged
		
		e = this.a[a].x + b.x, //x-direction
		g = z(K(e, 0, 511) / 8), //x tile
		k = z(K(this.a[a].y, 0, 255) / 8), //y tile
		g = I.e[k][g], //Tile data
		0 <= g && 8 >= g && 0 == this.ya[a]) { //Going into solid tile and not piercing
			if (0 == this.Y[a] || 1 == this.Y[a]) c = 1; //Despawn if not bouncing
			2 == this.Y[a] && (b.x *= -1, this.k[a].x *= -1) //Reverse x velocity
		} else this.a[a].x = e; //Keep orientation otherwise
	return c
};
aa.move = function() { //Main
	var a, b, c = new Qg,
		d, e, helpMe;
	for (a = 0; a < this.index; a++)
		if (-64 > this.a[a].x || 576 < this.a[a].x) this.q(a--); //Despawn out of bounds
		else if (0 < this.ha[a]) this.ha[a]--; //Appear delay
		else if (1 == this.d[a]) this.count[a]++, this.count[a] >= this.ia[a] && this.q(a--); //Disappear effect
		else {
			0 < this.ra[a] && //Homing
				(d = this.ra[a], 
				d = 1 != ga ? 0 == this.F[a] ? //Find homing target
					G.m(this.a[a].x - d, this.a[a].y - d, this.a[a].x + d, this.a[a].y + d) : //PvE player projectile
					v.m(this.a[a].x - d, this.a[a].y - d, this.a[a].x + d, this.a[a].y + d, 0) : //PvE enemy projectile
					v.m(this.a[a].x - d, this.a[a].y - d, this.a[a].x + d, this.a[a].y + d, 1 - this.F[a] << 2), //PvP
				-1 != d && //If target
					(1 != ga ? 0 == this.F[a] ? //Get homing direction
						c.q(G.a[d][0], this.a[a]) : //PvE p proj
						c.q(v.a[d][0], this.a[a]) : //PvE e proj
						c.q(v.a[d][0], this.a[a]), //PvP
				Xg(c), 
				d = Sg(this.k[a]), 
				this.k[a].x = 0.85 * this.k[a].x + 0.15 * c.x + N(-0.1, 0.1), 
				this.k[a].y = 0.85 * this.k[a].y + 0.15 * c.y + N(-0.1, 0.1), 
				Xg(this.k[a]), 
				Tg(this.k[a], ig(d, 1))));
			this.k[a].y += 0.01 * this.e[a]; //Gravity
			Tg(this.k[a], 0.01 * this.i[a]); //Acceleration
			d = this.h(a, c); //Check terrain interaction
			b = 1;
			//ELEMENT Fire's chance-based damage per frame
			if (this.U[a]%10 == 1 || z(this.U[a]/10) == 1) 0 != this.V[a] && A(1E3) > this.V[a] && (b = 0);
			0 < this.oa[a] && (this.oa[a]--, b = 0); //Solid delay
			e = -1;
			1 == b && (e = 1 != ga ? 0 == this.F[a] ? //Deal damage
				G.K(this.ga[a], this.U[a], this.V[a], this.ea[a], this.fa[a], this.a[a].x, this.a[a].y, this.ja[a], this.ka[a]) : //PvE p proj
				v.K(this.ga[a], this.U[a], this.V[a], this.ea[a], this.fa[a], this.a[a].x, this.a[a].y, this.ja[a], this.ka[a], 0) : //PvE e proj
				v.K(this.ga[a], this.U[a], this.V[a], this.ea[a], this.fa[a], this.a[a].x, this.a[a].y, this.ja[a], this.ka[a], 1 - this.F[a] << 2)); //PvP
			helpMe = e;
			-1 != e && 0 != this.la[a] && (1 != ga ? 0 == this.F[a] ? //Knockback
				c.q(G.a[e][0], this.a[a]) : //PvE p proj
				c.q(v.a[e][0], this.a[a]) : //PvE e proj
				c.q(v.a[e][0], this.a[a]), //PvP
			Xg(c), 
			Tg(c, 0.1 * this.la[a]), 
			1 != ga && 0 == this.F[a] ? 
				Tg(c, ah[B[G.id[e]][bh]] / B[G.id[e]][ch]) : //Knockback scaling for enemies
				Tg(c, 0.1), //For players
			1 != ga ? 0 == this.F[a] ? 
				G.c[e][0].sub(c) : //PvE p proj
				v.c[e][0].sub(c) : //PvE e proj
				v.c[e][0].sub(c), //PvP
			this.la[a] = 0); //End of knockback
			if (this.U[a]%10 == 1 || z(this.U[a]/10) == 1) 0 != this.V[a] && (e = -1); //Fire doesn't activate residues from hitting an enemy
			if (this.U[a]%10 == 3 || z(this.U[a]/10) == 3) { //PROJECTILE Thunder's chance to arc
				if (helpMe != -1 && this.V[a] > A(100)) {
					var speed, arcRotation = new Qg;
					speed = Sg(this.k[a]); //Magnitude of velocity
					arcRotation.x = N(-1, 1); //New projectile will go in a random direction
					arcRotation.y = N(-1, 1);
					Xg(arcRotation);
					Tg(arcRotation, speed);
					
					oe.add(
					this.F[a], //class_ID
					this.a[a].x, //x_pos
					this.a[a].y, //y_pos
					arcRotation.x, //Xspd
					arcRotation.y, //Yspd
					this.Ya[a], //orient
					this.N[a], //img
					this.G[a], //color
					this.Wa[a], //transp
					this.Ua[a], //width
					this.Va[a], //height
					this.ja[a], //box_width
					this.ka[a], //box_height
					0, //appear_delay
					10, //solid_delay
					this.startingLifespan[a], //lifespan
					this.ia[a], //disp_eff
					this.e[a], //grav
					this.i[a], //accel
					this.ya[a], //pierce
					this.Y[a], //bounce
					this.ra[a], //homing
					this.la[a], //knockback
					this.ga[a], //splash
					this.ea[a], //AT_Min
					this.fa[a], //AT_Max
					this.U[a], //res_type
					this.V[a] * 0.5, //res_type_param (arc chance always halves, 200 or more chance for multiple guaranteed arcs)
					this.sub[a], //res_mode
					this.Ha[a], //res_orient
					this.Sa[a], //res_img
					this.Ea[a], //Res_Color
					this.za[a], //res_transp
					this.Pa[a], //res_width
					this.Qa[a], //res_height
					this.La[a], //res_box_width
					this.Ma[a], //res_box_height
					this.Ga[a], //res_appear_delay
					this.Na[a], //res_solid_delay
					this.Fa[a], //Res_Lifespan
					this.Ia[a], //res_fade_time
					this.Ja[a], //res_grav
					this.Ta[a], //res_accel
					this.Oa[a], //res_pierce
					this.Ka[a], //res_bounce
					this.Ra[a], //res_splash
					this.Aa[a], //res_ATmin
					this.Ba[a], //res_ATmax
					this.A[a], //res_bullet
					this.Ca[a], //base_res_type
					this.Da[a]); //base_res_type_param
				}
			}
			if (1 == d || -1 != e) //Contact or hits enemy
				if (this.d[a] = 1, this.count[a] = 0, 1 == this.sub[a] || 3 == this.sub[a] || 4 == this.sub[a] || 5 == this.sub[a] || 6 == this.sub[a] || 7 == this.sub[a] || 8 == this.sub[a] || 9 == this.sub[a]) {
					//Residue
					var g = z(A(512));
					for (b = 0; b < this.A[a]; b++) {
						if (1 == this.sub[a]) Rg(c, 0, 0);
						else if (3 == this.sub[a]) {
							var g = z(A(512)),
								k = N(0.05, 0.1);
							c.x = this.A[a] * Xe[g][0] * k;
							c.y = this.A[a] * Xe[g][1] * k
						} else 4 == this.sub[a] ? (c.x = N(0.1 * -this.A[a], 0.1 * this.A[a]), c.y = N(0.2 * -this.A[a], 0.1 * -this.A[a])) : 
							5 == this.sub[a] ? (c.x = this.k[a].x, c.y = this.k[a].y) : 
							6 == this.sub[a] ? (c.x = N(0.01 * -this.A[a], 0.01 * this.A[a]), c.y = N(0.2 * -this.A[a], 0.05 * -this.A[a])) : 
							7 == this.sub[a] ? (k = z(g + 512 * b / this.A[a]) & 511, c.x = this.A[a] * Xe[k][0], c.y = this.A[a] * Xe[k][1]) : 
							8 == this.sub[a] ? (g = z(A(512)), k = N(0, 0.1), c.x = this.A[a] * Xe[g][0] * k, c.y = this.A[a] * Xe[g][1] * k) : 
							9 == this.sub[a] && (c.x = this.k[a].x, c.y = this.k[a].y, Xg(c));
						oe.add(this.F[a], this.a[a].x, this.a[a].y, c.x, c.y, this.Ha[a], this.Sa[a], this.Ea[a], this.za[a], this.Pa[a], this.Qa[a], this.La[a], this.Ma[a], this.Ga[a], this.Na[a], this.Fa[a], this.Ia[a], this.Ja[a], this.Ta[a], this.Oa[a], this.Ka[a], 0, 0, this.Ra[a], this.Aa[a], this.Ba[a], this.Ca[a], this.Da[a], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
					}
				}
			0 < this.count[a] && this.count[a]--;
			0 == this.count[a] && (this.d[a] = 1);
			//Constant residue production
			2 == this.sub[a] && (A(100) < this.A[a] || 1 == d || -1 != e) && (c.x = N(-1, 1), c.y = N(-1, 1), oe.add(this.F[a], this.a[a].x, this.a[a].y, c.x, c.y, this.Ha[a], this.Sa[a], this.Ea[a], this.za[a], this.Pa[a], this.Qa[a], this.La[a], this.Ma[a], this.Ga[a], this.Na[a], this.Fa[a], this.Ia[a], this.Ja[a], this.Ta[a], this.Oa[a], this.Ka[a], 0, 0, this.Ra[a], this.Aa[a], this.Ba[a], this.Ca[a], this.Da[a], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
		}
};
aa.b = function() { //Draw
	var a, b, c, d = new Qg,
		e = new Qg,
		g = new Qg,
		k = new Qg;
	for (a = 0; a < this.index; a++)
		if (!(0 < this.ha[a])) {
			b = 16 * this.N[a];
			c = 1 == this.d[a] ? z((this.G[a] >> 24 & 255) * (this.ia[a] - this.count[a]) / this.ia[a]) << 24 | this.G[a] & 16777215 : this.G[a];
			0 < this.oa[a] && (c = z((c >> 24 & 255) / 2) << 24 | c & 16777215);
			Xf = this.Wa[a];
			dg = 1;
			if (0 == this.Ya[a]) J(Za, z(this.a[a].x), z(this.a[a].y), this.Ua[a], this.Va[a], b, 0, 16, 16, c);
			else {
				e.set(this.k[a]);
				d.set(e);
				dh(d);
				Xg(d);
				Xg(e);
				Tg(d, this.Ua[a] >> 1);
				Tg(e, this.Va[a] >> 1);
				g.q(e, d);
				eh(k, e, d);
				var r = this.a[a].x + g.x,
					m = this.a[a].y + g.y,
					n = b,
					F = this.a[a].x + k.x,
					H = this.a[a].y + k.y,
					M = b + 16,
					E = this.a[a].x - g.x,
					ka = this.a[a].y - g.y,
					Ja = b + 16,
					Ea = this.a[a].x - k.x,
					Ca = this.a[a].y - k.y,
					Z = 0,
					X = 0,
					$ = 16,
					ob = 16,
					pb = Za,
					r = r << 16,
					m = m << 16,
					F = F << 16,
					H = H << 16,
					E = E << 16,
					ka = ka << 16,
					Ea = Ea << 16,
					Ca = Ca << 16,
					n = 65535 * n,
					Z = 65535 * Z,
					M = 65535 * M,
					X = 65535 * X,
					Ja = 65535 * Ja,
					$ = 65535 * $;
				b *= 65535;
				var ob = 65535 * ob,
					Xa = void 0,
					ta = void 0,
					ya = void 0,
					rb = Xa = void 0,
					ia = void 0,
					ja = void 0,
					za = void 0,
					bb = void 0,
					ab = void 0,
					pa = void 0,
					Ya = void 0,
					Bb = void 0,
					Cb = void 0,
					Sa = void 0,
					Sa = void 0,
					ya = fa << 16,
					Oa = 0;
				ya > m && (ya = m);
				ya > H && (ya = H);
				ya > ka && (ya = ka);
				ya > Ca && (ya = Ca);
				Oa < m && (Oa = m);
				Oa < H && (Oa = H);
				Oa < ka && (Oa = ka);
				Oa < Ca && (Oa = Ca);
				ya >>= 16;
				Oa >>= 16;
				0 > ya && (ya = 0);
				Oa >= fa && (Oa = fa - 1);
				for (ta = ya; ta <= Oa; ta++) jh[ta] = ea, kh[ta] = -1;
				lh(r, m, n, Z, F, H, M, X);
				lh(F, H, M, X, E, ka, Ja, $);
				lh(E, ka, Ja, $, Ea, Ca, b, ob);
				lh(Ea, Ca, b, ob, r, m, n, Z);
				Ya = c >> 24 & 255;
				bb = c >> 16 & 255;
				ab = c >> 8 & 255;
				pa = c & 255;
				for (ta = ya; ta <= Oa; ta++)
					for (ya = ta * ea + jh[ta], Xa = kh[ta] - jh[ta] + 1, ja = (mh[ta] - nh[ta]) / Xa, za = (oh[ta] - ph[ta]) / Xa, rb = nh[ta], ia = ph[ta], Xa = jh[ta]; Xa <= kh[ta]; Xa++, ya++, rb += ja, ia += za) 
						0 > Xa || ea <= Xa || (Sa = pb.f[(ia >> 16) * pb.i + (rb >> 16)], 0 == dg ? -1 != Sa && (Bb = bb * ((Sa & 16711680) >> 16) >> 8, Cb = ab * ((Sa & 65280) >> 8) >> 8, Sa = pa * (Sa & 255) >> 8, C[ya] = 0 == Xf ? Bb << 16 | Cb << 8 | Sa : qh(C[ya], Bb << 16 | Cb << 8 | Sa, Ya)) : (Sa = Ya * (Sa & 255) >> 8, 0 != Sa && (C[ya] = qh(C[ya], c, Sa))))
			}
			dg = Xf = 0
		}
};

var ne = new rh;

function rh() { //Indicators
	var a;
	this.a = Array(1E3);
	this.k = Array(1E3);
	this.value = new Int32Array(1E3);
	this.G = new Int32Array(1E3);
	this.count = new Int32Array(1E3);
	for (a = this.index = 0; 1E3 > a; a++) this.a[a] = new Qg;
	for (a = 0; 1E3 > a; a++) this.k[a] = new Qg
}
aa = rh.prototype;
aa.j = function() {
	this.index = 0
};
aa.add = function(a, b, c, d, e) {
	1E3 != this.index && (a = K(a, 16, 495), b = K(b, 8, 247), Rg(this.a[this.index], a, b), Rg(this.k[this.index], c, -2), 0 != c && (this.k[this.index].x += N(-0.2, 0.2), this.k[this.index].y += N(-0.2, 0.2)), this.value[this.index] = d, this.G[this.index] = e, this.count[this.index] = 0, this.index++)
};
aa.sub = function(a) {
	this.a[a].set(this.a[this.index - 1]);
	this.k[a].set(this.k[this.index - 1]);
	this.value[a] = this.value[this.index - 1];
	this.G[a] = this.G[this.index - 1];
	this.count[a] = this.count[this.index - 1];
	this.index--
};
aa.move = function() {
	var a;
	for (a = 0; a < this.index; a++) {
		if (0 == this.k[a].x) {
			var b = this.a[a],
				c = this.k[a];
			c.y += 0;
			Tg(c, 0.96)
		} else b = this.a[a], c = this.k[a], c.y += 0.05, Tg(c, 0.99);
		b.add(c);
		this.a[a].x = K(this.a[a].x, 16, 495);
		this.a[a].y = K(this.a[a].y, 8, 247);
		this.count[a]++;
		100 <= this.count[a] && this.sub(a--)
	}
};
aa.b = function() {
	var a, b, c, d, e;
	for (a = 0; a < this.index; a++) b = this.G[a] >> 16 & 255, c = this.G[a] >> 8 & 255, d = this.G[a] & 255, e = z(255 * (50 > 100 - this.count[a] ? 100 - this.count[a] : 50) / 50), Gf(hf, z(this.a[a].x), z(this.a[a].y), "" + this.value[a], b, c, d, e, 0, 0, 0, e, 5, 7)
};

var pe = new sh;

function sh() { //Item drops
	var a;
	this.a = Array(100);
	this.k = Array(100);
	this.item = new Int32Array(100);
	this.value = new Int32Array(100);
	this.da = new Int32Array(100);
	this.count = new Int32Array(100);
	for (a = this.J = this.index = 0; 100 > a; a++) this.a[a] = new Qg;
	for (a = 0; 100 > a; a++) this.k[a] = new Qg
}
aa = sh.prototype;
aa.j = function() {
	this.J = this.index = 0
};
aa.add = function(a, b, c, d, e) {
	if (100 != this.index)
		for (a = K(a, 16, 495), b = K(b, 8, 247), Rg(this.a[this.index], a, b), this.k[this.index].x = cg < a ? N(-0.5, -1) : N(0.5, 1), this.k[this.index].y = N(-1, -2), this.item[this.index] = c, this.value[this.index] = d, this.da[this.index] = e, this.count[this.index] = 0, this.index++, c = this.J = 0; c < this.index; c++) this.J += 7 * this.item[c] + 3 * this.value[c] + 11 * this.da[c]
};
aa.sub = function(a) {
	this.a[a].set(this.a[this.index - 1]);
	this.k[a].set(this.k[this.index - 1]);
	this.item[a] = this.item[this.index - 1];
	this.value[a] = this.value[this.index - 1];
	this.da[a] = this.da[this.index - 1];
	this.count[a] = this.count[this.index - 1];
	this.index--;
	for (a = this.J = 0; a < this.index; a++) this.J += 7 * this.item[a] + 3 * this.value[a] + 11 * this.da[a]
};
aa.move = function() {
	var a, b;
	for (a = b = 0; a < this.index; a++) b += 7 * this.item[a] + 3 * this.value[a] + 11 * this.da[a];
	this.J != b && (C = null);
	for (a = 0; a < this.index; a++) {
		this.k[a].y += 0.04;
		Tg(this.k[a], 0.98);
		var c, d;
		b = K(this.a[a].y + this.k[a].y, 8, 247);
		c = z(this.a[a].x / 8);
		d = z(b / 8);
		c = I.e[d][c];
		0 <= c && 8 >= c || (this.a[a].y = b);
		b = K(this.a[a].x + this.k[a].x, 16, 495);
		c = z(b / 8);
		d = z(this.a[a].y / 8);
		c = I.e[d][c];
		0 <= c && 8 >= c || (this.a[a].x = b);
		if (100 > this.count[a]) this.count[a]++;
		else if (b = v.m(this.a[a].x - 12, this.a[a].y - 6 - 12, this.a[a].x + 12, this.a[a].y - 6 + 12, 0), -1 != b) {
			Ne();
			if (1 == this.item[a]) dc = K(dc + this.value[a], 0, 9999999), ne.add(this.a[a].x, this.a[a].y, 0, this.value[a], 16776960);
			else if (2 == this.item[a]) {
				for (c = 0; 4 > c; c++) 0 != v.search[c] && z(100 * p[b] / kc[b]) > z(100 * p[c] / kc[c]) && (b = c);
				if (p[b] == kc[b]) continue;
				Ne();
				p[b] = K(p[b] + z(kc[b] / 5), 0, kc[b]);
				te();
				ne.add(this.a[a].x, this.a[a].y, 0, z(kc[b] / 5), 65280)
			} else {
				for (b = Fc; b < Gc; b++)
					if (0 == q[b]) {
						q[b] = this.item[a];
						Dc[b] = this.value[a];
						Ec[b] = this.da[a];
						break
					}
				if (b == Gc) {
					this.k[a].x = N(-1, 1);
					this.k[a].y = N(-1, -2);
					this.count[a] =
						0;
					continue
				}
			}
			te();
			this.sub(a--)
		}
	}
};
aa.b = function() {
	var a;
	dg = 2;
	for (a = 0; a < this.index; a++) 100 != this.count[a] && 0 == (this.count[a] & 6) || eg(Ra, z(this.a[a].x) - 6, z(this.a[a].y) - 12, 12, 12, 12 * w(this.item[a], Pc), 0, 12, 12, w(this.item[a], Sc));
	dg = 0
};
var I = new th;

function th() { //Terrain
	this.i = 64;
	this.s = 48;
	this.e = Array(this.s);
	this.o = new Int32Array(this.i);
	this.I = new Int32Array(this.i);
	this.$ = new Int32Array(this.i);
	this.hb = new Int32Array(this.i);
	this.gb = new Int32Array(48 * this.s);
	this.w = this.ab = 0;
	this.cb = -1;
	for (var a = 0; a < this.s; a++) this.e[a] = new Int32Array(this.i)
}
th.prototype.j = function(a) { //Set
	var b, c;
	this.w = a;
	this.cb != Me[this.w][nb][1] && (this.cb = Me[this.w][nb][1], Na = new wa, Na.j("st" + this.cb + ".gif"));
	mf(Na);
	if (0 != nf) return !1;
	this.s = Na.s;
	for (c = 0; c < this.s; c++)
		for (b = 0; b < this.i; b++) this.e[c][b] = -1;
	var d = z(A(Na.i - 64));
	for (c = 0; c < this.s; c++)
		for (b = 0; b < this.i; b++) {
			a = c * Na.i + K(b, 3, 60) + d;
			var e = Na.f[3 >= b || this.i - 3 <= b ? a : a - 1],
				g = Na.f[2 >= b || this.i - 4 <= b ? a : a + 1],
				k = Na.f[0 == c ? a : a - Na.i],
				r = Na.f[c == this.s - 1 ? a : a + Na.i];
			0 == Na.f[a] ? 0 != e && 0 == g && 0 != k && 0 == r ? this.e[c][b] = 0 : 0 == e && 0 == g && 0 != k && 0 == r ? this.e[c][b] = 1 : 0 == e && 0 != g && 0 != k && 0 == r ? this.e[c][b] = 2 : 0 != e && 0 == g && 0 == k && 0 == r ? this.e[c][b] = 3 : 0 == e && 0 == g && 0 == k && 0 == r ? this.e[c][b] = 4 : 0 == e && 0 != g && 0 == k && 0 == r ? this.e[c][b] = 5 : 0 != e && 0 == g && 0 == k && 0 != r ? this.e[c][b] = 6 : 0 == e && 0 == g && 0 == k && 0 != r ? this.e[c][b] = 7 : 0 == e && 0 != g && 0 == k && 0 != r && (this.e[c][b] = 8) : 255 == Na.f[a] && (this.e[c][b] = 9)
		}
	for (b = 0; b < this.i; b++)
		for (c = this.s - 1; 0 <= c; c--)
			if (0 > this.e[c][b] || 8 < this.e[c][b]) {
				this.o[b] = c;
				break
			}
	for (b = 0; b < this.i; b++)
		for (c = 1; c < this.s; c++)
			if ((0 > this.e[c - 1][b] || 8 < this.e[c - 1][b]) &&
				0 <= this.e[c][b] && 8 >= this.e[c][b]) {
				this.I[b] = c - 1;
				break
			}
	for (b = 0; b < this.i; b++)
		for (c = 0; c < this.s; c++)
			if (0 > this.e[c][b] || 8 < this.e[c][b]) {
				this.$[b] = c;
				break
			}
	for (b = 0; b < this.i; b++)
		for (this.hb[b] = this.$[b], c = 1; c < this.s; c++)
			if ((0 > this.e[c - 1][b] || 8 < this.e[c - 1][b]) && 0 <= this.e[c][b] && 9 >= this.e[c][b]) {
				this.hb[b] = c - 1;
				break
			}
	this.ab = 0;
	for (b = 12; 60 > b; b++)
		for (c = 1; c < this.s - 1; c++) 9 == this.e[c - 1][b] && 9 == this.e[c][b] && (this.gb[this.ab++] = c * this.i + b);
	if (0 == nb) {
		for (a = 0; a < ea * fa; a++) Ma.f[a] = 0;
		b = C;
		switch (this.w) { //mist
			case 13:
			case 14:
			case 15:
			case 16:
				Xf = 1;
				dg = 3;
				C = Ma.f;
				for (a = 0; a < ea * fa; a++) C[a] = 0;
				for (a = 0; 100 > a; a++) c = N(1.7, 3.69), c *= c * c * c, J(Za, z(N(0, 512)), z(256 - c), 256, 32, 96, 0, 16, 16, 419430399);
				C = b;
				Xf = dg = 0
		}
	}
	return !0
};
th.prototype.b = function() { //Draw
	var a, b, c = new Int32Array([0, 8, 16, 0, 8, 16, 0, 8, 16]),
		d = new Int32Array([0, 0, 0, 8, 8, 8, 16, 16, 16]),
		e = Pa[Me[this.w][nb][0]];
	for (b = 0; b < this.s; b++)
		for (a = 0; a < this.i; a++) {
			var g = this.e[b][a];
			-1 != g && 
				(9 == g ? 
					(this.w == 13 || this.w == 14 || this.w == 15) ? 
						-1 == this.e[b - 1][a] ? 
							ag(gb, 8 * a, 8 * b, 8, 8, 0, 0, 8, 8) : //Water2 surface
							Og(8 * a - 4, 8 * b, 16, 8, 0x673E16) : //Water2 non-surface
						-1 == this.e[b - 1][a] ? 
							ag(fb, 8 * a, 8 * b, 8, 8, 0, 0, 8, 8) : //Water surface
							Og(8 * a - 4, 8 * b, 16, 8, 21916) : //Water non-surface
					ag(e, 8 * a, 8 * b, 8, 8, c[g], d[g], 8, 8)) //Solid tile
		}
};
var qe = new uh;

function uh() { //Map
	this.i = 78;
	this.s = 16;
	this.t = 0;
	this.e = Array(this.s);
	this.W = Array(this.s);
	for (var a = 0; a < this.s; a++) this.e[a] = new Int32Array(this.i), this.W[a] = new Int32Array(this.i)
}
uh.prototype.j = function() { //Tiling
	var a, b, c;
	for (c = 0; c < this.s; c++)
		for (b = 0; b < this.i; b++) this.e[c][b] = -1;
	for (c = 0; c < this.s; c++)
		for (b = 0; b < this.i; b++) {
			a = c * ib.i + b;
			var d = 0 == b ? 0 : -1,
				e = b == this.i - 1 ? 0 : 1,
				g = 0 == c ? 0 : -this.i,
				k = c == this.s - 1 ? 0 : this.i,
				r = ib.f[a + d + g],
				m = ib.f[a + g],
				g = ib.f[a + e + g],
				n = ib.f[a + d],
				F = ib.f[a + e],
				d = ib.f[a + d + k],
				H = ib.f[a + k],
				e = ib.f[a + e + k];
			//MAP tiles
			0x66FF66 == kb.f[a] ? this.e[c][b] = 18 : //Grass
			0 != ib.f[a] &&
				(0x003399 == ib.f[a] ? this.e[c][b] = 13 : //Water
				0x0044CC == ib.f[a] ? this.e[c][b] = 14 : //Shallow Water
				(a = ib.f[a], 
				m >= a && n >= a && F >= a && H >= a && e < a ? this.e[c][b] = 3 : 
				m >= a && n >= a && F >= a && H >= a && d < a ? this.e[c][b] = 4 : 
				m >= a && n >= a && F >= a && H >= a && g < a ? this.e[c][b] = 8 : 
				m >= a && n >= a && F >= a && H >= a && r < a ? this.e[c][b] = 9 : 
				n < a && F >= a && m < a && H >= a ? this.e[c][b] = 0 : 
				n >= a && F >= a && m < a && H >= a ? this.e[c][b] = 1 : 
				n >= a && F < a && m < a && H >= a ? this.e[c][b] = 2 : 
				n < a && F >= a && m >= a && H >= a ? this.e[c][b] = 5 : 
				n >= a && F < a && m >= a && H >= a ? this.e[c][b] = 7 : 
				n < a && F >= a && m >= a && H < a ? this.e[c][b] = 10 : 
				n >= a && F >= a && m >= a && H < a ? this.e[c][b] = 11 : 
				n >= a && F < a && m >= a && H < a && (this.e[c][b] = 12)))
		}
	for (c = 0; c < this.s; c++) //Map details
		for (b = 0; b < this.i; b++) 
			a = c * kb.i + b, 
			this.W[c][b] = -1, 
			0x006600 == kb.f[a] ? this.W[c][b] = 0 : //3 trees
			0x004C00 == kb.f[a] ? this.W[c][b] = 1 : //2 trees
			0x666666 == kb.f[a] ? this.W[c][b] = 2 : //Raincloud
			0x720000 == kb.f[a] ? this.W[c][b] = 3 : //Monolith
			0x7F5500 == kb.f[a] ? this.W[c][b] = 4 : //Bridge
			0x593E08 == kb.f[a] ? this.W[c][b] = 5 : //Reeds
			0x7F7F7F == kb.f[a] ? this.W[c][b] = 6 : //Tower
			0x3F7F3F == kb.f[a] ? this.W[c][b] = 7 : //Big tree
			0xFF0000 == kb.f[a] ? this.W[c][b] = 8 : //Stone pillar
			0xFFFF00 == kb.f[a] ? this.W[c][b] = 9 : //Thunderhead
			0x30497A == kb.f[a] ? this.e[c][b] = 17 : //Big waterfall
			0x00297C == kb.f[a] ? //Hill waterfalls and lakes
				(this.e[c][b] == 1 ? this.e[c][b] = 15 : 
				this.e[c][b] == 11 ? this.e[c][b] = 16 : 
				this.e[c][b] = 14) :
			0xB20000 == kb.f[a] ? //Tall
				(0xB20000 == kb.f[(c+1)*kb.i+b] ? this.e[c][b] = 20 : 
				0xB20000 == kb.f[c*kb.i+b-1] ? this.e[c][b] = 22 : 
				this.e[c][b] = 25) :
			0xB27C7C == kb.f[a] && 
				(0xB27C7C == kb.f[(c+1)*kb.i+b] ? this.e[c][b] = 21 : this.e[c][b] = 26)
};
uh.prototype.b = function() { //Main
	var a, b, c, d, e = new Qg,
		g = new Qg;
	20 > cg && 256 > fg ? //Scroll left
		this.t = K(this.t + 4, -720, 0) : 
	492 < cg && 256 > fg && //Scroll right
		(this.t = K(this.t - 4, -720, 0));
	for (d = 0; d < this.s; d++)
		for (b = 0; b < this.i; b++) - 1 != this.e[d][b] && ag(jb, this.t + 16 * b, 16 * d, 16, 16, this.e[d][b] % 5 * 16, 16 * z(this.e[d][b] / 5), 16, 16);
	for (a = 0; a < ze; a++) //Dot path
		if (0 != (Ae[a] & Be)) //Don't draw for hidden stages
			for (b = 3; 4 >= b; b++)
				if (!(0 >= De[a][b]) && a + b - 2 != 20)
					for (e.x = 8 * De[a][0], 
						e.y = 8 * De[a][1], 
						g.x = 8 * (De[De[a][b]][0] - De[a][0]), 
						g.y = 8 * (De[De[a][b]][1] - De[a][1]), 
						d = Xg(g) / 8 - 1, 
						Tg(g, 8), 
						e.add(g), 
						c = 0; c < d; c++) 
							Hf(this.t + e.x, e.y, 2, 2, 13421772), e.add(g);
	for (d = 0; d < this.s; d++)
		for (b = 0; b < this.i; b++) - 1 != this.W[d][b] && ag(lb, this.t + 16 * b + 8, 16 * d + 8, 16, 16, 16 * this.W[d][b], 0, 16, 16);
	/*eg(lb, this.t + 384 - 8, 124, 16, 16, 16, 0, 16, 16, 8421631); //MAP objects
	eg(lb, this.t + 504 - 8, 116, 16, 16, 48, 0, 16, 16, 16777215);
	eg(lb, this.t + 552 - 8, 116, 16, 16, 64, 0, 16, 16, 16777215);
	eg(lb, this.t + 592 - 8, 100, 16, 16, 32, 0, 16, 16, 16777215);
	eg(lb, this.t + 672 - 8, 68, 16, 16, 32, 0, 16, 16, 16777215);
	eg(lb, this.t + 808 - 8, 132, 16, 16, 16, 0, 16, 16, 13434879);
	eg(lb, this.t + 904 - 8, 164, 16, 16, 112, 0, 16, 16, 13434879);
	eg(lb, this.t + 1040 - 8, 172, 16, 16, 128, 0, 16, 16, 13434879);
	eg(lb, this.t + 1088 - 8, 100, 16, 16, 32, 0, 16, 16, 16777215);
	eg(lb, this.t + 1160 - 8, 84, 16, 16, 32, 0, 16, 16, 16777215);
	eg(lb, this.t + 1112 - 8, 44, 32, 16, 144, 0, 32, 16, 16777215);*/
	if (Ae[22] > 1) {
		if (mapCloudPos < 832) mapCloudPos += 2;
		else mapCloudPos = 832;
	} else mapCloudPos = 384;
	ag(cloudImg, this.t + mapCloudPos, 0, 64, 256, 0, 0, 16, 64);
	V(this.t + mapCloudPos + 64, 0, mapWidth - mapCloudPos, 256, 0x515151);
	//Stage dot colors
	for (a = 0; a < ze; a++) 
		0 != Ae[a] && 
			(b = 8 * De[a][0], 
			d = 8 * De[a][1], 
			c = 
				(0 == a || 21 == a) ? 16777215 : //Town stage
				20 == a ? 0 : //Hidden stage
				0 != (Ae[a] & Be) ? 10027008 : //Stage beaten
				13421568, //Not beaten
			0 == De[a][2] && Hf(this.t + b, d, 6, 6, c), 
			c = 20 == a ? 3 : 24, //Dot size
			Df(this.t + b, d, c, c) && If(this.t + b, d, c, c, 13369344));
	b = 8 * De[h][0];
	d = 8 * De[h][1];
	ag(Qa, this.t + b + 1 - 12, d - 14 - 11, 24, 22, 0, 0, 24, 22);
	for (a = 0; a < ze; a++) 
		0 != Ae[a] && 
			(b = 8 * De[a][0], 
			d = 8 * De[a][1], 
			c = -2 == a ? 3 : 24, //Tiny stage
			Df(this.t + b, d, c, c)) && (!Ef || 0 != a && 17 != a && 21 != a && 20 != a ? Ef && 0 != a && (h = a, nb = 0, f = 10) : (h = a, nb = 1, f = 50, a == 20 && (nb = 4)), b = K(cg, 1 + 4 * Uf[a].length, 510 - 4 * Uf[a].length), d = K(fg - 24, 8, 256), yf(D, b, d, Uf[a], 16777215, 5263440));
	a = D;
	a.Q = 4;
	yf(a, 256, 16, "WORLD MAP", -1, 13158600);
	a.Q = 0;
	0 > this.t && yf(D, 12, 16, "<<", 13158600, 5263440); - 720 < this.t && yf(D, 500, 16, ">>", 13158600, 5263440)
};
var vh = document,
	We = vh.getElementById("cv"),
	wh = We.getContext("2d"),
	xh = wh.createImageData(ea, fa),
	gf = new Uint8Array(xh.data.buffer),
	yh = da.console,
	zg = String.fromCharCode,
	of = setTimeout,
	zh = zg(100, 97, 110, 45, 98, 97, 108, 108, 46, 106, 112);
da.fff = Ah;

function Ah(a, b, c) {
	try {
		We = vh.getElementById("cv"), wh = We.getContext("2d"), wh.putImageData(a, b, c)
	} catch (d) {}
}
da.fff = Ue;

function Ue(a) {
	try {
		yh.log(a)
	} catch (b) {}
}
da.Init = Te;
var Hg = zg(40, 67, 41, 32, 50, 48, 48, 56, 32, 104, 97, 53, 53, 105, 105, 32, 68, 65, 78, 45, 66, 65, 76, 76, 46, 106, 112),
	Ve = zg(67, 111, 112, 121, 114, 105, 103, 104, 116, 32, 40, 67, 41, 32, 50, 48, 48, 56, 32, 104, 97, 53, 53, 105, 105, 32, 68, 65, 78, 45, 66, 65, 76, 76, 46, 106, 112),
	Bh = zg(46, 47, 100, 97, 116, 97, 47),
	Af = zg(102, 112, 115),
	Ch = zg(99, 97, 110, 118, 97, 115),
	Dh = zg(50, 100),
	Eh = 0,
	Fh = zg(100, 97, 110, 45, 98, 97, 108, 108, 46, 106, 112),
	C = new Int32Array(ea * fa),
	jh = new Int32Array(fa),
	kh = new Int32Array(fa),
	nh = new Float32Array(fa),
	mh = new Float32Array(fa),
	ph = new Float32Array(fa),
	oh = new Float32Array(fa);

function rf() {
	if (Gh) {
		Gh(rf);
		Hh++;
		Ih = Date.now();
		var a = z(60 * (Ih - Jh) / 1E3 + 0.5);
		if (0 > a || 60 <= a) Hh = 0, zf = Kh, Kh = 0, Bf = z((2 * Bf + Lh) / 3), Lh = 0, Jh = Ih, a = 0;
		else if (a == Mh) return;
		Kh++;
		Mh = a
	}
	Ef = !1 == Ug && !0 == Nh;
	xg = !0 == Ug && !1 == Nh;
	Oh = !0 == Ph && !1 == Qh;
	Ug = Nh;
	Ph = Qh;
	Lg = !(xg | Ug | Oh | Ph);
	$f = xg ? 1 : Oh ? -1 : 0;
	cg = Rh;
	fg = Sh;
	for (a = 0; 256 > a; a++) Ze[a] = $e[a], $e[a] = !1;
	ef = ef + z(1024 * Math.random()) & 1023;
	ff = z(512 * Math.random()) | 1;
	sf();
	var b, c = 11 == Eh ? ea * fa : 0;
	for (b = a = 0; a < c; a++) gf[b++] = C[a] >> 16 & 255, gf[b++] = C[a] >> 8 & 255, gf[b++] = C[a] & 255, b++;
	Ah(xh, 0, 0);
	Gh ?
		Lh += Date.now() - Ih : of (rf, pf())
}
var tf = 1;

function jf() {
	if (zh.length != Fh.length) return !0;
	for (tf = 0; Eh < zh.length; Eh++)
		if (zh[Eh] != Fh[Eh]) return !0;
	return !1
}
var Gh = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame,
	Hh = 0,
	Mh = 0,
	Kh = 0,
	zf = 0,
	Lh = 0,
	Bf = 0,
	Th = 20,
	Ih = Date.now(),
	Jh = Ih,
	Uh = Ih + Th,
	Vh = Ih,
	Ig = 0;

function pf() {
	Ih = Date.now();
	var a = K(Uh - Ih, 5, Th);
	Kh++;
	Ig++;
	Lh += a;
	Uh += Th;
	if (Ih + a >= Vh || Ih < Jh) Bf = Bf + Lh >> 1, Lh = 0, zf = Kh, Kh = 0, Uh = Ih + Th, Vh = Ih + 1E3;
	Jh = Ih;
	return a
}
var nf = 0;

function wa() {
	this.Z = 0;
	this.file = "";
	this.ib = this.ca = this.Xa = this.u = this.d = this.f = this.shift = this.s = this.i = 0
}

function qf(a, b, c) {
	a.i = b;
	a.s = c;
	for (b = a.shift = 0; 16 > b; b++) 1 << b == a.i && (a.shift = b);
	a.f = new Int32Array(a.i * a.s)
}
wa.prototype.j = function(a) {
	this.file != a && (nf++, this.file = a, this.Z = new Image, this.Z.src = Bh + a + "?18.9", delete this.f, this.d = this.f = 0)
};

function mf(a) {
	if (0 == a.d && a.Z.complete) {
		nf--;
		var b = a.Z.width,
			c = a.Z.height;
		if (0 == b || 0 == c) throw delete a.Z, a.file = "", Wh;
		var d = vh.createElement(Ch);
		d.width = b;
		d.height = c;
		d = d.getContext(Dh);
		d.drawImage(a.Z, 0, 0);
		d = d.getImageData(0, 0, b, c).data;
		qf(a, b, c);
		b = 0;
		for (c = d.length; b < c; b += 4) a.f[b >> 2] = 0 == d[b + 3] ? -1 : d[b + 0] << 16 | d[b + 1] << 8 | d[b + 2];
		delete a.Z;
		a.d = 1
	}
}

function vg(a, b) {
	0 == a.d && (a.d = 1, qf(a, ea, 16), a.Xa = vh.createElement(Ch), a.Xa.width = a.i, a.Xa.height = a.s, a.ca = a.Xa.getContext(Dh));
	var c = b + "sans-serif014";
	if (a.ib != c) {
		a.ib = c;
		a.ca.fillStyle = "#000000";
		a.ca.fillRect(0, 0, a.i, a.s);
		c = "14px sans-serif";
		a.ca.font = c;
		a.ca.fillStyle = "#ffffff";
		a.ca.fillText(b, 0, 14);
		for (var d = a.ca.getImageData(0, 0, a.i, a.s).data, c = 0, e = d.length; c < e; c += 4) a.f[c >> 2] = 1 <= d[c + 0] ? 16777215 : -1;
		for (c = d = a.u = 0; d < a.s; d++)
			for (e = 0; e < a.i; e++, c++) 16777215 == a.f[c] && a.u <= e && (a.u = e + 1)
	}
}
var Xh = [
		[0, 2, 0, 0, 1, 0, 0, 2, 2, 1, 1, 1, 2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 3, 1, 0],
		[0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
	],
	Yh = [
		[0, 1, 1, 0, 0, 0, 0, 2, 1, 2, 0, 0, 2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 0
		],
		[0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
	],
	D = new Zh,
	hf = new Zh;

function Zh() {
	this.N = new wa;
	this.P = this.Q = this.$a = this.R = 0
}
Zh.prototype.j = function(a, b, c) {
	this.N.j(a);
	this.R = b;
	this.$a = c;
	this.P = this.Q = 0
};
Zh.prototype.b = function(a, b, c, d, e) {
	var g, k, r, m, n, F, H, M = ea - this.R,
		E = this.N.i - this.R,
		ka = -1 < d ? 16777215 : 1,
		Ja = -1 < e ? 0 : 1,
		Ea = c.length;
	for (g = 0; g < Ea; g++, a += this.R + this.Q)
		if (n = c.charCodeAt(g) - 32, 0 != n) {
			96 <= n && (n = 31);
			0 != this.P && (a -= Xh[this.P - 1][n]);
			F = n * this.R;
			m = b * ea + a;
			for (r = 0; r < this.$a; r++, m += M, F += E)
				for (k = 0; k < this.R; k++, m++, F++) H = this.N.f[F], H == ka ? C[m] = d : H == Ja && (C[m] = e);
			0 != this.P && (a -= Yh[this.P - 1][n])
		}
	this.P = 0
};

function yf(a, b, c, d, e, g) {
	b -= d.length * (a.R + a.Q) >> 1;
	c -= a.$a >> 1;
	a.b(b, c, d, e, g)
}

function hg(a, b, c, d, e, g) {
	var k = D;
	k.Q = g;
	k.b(a, b, c, d, e);
	k.Q = 0
}
Zh.prototype.M = function(a, b, c, d, e, g, k, r, m, n, F, H, M) {
	d = d * k >> 8;
	e = e * k >> 8;
	g = g * k >> 8;
	k = 255 - k;
	r = r * F >> 8;
	m = m * F >> 8;
	n = n * F >> 8;
	F = 255 - F;
	var E, ka, Ja, Ea, Ca, Z, X, $, ob, pb = ea - H,
		Xa = 255 != k ? 16777215 : 1,
		ta = 255 != F ? 0 : 1,
		ya = c.length;
	for (E = 0; E < ya; E++, a += H + this.Q)
		if (Ca = c.charCodeAt(E) - 32, 0 != Ca) {
			96 <= Ca && (Ca = 31);
			0 != this.P && (a -= z(Xh[this.P - 1][Ca] * H / this.R));
			Z = Ca * this.R;
			Ea = b * ea + a;
			for (Ja = 0; Ja < M; Ja++, Ea += pb)
				for ($ = z(Ja * this.$a / M) * this.N.i + Z << 8, ob = z((this.R << 8) / H), ka = 0; ka < H; ka++, Ea++, $ += ob) X = this.N.f[$ >> 8], X == Xa ? (X = C[Ea], C[Ea] = d + ((X >> 16 &
					255) * k >> 8) << 16 | e + ((X >> 8 & 255) * k >> 8) << 8 | g + ((X & 255) * k >> 8)) : X == ta && (X = C[Ea], C[Ea] = r + ((X >> 16 & 255) * F >> 8) << 16 | m + ((X >> 8 & 255) * F >> 8) << 8 | n + ((X & 255) * F >> 8));
			0 != this.P && (a -= z(Yh[this.P - 1][Ca] * H / this.R))
		}
	this.P = 0
};

function Gf(a, b, c, d, e, g, k, r, m, n, F, H, M, E) {
	b -= d.length * (M + a.Q) >> 1;
	a.M(b, c - (E >> 1), d, e, g, k, r, m, n, F, H, M, E)
}

function Vf(a) {
	var b, c, d, e, g;
	b = 0 * ea;
	for (c = 384 * ea; b < c; b++) d = C[b] >> 16 & 255, e = ((0 - d) * a >> 8) + d, d = C[b] >> 8 & 255, g = ((0 - d) * a >> 8) + d, d = C[b] & 255, d = ((0 - d) * a >> 8) + d, C[b] = e << 16 | g << 8 | d
}
var Xf = 0;

function qh(a, b, c) {
	var d = Xf,
		e = 0,
		g = 0,
		k = 0;
	1 == d ? (d = a >> 16 & 255, e = (((b >> 16 & 255) - d) * c >> 8) + d, d = a >> 8 & 255, g = (((b >> 8 & 255) - d) * c >> 8) + d, d = a & 255, k = (((b & 255) - d) * c >> 8) + d) : 2 == d ? (e = ((b >> 16 & 255) * c >> 8) + (a >> 16 & 255), 255 < e && (e = 255), g = ((b >> 8 & 255) * c >> 8) + (a >> 8 & 255), 255 < g && (g = 255), k = ((b & 255) * c >> 8) + (a & 255), 255 < k && (k = 255)) : 3 == d ? (e = (a >> 16 & 255) - ((b >> 16 & 255) * c >> 8), 0 > e && (e = 0), g = (a >> 8 & 255) - ((b >> 8 & 255) * c >> 8), 0 > g && (g = 0), k = (a & 255) - ((b & 255) * c >> 8), 0 > k && (k = 0)) : 4 == d ? (e = (b >> 16 & 255) * (a >> 16 & 255) >> 8, g = (b >> 8 & 255) * (a >> 8 & 255) >> 8, k = (b & 255) * (a & 255) >>
		8) : 5 == d ? (d = a >> 16 & 255, e = d + ((b >> 16 & 255) * d * c >> 16), 255 < e && (e = 255), d = a >> 8 & 255, g = d + ((b >> 8 & 255) * d * c >> 16), 255 < g && (g = 255), d = a & 255, k = d + ((b & 255) * d * c >> 16), 255 < k && (k = 255)) : 6 == d && (d = a >> 16 & 255, e = d + (c - (2 * d * c >> 8)), d = a >> 8 & 255, g = d + (c - (2 * d * c >> 8)), d = a & 255, k = d + (c - (2 * d * c >> 8)));
	return e << 16 | g << 8 | k
}
var dg = 0;

function L(a, b, c, d, e) {
	c -= a;
	d -= b;
	var g, k;
	Kg(c) >= Kg(d) ? (k = z(Kg(c)), 0 != k && (d = z(65536 * d / k)), c = 0 <= c ? 65536 : -65536) : (k = z(Kg(d)), 0 != k && (c = z(65536 * c / k)), d = 0 <= d ? 65536 : -65536);
	a = z(65536 * a) + 32768;
	for (b = z(65536 * b) + 32768; 0 <= k; k--, a += c, b += d) 0 > a || ea <= a >> 16 || 0 > b || fa <= b >> 16 || (g = (b >> 16) * ea + (a >> 16), C[g] = 0 == Xf ? e : qh(C[g], e, e >> 24 & 255))
}

function bg(a, b, c, d, e) {
	c--;
	d--;
	L(a, b, a + c, b, e);
	L(a, b + d, a + c, b + d, e);
	L(a, b, a, b + d, e);
	L(a + c, b, a + c, b + d, e)
}

function If(a, b, c, d, e) {
	bg(a - (c >> 1), b - (d >> 1), c, d, e)
}

function V(a, b, c, d, e) {
	var g;
	c = a + c > ea ? ea : ~~(a + c);
	d = b + d > fa ? fa : ~~(b + d);
	a = 0 > a ? 0 : ~~a;
	b = (0 > b ? 0 : ~~b) * ea + a;
	g = ea - (c - a);
	c = b + c - a;
	d *= ea;
	if (0 == Xf)
		for (; b < d; b += g, c += ea)
			for (; b < c; b++) C[b] = e;
	else
		for (; b < d; b += g, c += ea)
			for (; b < c; b++) C[b] = qh(C[b], e, e >> 24 & 255)
}

function Hf(a, b, c, d, e) {
	V(a - (c >> 1), b - (d >> 1), c, d, e)
}

function ag(a, b, c, d, e, g, k, r, m) {
	var n, F;
	if (0 != d && 0 != e)
		for (r = ~~((r << 8) / d), m = ~~((m << 8) / e), g <<= 8, k <<= 8, 0 > b && (g += r * -b), 0 > c && (k += m * -c), d = b + d > ea ? ea : ~~(b + d), e = c + e > fa ? fa : ~~(c + e), b = 0 > b ? 0 : ~~b, c = (0 > c ? 0 : ~~c) * ea + b, n = ea - (d - b), d = c + d - b, e *= ea; c < e; c += n, d += ea, k += m)
			for (b = ((k >> 8) * a.i << 8) + g; c < d; c++, b += r) F = a.f[b >> 8], -1 != F && (C[c] = F)
}

function eg(a, b, c, d, e, g, k, r, m, n) {
	var F, H, M, E;
	if (0 != d && 0 != e) {
		r = z((r << 8) / d);
		m = z((m << 8) / e);
		g <<= 8;
		k <<= 8;
		0 > b && (g += r * -b);
		0 > c && (k += m * -c);
		d = b + d > ea ? ea : z(b + d);
		e = c + e > fa ? fa : z(c + e);
		b = 0 > b ? 0 : z(b);
		c = 0 > c ? 0 : z(c);
		var ka = n >> 24 & 255,
			Ja = n >> 16 & 255,
			Ea = n >> 8 & 255,
			Ca = n & 255,
			Z, X, $;
		if (0 == dg)
			for (; c < e; c++, k += m)
				for (H = c * ea + b, M = ((k >> 8) * a.i << 8) + g, F = b; F < d; F++, H++, M += r) E = a.f[M >> 8], -1 != E && (Z = Ja * (E >> 16 & 255) >> 8, X = Ea * (E >> 8 & 255) >> 8, $ = Ca * (E & 255) >> 8, 0 == Xf ? C[H] = Z << 16 | X << 8 | $ : 1 == Xf ? (E = C[H] >> 16 & 255, Z = ((Z - E) * ka >> 8) + E, E = C[H] >> 8 & 255, X = ((X - E) * ka >> 8) +
					E, E = C[H] & 255, $ = (($ - E) * ka >> 8) + E, C[H] = Z << 16 | X << 8 | $) : 2 == Xf ? (Z = (Z * ka >> 8) + (C[H] >> 16 & 255), 255 < Z && (Z = 255), X = (X * ka >> 8) + (C[H] >> 8 & 255), 255 < X && (X = 255), $ = ($ * ka >> 8) + (C[H] & 255), 255 < $ && ($ = 255), C[H] = Z << 16 | X << 8 | $) : 5 == Xf && (E = C[H] >> 16 & 255, Z = E + (Z * E * ka >> 16), 255 < Z && (Z = 255), E = C[H] >> 8 & 255, X = E + (X * E * ka >> 16), 255 < X && (X = 255), E = C[H] & 255, $ = E + ($ * E * ka >> 16), 255 < $ && ($ = 255), C[H] = Z << 16 | X << 8 | $));
		else if (1 == dg)
			for (; c < e; c++, k += m)
				for (H = c * ea + b, M = ((k >> 8) * a.i << 8) + g, F = b; F < d; F++, H++, M += r) E = ka * (a.f[M >> 8] & 255) >> 8, 0 != E && (1 == Xf ? (Z = C[H] >> 16 & 255, Z =
					((Ja - Z) * E >> 8) + Z, X = C[H] >> 8 & 255, X = ((Ea - X) * E >> 8) + X, $ = C[H] & 255, $ = ((Ca - $) * E >> 8) + $, C[H] = Z << 16 | X << 8 | $) : 2 == Xf ? (Z = (C[H] >> 16 & 255) + (Ja * E >> 8), 255 < Z && (Z = 255), X = (C[H] >> 8 & 255) + (Ea * E >> 8), 255 < X && (X = 255), $ = (C[H] & 255) + (Ca * E >> 8), 255 < $ && ($ = 255), C[H] = Z << 16 | X << 8 | $) : 3 == Xf ? (Z = (C[H] >> 16 & 255) - E, 0 > Z && (Z = 0), X = (C[H] >> 8 & 255) - E, 0 > X && (X = 0), $ = (C[H] & 255) - E, 0 > $ && ($ = 0), C[H] = Z << 16 | X << 8 | $) : C[H] = qh(C[H], n, E));
		else if (2 == dg)
			for (; c < e; c++, k += m)
				for (H = c * ea + b, M = ((k >> 8) * a.i << 8) + g, F = b; F < d; F++, H++, M += r) E = a.f[M >> 8], 0 != E && (Z = E >> 16 & 255, X = E >> 8 & 255,
					$ = E & 255, C[H] = Z == X && X == $ ? Ja * Z >> 8 << 16 | Ea * X >> 8 << 8 | Ca * $ >> 8 : Z << 16 | X << 8 | $);
		else if (3 == dg)
			for (; c < e; c++, k += m)
				for (H = c * ea + b, M = ((k >> 8) * a.i << 8) + g, F = b; F < d; F++, H++, M += r) E = ka * (a.f[M >> 8] & 255) >> 8, 0 != E && (1 == Xf ? C[H] = ((255 - C[H]) * E >> 8) + C[H] : 2 == Xf ? (Z = (C[H] >> 16 & 255) + (Ja * E >> 8), 255 < Z && (Z = 255), X = (C[H] >> 8 & 255) + (Ea * E >> 8), 255 < X && (X = 255), $ = (C[H] & 255) + (Ca * E >> 8), 255 < $ && ($ = 255), C[H] = Z << 16 | X << 8 | $) : 3 == Xf && (E = C[H] - E, 0 > E && (E = 0), C[H] = E))
	}
}

function J(a, b, c, d, e, g, k, r, m, n) {
	eg(a, b - (d >> 1), c - (e >> 1), d, e, g, k, r, m, n)
}

function Og(a, b, c, d, e) {
	var g;
	c = a + c > ea ? ea : ~~(a + c);
	d = b + d > fa ? fa : ~~(b + d);
	a = 0 > a ? 0 : ~~a;
	b = (0 > b ? 0 : ~~b) * ea + a;
	g = ea - (c - a);
	c = b + c - a;
	for (d *= ea; b < d; b += g, c += ea)
		for (; b < c; b++) 0 == (C[b] & 16777215) && (C[b] = e)
}

function Yf(a, b, c, d) {
	var e = Qa,
		g, k, r, m, n, F = 0 > a ? -a : 0,
		H = a + 24 > ea ? 24 - (a + 24 - ea) : 24,
		M = b + 24 > fa ? 24 - (b + 24 - fa) : 24;
	for (k = 0 > b ? -b : 0; k < M; k++)
		for (r = (b + k) * ea + (a + F), m = (0 + z(24 * k / 24)) * e.i + c, g = F; g < H; g++, r++) n = m + z(24 * g / 24), 16711680 == e.f[n] && (C[r] = d)
}

function lh(a, b, c, d, e, g, k, r) {
	var m = ig(Kg(e - a >> 16), Kg(g - b >> 16)) + 1;
	e = z((e - a) / m);
	g = z((g - b) / m);
	k = z((k - c) / m);
	r = z((r - d) / m);
	c = z(c);
	d = z(d);
	for (var n, F, H = 0; H < m; H++, a += e, b += g, c += k, d += r) n = a >> 16, F = b >> 16, 0 > F || fa <= F || (jh[F] > n && (jh[F] = n, nh[F] = c, ph[F] = d), kh[F] < n && (kh[F] = n, mh[F] = c, oh[F] = d))
}
var $h = new Qg;

function Y(a, b, c, d, e) {
	$h.q(a, b);
	c -= Xg($h);
	d *= c;
	e *= c;
	a.x += $h.x * d;
	a.y += $h.y * d;
	b.x -= $h.x * e;
	b.y -= $h.y * e
}

function W(a, b, c, d) {
	$h.q(a, b);
	b.set(a);
	$h.y += c;
	Tg($h, d);
	a.add($h)
}
var Ef = !1,
	xg = !1,
	Ug = !1,
	Nh = !1,
	Oh = !1,
	Ph = !1,
	Qh = !1,
	Lg = !1,
	$f = 0,
	cg = 0,
	fg = 0,
	Rh = 0,
	Sh = 0;

function Wf(a, b, c, d) {
	return cg < a || a + c <= cg || fg < b || b + d <= fg ? !1 : !0
}

function Df(a, b, c, d) {
	return Wf(a - c / 2, b - d / 2, c, d)
}

function ai(a) {
	var b = We.getBoundingClientRect();
	Rh = z(a.clientX - b.left);
	Sh = z(a.clientY - b.top)
}
vh.onmousemove = ai;
vh.onmousedown = function(a) {
	ai(a);
	bi = !1;
	if (!(0 > Rh || ea <= Rh || 0 > Sh || fa <= Sh) && (bi = !0, 0 == a.button && (Nh = !0), 2 == a.button && (Qh = !0), bi)) return !1
};
vh.onmouseup = function(a) {
	ai(a);
	0 == a.button && (Nh = !1);
	2 == a.button && (Qh = !1)
};
vh.oncontextmenu = function() {
	if (bi) return !1
};

function ci(a) {
	for (var b = 0, c = 0, d = We; null !== d; d = d.offsetParent) b += d.offsetLeft, c += d.offsetTop;
	a = a.touches;
	Rh = z(a[0].pageX - b);
	Sh = z(a[0].pageY - c)
}
vh.ontouchstart = function(a) {
	ci(a);
	bi = Qh = Nh = !1;
	if (!(0 > Rh || ea <= Rh || 0 > Sh || fa <= Sh)) return Nh = bi = !0, 1 < a.touches.length && (Qh = !0), !1;
        return !1;
};
vh.ontouchmove = function(a) {
	ci(a);
	if (bi) return !1;
        return !1;
};
vh.ontouchend = function(a) {
	1 > a.touches.length && (Nh = !1);
	Qh = !1;
	if (bi) return !1;
        return !1;
};
vh.ontouchcancel = function() {
	Qh = Nh = bi = !1
};
var Ze = Array(256),
	$e = Array(256),
	af = Array(256),
	bf = Array(256),
	cf = Array(256);
vh.onkeydown = function(a) {
	var b = a.keyCode;
	65 <= b & 90 >= b ? a.shiftKey || (b += 32) : b = a.shiftKey ? cf[b] : bf[b];
	0 <= b && 256 > b && (af[b] = !0, $e[b] = !0);
	if (0 != b && bi) return !1
};
vh.onkeyup = function(a) {
	var b = a.keyCode;
	65 <= b & 90 >= b ? a.shiftKey || (b += 32) : b = a.shiftKey ? cf[b] : bf[b];
	0 <= b && 256 > b && (af[b] = !1);
	if (0 != b && bi) return !1
};
var bi = !1,
	wg = "",
	yg = new wa,
	Fg = Array(100),
	Eg = 0,
	di = zg(80, 79, 83, 84),
	Ag = zg(38, 98, 61),
	Bg = zg(38, 99, 61),
	Cg = zg(38, 100, 61),
	Gg = zg(38, 101, 61);
zg(38, 102, 61);
zg(38, 103, 61);
zg(38, 104, 61);
zg(38, 105, 61);
zg(38, 106, 61);
zg(38, 107, 61);
zg(111, 107);
var Wh = zg(69, 82, 82, 79, 82),
	ei = zg(61),
	fi = zg(10),
	gi = zg(67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101),
	hi = zg(97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 120, 45, 119, 119, 119, 45, 102, 111, 114, 109, 45, 117, 114, 108, 101, 110, 99, 111, 100, 101, 100);

function Dg(a) {
	for (var b = Eg = 0; 100 > b; b++) Fg[b] = "";
	try {
		var c = new XMLHttpRequest;
		c.onreadystatechange = function() {
			if (4 == c.readyState)
				if (200 == c.status) {
					var a, b, d = 0,
						r = c.responseText.length;
					for (a = 0; a < r; a++)
						if (b = c.responseText[a], b == ei) {
							for (a += 1; a < r; a++) {
								b = c.responseText[a];
								if (b == fi) break;
								Fg[d] += b
							}
							d++
						} else
							for (; a < r && c.responseText[a] != fi; a++);
					Eg = 1
				} else Eg = -1
		};
		c.open(di, a, !0);
		c.setRequestHeader(gi, hi);
		c.send("")
	} catch (d) {
		Eg = -2
	}
}

function Qg() {
	this.y = this.x = 0
}
Qg.prototype.set = function(a) {
	this.x = a.x;
	this.y = a.y;
	return this
};

function Rg(a, b, c) {
	a.x = b;
	a.y = c
}
Qg.prototype.add = function(a) {
	this.x += a.x;
	this.y += a.y;
	return this
};

function eh(a, b, c) {
	a.x = b.x + c.x;
	a.y = b.y + c.y
}
Qg.prototype.sub = function(a) {
	this.x -= a.x;
	this.y -= a.y;
	return this
};
Qg.prototype.q = function(a, b) {
	this.x = a.x - b.x;
	this.y = a.y - b.y;
	return this
};

function Tg(a, b) {
	a.x *= b;
	a.y *= b
}

function dh(a) {
	var b = a.x;
	a.x = a.y;
	a.y = -b
}

function Sg(a) {
	return Math.sqrt(a.x * a.x + a.y * a.y)
}

function Xg(a) {
	var b = Sg(a);
	if (0 == b) return 0;
	a.x /= b;
	a.y /= b;
	return b
}

function Vg(a) {
	var b = Math.acos(a.x / Math.sqrt(a.x * a.x + a.y * a.y));
	0 < a.y && (b = Wg - b);
	return b
}
var df = new Float32Array(1024),
	ef = 0,
	ff = 0;

function A(a) {
	ef += ff;
	ef &= 1023;
	return df[ef] * a
}

function N(a, b) {
	ef += ff;
	ef &= 1023;
	return df[ef] * (b - a) + a
}

function Kf(a, b) {
	ef += ff;
	ef &= 1023;
	return 0.5 > df[ef] ? a : b
}

function $g(a) {
	ef += ff;
	ef &= 1023;
	return ~~(df[ef] * a)
}
var Xe = Array(513),
	Ye = 3.1415927,
	Wg = 6.2831855;

function Kg(a) {
	return 0 > a ? -a : a
}

function ig(a, b) {
	return a > b ? a : b
}

function K(a, b, c) {
	return a < b ? b : a > c ? c : a
}

function Zf(a, b, c) {
	return a < b ? c : a > c ? b : a
}

function z(a) {
	return Math.floor(a)
};
